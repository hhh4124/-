정보처리기사 중요부분 요약


1. 소프트웨어 생명주기 모델(SDLC: Software Development Life Cycle)
  ㄴ 소프트웨어 생명주기는 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차.
  
 가. 소프트웨어 생명주기 모델 프로세스
  ㅇ 요설구테유
    - 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 

 나. 소프트웨어 생명주기 모델 종류
   ㅇ 폭프나반: 폭포수 모델, 프로토타이핑 모델, 나선형 모델, 반복적 모델
     1) 폭포수 모델
      - 폭포수 모델은 가장 오래된 모델이자 순차적 모형, 성공 사례가 많고 산출물이 명확하지만 요구사항 변경이 어려움 
      - 절차: 타당성 검토 -> 계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수
  
     2) 나선형 모델
      - 시스템 개발 시 위험을 최소화 하기 위해 점진적으로 완벽한 시스템으로 개발해나가는 모델
      - 절차: 계획 및 정의 -> 위험 분석 -> 개발 -> 고객 평가
  
     3) 프로토 타이핑 모델 
      - 고객이 요구한 주요 기능을 프로토타입으로 구현하여, 고객의 피드백을 반영하여 소프트웨어를 만들어가는 모델
      - 프로토 타입은 발주자나 개발자 모두에게 공동의 참조모델 제공
   
     4) 반복적 모델
      - 구축 대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적을 개발하여 점증 완성시키는 모델

 다. 소프트웨어 개발 방법론
  ㄴ 소프트웨어 개발 방법론은 소프트웨어 개발 전 과정에 지속적으로 적용할 수 있는 방법, 절차, 기법이다.
    SW를 하나의 생명체로 간주하고 개발의 시작부터 시스템을 사용하지 않는 과정까지의 전 과정 형상화
  
   ㅇ 소프트웨어 개발 방법론 종류
     - 구정객컴애제: 구조적, 정보공학, 객체지향, 컴포넌트 기반, 애자일, 제품 계열 방법론
   가. 구조적 방법론
     - 전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 분할과 정복  접근 방식의 방법론
     - 프로세스 중심의 하향식 방법론
     - 나씨-슈나이더만 차트 사용(논리의 기술에 중점을 둔 도형식 표현 방법, 연속, 선택 및 다중선택, 반복 등의 제어 논리 구조로 표현, 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합)
   나. 정보공학 방법론
     - 정보시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
     - 개발 주기를 이용해 대형 프로젝트를 수행하는 체계적인 방법론
   다. 객체지향 방법론
     - 객체라는 기본 단위로 시스템을 분석 및 설계하는 방법론
     - 복잡한 현실 세계를 사람이 이해하는 방식으로 시스템에 적용, 객체, 클래스, 메시지 사용ㅓㅓ
   라. 컴포넌트 기반 방법론
     - 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
     - 개발 기간 단축으로 생산성 향상, 새로운 기능 추가 쉬움, 소프트웨어 재사용 가능
   마. 애자일 방법론
     - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론
     - 애자일은 개발 과정의 어려움을 극복하기 위해 적극적으로 모색한 방법론
   바. 제품 계열 방법론
     - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
     - 임베디드 소프트웨어를 작성하는 데 유용한 방법론
     
  ㅁ 애자일 방법론의 개념
   ㅇ 애자일 방법론은 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발 방법론이다.
   ㅇ 개발기간이 짧고 신속하며, 폭포수 모형에 대비되는 방법론으로 개발과 함께 즉시 피드백을 받아서 유동적으로 개발할 수 있다. 
   
   ㅇ 애자일 방법론은 대표적으로 XP, 린(Learn), 스크럼(SCRUM) 등이 있다.
   ㅇ XP(extrema Programming)
    - XP의 5가지 가치: 용단의피존(용기, 단순성, 의사소통, 피드백, 존중)
    - XP 12가지 기본원리: 짝 프로그래밍, 공동 코드 소유, 지속적인 통합, 계획 세우기, 작은 릴리즈, 메타포어, 간단한 디자인, 테스트 기반 개발, 리팩토링, 40시간 작업, 고객 상주, 코드 표준
   ㅇ 스크럼
    - 백로그, 스프린트, 스크럼 미팅, 스크럼 마스터, 스프린트 회고, 번 다운 차트
   ㅇ 린
    - 도요타의 린 시스템 품질 기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론
    - JIT, 칸반 보드 사용
    - 7가지 원칙: 낭품지늦빠사전 - 낭비제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화

2. 비용산정 모형
  ㄴ 비용산정 모형은 소프트웨어 규모파악을 통한 투입자원, 소요시간을 파악하여 실행 가능한 계획을 수립하기 위해 비용을 산정하는 방식이다.
  ㄴ 하향식 산정방법, 상향식 산정방법이 있다.
  ㄴ 하향식 산정 방법에는 델파이 기법, 전문가 판단이 있다.
  
  ㄴ 상향식 산정방법에는 코드라인 수(Loc), Man Month COCOMO 푸트남 기능점수(FP)모형이 있따.

  가. Loc(Lines of Code) 모형: 소프트웨어 각 기능의 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구하여 비용을 산정하는 방식, 측정이 쉽고 이해하기 쉬워 많이 사용된다.
  낙관치 + 4중간치 + 비관치 / 6

  나. Moan Month 모형은 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 프로젝트 비용을 산정하는 방식
     MM = Loc/월간 생산성, 프로젝트 기간 = MM/프로젝트 인력
  다. COCOMO 모형: 보헴이 제안한 ㅁ형으로 프로그램 규모에 따라 비용을 산정하는 방식. 비용산정 결과는 Man Month로 산정
     규모에 따라 조직형, 반분리형, 임베디드형으로 나뉜다.(Organic, Semi-Detached, Embedded)
  라. 푸트남 모형: 소프트웨어 개발주기의 단계별로 요구할 인력의 분포를 가정하는 방식, 푸트남이 제안한 것으로 생명주기 예측 모형이라고 한다. Rayleigh-Norden 곡선의 노력 분포도를 기준으로 한다.
  마. 기능점수(Function Point) 모형: 요구 기능을 증가시키는 인자별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능점수 계산하여 비용을 산정하는 방식 경험을 바탕으로 단순, 보통, 복잡에 따라 가중치 부여
  
3. 일정관리 모델
주 공정법, PERT, 중요 연쇄 프로젝트 관리가 있다.
CPM 일정계산 - 가장 긴 경로 계싼
PERT - 비관치, 중간치, 낙관치의 3점 추정방식을 통해 일정을 관리하는 기법
CCPM - CPM으로 자원제약사항을 고려하여 일정을 작성

4. 소프트웨어 아키텍쳐
 ㄴ 소프트웨어 아키텍처는 여러가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체이다.
 ㄴ 소프트웨어 아키텍쳐 프레임워크: 소프트웨어 집약적인 시스템에서 아키텍처가 표현해야하는 내용 및 이들 간의 관계를 제공하는 아키텍처 기술 표준이다.
 ㄴ 소프트웨어 아키텍처 구성요소: 아키텍처 명세서, 이해관계자, 관심사, 관점, 뷰, 근거, 목표, 환경, 시스템

5. 소프트웨어 아키텍처 4+1뷰
 ㄴ 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법
 ㄴ 4개의 분리된 구조로 구성되는 아키텍처 개념을 제시하고, 서로 충돌되거나 요구사항 충족을 증명하기 위해 유스케이스를 사용
 ㄴ 구성요소: 유논프구배(유스케이스뷰, 논리뷰, 프로세스뷰, 구현뷰, 배포뷰)

6. 소프트웨어 아키텍처 패턴
 ㄴ 소프트웨어를 설계할 때 참조할 수 있는 전형적인 해결 방식.
 ㄴ 일반화되고 재사용 가능한 솔루션
 ㄴ 패턴유형: 계층화 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 브로커 패턴, 모델-뷰-컨트롤러 패턴(MVC)

7. 소프트웨어 아키텍처 비용 평가 모델
 ㄴ SAAM, ATAM, CBAM, ADR, ARID

8. 디자인 패턴
 ㄴ 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴
 ㄴ 개발 효율성, 유지보수성, 운용성, 프로그램 최적화
 ㄴ 구성요소: 패문솔 사결샘(패턴의 이름, 문제 및 배경, 솔루션, 사례, 결과, 샘플코드)

9. 디자인 패턴 유형
 목적 - 생성, 구조, 행위 / 범위 - 클래스, 객체

10. 디자인 패턴 종류
 생성 - Builder, Prototype, Factory Method, Abstract Factory, Singleton
 구조 - Bridge, Decorator, Facade, Flyweight, Proxy, Composite, Adapter
 행위 - Mediator, Interpreter, Iterator, Template Method, Observer, State, Visitor, Command, Strategy, Memento, Chain of Responsibility

11. 현행 시스템 분석서 작성 및 검토
 ㄴ 분석 산출물의 종류: 현기인 아소하네(정보시스템 구성 현황, 정보 시스템 기능 구성도, 인터페이스 현황, 현행 시스템 아키텍처 구성도, 소프트웨어 구성도, 하드웨어 구성도, 네트워크 구성도)
 ㄴ 각 구성도의 사례 확인

12. 운영체제 개념: 컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있도록 해주고, 사용자와 하드웨어간 인터페이스 담당
 ㄴ 현행 시스템 분석
   품질측면 - 신뢰도, 성능
   지원측면 - 기술지원, 주변기기, 구축비용

13. 운영체제 종류 및 특징
 ㄴ PC - 윈도우, 유닉스, 리눅스 / 모바일 - 안드로이드, iOS

14. 네트워크 현행 시스템 분석
 ㄴ 네트워크 개념: 컴퓨터 장치들의 노드 간 연결(데이터 링크)을 사용하여 서로에게 데이터를 교환할 수 있도록 하는 기술
 OSI 7계층: 네트워크 통신에서 생긴 여러가지 충돌 문제를 완화하기 위해 국제 표준화 기구(ISO)에서 제시한 네트워크 기본 모델

 OSI 7계층 구성요소: Application, Presentation, Session, Transport, Network, Data Link, Physical
 
 네트워크 현행 시스템 분석: 네트워크 구조를 구성도를 통해 분석
 백본망, 라우터, 스위치, 게이트웨이, 방화벽 등을 대상으로 분석

15 DBMS 형행 시스템 분석
 - 가성호기구(성능 측면 - 가용성, 성능, 상호 호환성 / 지원 측면 - 기술 지원, 구축 비용)

16. 미들웨어 현행 시스템 분석: 가성기구(성능 측면: 가용성, 성능 / 지원 측면 - 기술 지원, 구축 비용)


17. 요구사항 확인
 - 요구공학: 사용자의 요구가 반영된 시스템을 개발하기 위하여 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동
 - 요구공학의 목적: 이해관계자 사이 효과적인 의사소통 수단 제공, 공통된 이해 설정, 요구사항 누락 방지 및 이해 오류로 인한 불필요한 비용 절감, 요구사항 변경 추적, 개발 비용 시간 절약
 - 요구사항의 분류: 기능적 요구사항(특성: 기완일 - 기능성, 완전성, 일관성) / 비기능적 요구사항(신사효유이보품제 - 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성, 품질 관련 요구사항, 제약사항)
 
18. 요구공학 프로세스: 도분명확(도출, 분석, 명세, 확인)

19. 요구사항 도출단계: 소프트웨어가 해결해야할 문제를 이해하고, 고갱르ㅗ 부터 제시되는 추상적 요구에 대해 관련 정보를 식별하고 수집방법 결정, 요구사항 구체적으로 표현하는 단계
 주요기법: 인터뷰, 브레인스토밍, 델파이, 롤 플레잉, 워크숍, 설문조사

20 요구사항 분석 단계: 요구사항 분석 단계는 추출된 요구사항에 대해 충돌, 중복, 누락 등의 분석을 통해 완전성과 일관성을 확보하는 단계
 분석 단계 절차: 요구사항 분류 -> 개념 모델링 생성 및 분석 -> 요구사항 할당 -> 요구사항 협상 -> 정형분석
 분석 단계 기법: 자료 흐름 지향 분석, 객체 지향 분석
 분석기술: 청취, 인터뷰와 질문, 분석, 중재, 관찰, 작성, 조직, 모델 작성

21. 요구사항 명세 단계: 체계적으로 검토, 평가, 승인될 수 있는 문서를 작성
 주요기법: 비정형 명세 기법, 정형 명세 기법
 산출물: 요구사항 명세서
 명세 원리 및 검증 항목: 명완검일수추개(명확성, 완전성, 검증 가능성, 일관성, 수정 용이성, 추적 가능성, 개발 후 이용성)

22. 요구사항 확인 및 검증 단계: 사용자의 요구가 올바르게 기술 되었는지에 대한 검토 / 요구사항을 이해했는지 확인(Validation)하고 욕사항 문서가 회사 표준에 적합한지, 일관성을 만족하는지, 완전한지 검증(Verification) 해야한다.

 ㄴ 요구사항 확인 및 검증 절차: 요구사항 목록 확인, 정의서 작성 여부 확인, 비기능적 요구사항 확인, 타 시스템 연계 및 인터페이스 요구사항 확인
 ㄴ 요구사항 확인 및 검증 단계의 주요기법 및 산출물: 
   - 요구사항 검토, 정형 기술 검토 활용(동료 검토, 워크스루, 인스펙션), 프로토 타이핑 활용, 모델 검증, 테스트 케이스 및 테스트를 통한 확인, CASE 도구 활용 검증, 베이스라인을 통한 검증, 요구사항 추적표

 - 상세 정형 기술 검토 기법: 관리 리뷰, 기술 리뷰, 인스펙션, 워크 스루, 감사

23. 요구사항 관리 단계: 프로젝트 진행 과정에서 발생하는 요구사항의 변경에 대해 일치성과 무결성을 제공하기 위해 변경제어와 추적 등 일련의 관리를 수행하는 활동
 주요산출물: 요구사항 변경요청서, 변경 승인서, 추적표

 - 요구사항 관리 단계 절차: 협기변확(요구사항 협상 -> 요구사항 기준선 설정 -> 요구사항 변경관리 -> 요구사항 확인 및 검증)

24. 분석모델 검증: 요구사항 도출 기법을 활용하여 업무 분석가가 제시한 분석 모델에 대해서 확인하는 활동
 ㄴ 분석모델 검증 방법: 유스케이스 모델 검증, 개념 수준의 분석 클래스 검증, 분석 클래스 검증


25. UI 요구사항 확인
 UI(User Interface) - 사용자와 시스템 사이에서 의사소통할 수 있도록 고안된 물리적, 가상의 매개체이다. 정보기기나 소프트웨어의 화면 등에서 사람이 접하게 되는 화면
 UX(User eXperience) - 제품과 시스템, 서비스 드응ㄹ 사용자가 직/간접적으로 경험하면서 느끼고 생각하는 총체적 경험

26. UI 유형: CLI, GUI, NUI, OUI
 CLI - 정적인 텍스트 기반, GUI - 그래픽 반응 기반, NUI - 직관적 사용자 반응 기반, OUI - 유기적 상호작용 기반
27. UI 설계원칙: 직유학유(직관성, 유효성, 학습성, 유연성)

28. UI 설계지침: 사일단결 가표접명오(사용자 중심, 일관성, 단순성, 결과 예측 가능, 가시성, 표준화, 접근성, 명확성, 오류 발생 해결)

29. UI 품질 요구사항: 기신사효유이(기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성)
 
30. UI 표준: 디자인 철학과 원칙 기반 하에 전체 시스템에 공통으로 적용되는 화면 간 이동, 화면구성 등에 관한 규약
 ㄴ UI 표준 구성: 액정스패조(전체적인 UX원칙, 정책 및 철학, UI 스타일 가이드, uI 패턴 모델 정의, UI표준 수립을 위한 조직 구성
 ㄴ CRUD 방식: 대부분의 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create, Read, Update, Delete를 묶어서 이르는 말

31. UI 개발을 위한 주요 기법: 3C 분석, SWOT 분석, 시나리오 플래닝, 사용성 테스트, 워크숍

32. 사용자 요구사항 도출: 페르소나 정의, 콘셉트 모델 정의, 사용자 요구사항 정의, UI컨셉션

33. 스토리보드 개념: UI 화면 설계를 위해서 정책이나 프로세스 및 콘텐츠의 구성, 와이어 프레임(UI, UX), 기능에 대한 정의, 데이터 베이스의 연동 등 구축하는 서비스를 위한 대부분 정보가 수록된 문서, 디자이너와 개발자가 최종적으로 참고하는 산출 문서

34. UI 화면설계 구분: 와스프(와이어 프레임, 스토리보드, 프로토타입)
 ㄴ 와이어 프레임: 이해 관계자들과의 화면구성을 협의하거나 서비스의 간략한 흐름을 공유하기 위해 화면 단위의 레이아웃을 설계하는 작업
 ㄴ 스토리보드: 정책, 프로세스, 콘텐츠 구성, 와이어 프레임, 기능 정의, 데이터베이스 연동 등 서비스 구축을 위한 모든 정보가 담겨 있는 설계 산출물
 ㄴ 프로토타입: 정적인 화면으로 설계된 와이어 프레임 또는 스토리보드에 동적 효과를 적용하여 실제 구현된 것처럼 시뮬레이션 할 수 있는 모형

35. UI 설계를 위한 UML
 ㄴ UML 개념: 객체지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화 할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어
 ㄴ UML 특징: 가구명문(가시화 언어, 구축 언어, 명세화 언어, 문서화 언어)
 ㄴ 가시화 언어: 개념 모델 작성 시 오류가 적고 의사소통 용이
 ㄴ 구축 언어: 다양한 프로그래밍 언어로 실행 시스템의 예측 가능, UML을 소스 코드로 변환하여 구축 가능, 역 변환하여 역공학 가능
 ㄴ 명세화 언어: 정확한 모델 제시, 완전한 모델 작성 가능
 ㄴ 문서화 언어: 시스템에 대한 평가 및 의사소통의 문서

36. UML 구성요소: 사관다(사물 관계 다이어그램)
 ㄴ 사물: 추상적인 개념으로, 주제를 나타내는 요소, 단어 관점에서 '명사'또는 '동사'를 의미
 ㄴ 관계: 사물의 의미를 확장하고 명확히 하는 요소, 사물과 사물을 연결하여 관계를 표현하는 요소, 단어 관점에서 '형용사'또는 '부사'를 의미
 ㄴ 다이어그램: 사물과 관계를 모아 그림으로 표현한 형태, 형식과 목적에 따라 9가지로 정의

37. UML 다이어그램: 구분에 따라 구조적(정적) 다이어그램과 행위적(동적) 다이어그램으로 구분된다.
 ㄴ 구조적(정적) 다이어그램: 클객 컴배 복패(클래스, 객체, 컴포넌트, 배치, 복합체 구조, 패키지)
 ㄴ 행위적(동적) 다이어그램: 유시커 상활타(유스케이스, 시퀀스, 커뮤니케이션, 상태, 활동, 타이밍)

38. UML 확장 모델의 스테레오 타입: UML 기본 요소 이외의 새로운 요소를 만들어내기 위한 확장 메커니즘, 형태는 기존 UML 요소를 그대로 사용하지만 내부 의미는 다른목적으로 사용, <<>>길러멧 기호를 사용하여 표현한다.

39. 클래스 다이어그램: 객체지향 모델링 시 클래스의 속성 및 연산과 클래스 간 정적인 관계를 표현한 다이어그램
 ㄴ 구성요소: 클래스, 속성, 연산, 접근제어자(-, +, #, ~)
 ㄴ 클래스 간의 관계: 연집복 일의실(연관 집합 복합 일반화 의존 실체화)


40. 유스케이스 다이어그램: 시스템이 제공하고 있는 기능 및 그와 관련된 외부 요소를 사용자의 관점에서 표현하는 다이어그램
 ㄴ 구성요소: 유스케이스, 액터, 시스템, 시나리오, 이벤트의 흐름
 ㄴ 유스케이스 다이어그램의 관계: 포함관계, 확장관계, 일반화관계

41. 시퀀스 다이어그램: 객체 간 상호작용을 메시지 흐름으로 표현한 다이어그램, 객체 간의 동적 상호작용을 시간적 개념을 중심으로 모델링하는 과정이다.
      		 객체의 오퍼레이션과 속성을 상세히 정의해야 한다. 유스케이스를 실현한다.
 ㄴ 구성요소: 객생실메(객체, 생명선, 실행, 메시지)

42. 패키지 다이어그램: 시스템의 서로 다른 패키지들 사이의 의존 관계를 표현하기 위한 다이어그램
 ㄴ 구성요소: 패키지, 의존관계

43. 활동 다이어그램: 시스템이 어떤 기능을 수행하는지를 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서대로 표현하는 다이어그램, 오퍼레이션이나 처리과정이 수행되는 동안 일어나는 일들을 단계적으로 표현한다. 활동 다이어그램은 하나의 유스케이스 안이나, 유스케이스 사이에서 발생하는 복잡한 처리의 흐름을 명확하게 표현할 수 있다.
 ㄴ 구성요소: 시작점, 전이, 액션/액티비티, 종료점, 조건(판단)노드, 병합노드, 포크노드, 조인노드, 구획면

44. 상태다이어그램: 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호작용에 따라 상태가 어떻게 변화하는지 표현하는 다이어그램. 어떤 이벤트에 의해 객체 자신이 속한 클래스의 상태 변화나 객체 간 상호작용을 하는 과정에서의 상태 변화를 표현한다. 객체는 파악된 상태들 이외의 상태는 가질 수 없고, 특정 순간에는 오직 한 상태로만 존재할 수 있다. 객체의 상태란 객체가 갖는 속성값의 변화이다. 
 ㄴ 구성요소: 상태, 시작상태, 종료상태, 전이, 이벤트, 전이조건

45. 커뮤니케이션 다이어그램: 시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하고, 메시지 뿐만 아니라 객체 간의 연관까지 표현하는 다이어그램이다. 커뮤니케이션 다이어그램은 시스템이나 객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호작용하는 과정을 표현한 다이어그램
 ㄴ 구성요소: 액터, 객체, 링크, 메시지

46. 컴포넌트 다이어그램: 시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존 관계를 나타내는 다이어그램이다. 코드 컴포넌트 기반의 물리적 구조료 표현된다. 실질적 프로그래밍 작업에 사용된다.
 ㄴ 구성요소: 컴포넌트, 인터페이스, 의존관계

47. UI 시나리오 문서의 작성 요건: 완일이가 추수(완전성 일관성 이해성 가독성 추적용이성 수정용이성)

48. 데이터 모델: 현실 세계의 정보를 인간과 컴퓨터가 이애할 수 있도록 추상화하여 표현한 모델
 ㄴ 표시해야할 요쇠: 논리적 데이터 구조, 연산, 제약조건

49. 데이터 모델 절차: 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델
 ㄴ 개념적: 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 데이터 모델, 트랜잭션 모델링, View 통합방법 및 Attribute 합성 고려, DB 종류 관계 X, 주요산출물로는 개체관계 다이어그램이 있다.
 ㄴ 논리적: 업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현한 데이터 모델, 논리적 데이터 몰델을 통해 관계 데이터 모델, 계층 데이터 모델, 네트워크 데이터 모델, 객체지향 데이터 모델, 객체-관계 데이터 모델 중 하나의 모델에 맞게 설계, 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계, 정규화 수행, 매핑, 스키마의 평가 및 정제
 ㄴ 물리적: 논리 데이터 모델을 특정 DBMS의 특성 및 성능을 고려하여 물리적인 스키마를 만드는 일련의 데이터 모델. 각 DBMS의 특성을 고려하여 데이터베이스 저장 구조로 변환, 테이블 인덱스, 뷰, 파티션 등 객체를 생성, 응답시간, 저장 공간의 효율화, 트랜잭션 처리를 고려하여 설계, 성능 측면에서 반 정규화를 수행, 레코드 집중의 분석 및 설꼐, 저장 레코드 양식 설계, 접근 경로 설계

50. 논리 데이터 모델 검증: 업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현하는 프로세스, 개념 모델로부터 업무 영역의 업무 데이터 및 규칙을 구체적으로 표현한 모델

51. 논리적 데이터 모델링 종류
 ㄴ 관계 데이터 모델: 논리적 구조가 2차원 테이블 형태로 구성된 모델, 기본 키와 이를 참조하는 외래 키로 관계 표현 1:1, 1:N, N:M	 관계를 자유롭게 표현
 ㄴ 계층 데이터 모델: 논리적 구조가 트리 형태로 구성된 모델, 상하 관계 존재(부모-자식), 1:N 관계만 허용
 ㄴ 네트워크 데이터 모델: 논리적 구조가 그래프 형태로 구성된 모델, CODASYL DBTG 모델이라고 불림, 상위와 하위 레코드 사이에 다대다(N:M) 관계를 만족하는 구조

52. 관계 데이터 모델의 구성
 ㄴ 릴레이션: 행과 열로 구성된 테이블
 ㄴ 튜플: 릴레이션의 행(Row)에 해당되는 요소
 ㄴ 속성: 릴레이션의 열(Column)에 해당되는 요소
 ㄴ 카디널리티: 튜플의 수
 ㄴ 차수: 애트리뷰트의 수
 ㄴ 스키마: 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조  

53. 관계 대수: 데이터베이스에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 정형 언어이다.
 ㄴ 관계대수 연산자의 종류는 일반 집합 연산자와 순수 관계 연산자로 나뉘어짐
 ㄴ 일반집합연산자의 종류: 합교차카(합집합, 교집합, 차집합, 카디션 프로덕트)
 ㄴ 순수관계연산자의 종류: 셀프조디(셀렉트, 프로젝트, 조인, 디비전)

54. 관계해석: 관계 해석은 튜플 관계 해석과 도메인 관계 해석을 하는 비절차적 언어
 ㄴ 특징: 프레디킷 해석(Predicate Calculus)에 기반한 언어이며 비절차적 언어(원하는 정보가 무엇이라는 것만 선언)이다.

55. 논리 데이터 모델링 속성: 개속관(개체, 속성, 관계)
 ㄴ 개체: 개체는 사물 또는 사건이라고 정의. 피터 챈 모델에서는 개체를 사각형으로 표시, 까마귀발 모델에서는 개체를 표 형식으로 표시
 ㄴ 속성: 개체가 가지고 있는 요소 또는 성질이다. 피터 챈 모델에서는 속성을 타원형으로, 까마귀발 모델에서는 속성을 표 내부에 표시.
 ㄴ 관계: 두 개체 간의 관계를 정의, 피터 챈 모델에서는 관계를 마름모로, 까마귀발 모델에서는 관계를 그림과 같이 표시(그림 참조)

56. 개체-관계(E-R) 모델: 현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 표현하기 위해 가장 널리 사용되고 있는 모델, 논리 데이터 모델링에서는 모든 이해당사자와 의사소통의 보조 자료로 E-R 모델 활용. 
 ㄴ 기호: 개체-사각형, 관계-마름모, 속성-타원, 다중 값 속성-이중 타원, 관계와 속성을 연결-선

57. 정규화: 정규화는 관계형 데이터 모델에서 데이터의 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성과 정확성을 유지하기 위해 무손실 분해하는 과정이다.

58. 이상현상: 데이터 중복성으로 인해 릴레이션을 조작할 때 발생하는 비합리적 현상, 삽삭갱(삽입, 삭제, 갱신)이 있다.
 ㄴ 삽입 이상: 정보 저장 시 해당 정보의 불필요한 세부정보를 입력해야 하는 경우
 ㄴ 삭제 이상: 정보 삭제 시 원치 않는 다른 정보가 같이 삭제되는 경우
 ㄴ 갱신 이상: 중복 데이터 중에서 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우

59. 데이터베이스 정규화 단계: 원부이결다조(원자화, 부분함수 종속 제거, 이행함수 종속 제거, 결정자 함수 종속 제거, 다치 종속 제거, 조인 종속 제거)

60. 반 정규화: 정규화된 엔터티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법이다
 ㄴ 장점: 반 정규화된 데이터 구조는 성능 향상과 관리의 효율성이 증가
 ㄴ 단점: 데이터의 일관성 및 정합성 저하, 유지를 위한 비용이 별도로 발생하여 성능에 나쁜 영향을 미칠 수 있음

61. 반 정규화 기법: 테병분중 컬중 관중( 테이블- 병합/분할/중복, 컬럼- 중복, 관계- 중복)

62. 물리 데이터 모델링: 논리모델을 적용하고자 하는 기술에 맞도록 상세화해가는 과정이다.

63. 논리 데이터 저장소에서 물리 데이터 저장소로 모델링 변환 절차: 계속U관컬반(개체를 테이블로 변환, 속성을 컬럼으로 변환, UID를 기본키로 변환, 관계를 외래키로 변환, 컬럼 유형과 길이 정의, 반 정규화 수행)

64. 참조 무결성 제약조건: 릴레이션과 릴레이션 사이에 대해 참조의 일관성을 보장하기 위한 조건, 두 개의 릴레이션이 기본키, 외래키를 통해 참조관계를 형성할 경우, 참조 하는 외래키의 값은 항상 참조되는 릴레이션에 기본키로 존재해야 한다.
 ㄴ 제한: 참조 무결성 원칙을 위배하는 연산을 거절하는 옵션
 ㄴ 연쇄: Cascade 참조되는 릴레이션에서 튜플을 삭제하고, 참조되는 릴레이션에서 이 튜플을 참조하는 튜플들도 함께 삭제하는 옵션
 ㄴ 널값: Nullify 참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 릴레이션에서 해당 튜플을 참조하는 튜플들의 외래 키에 NULL값을 넣는 옵션.

65. 인덱스: 검색 연산의 최적화를 위해 데이터베이스 내 열에 대한 정보를 구성한 데이터구조, 전체 데이터의 검색 없이 필요한 정보에 대해 신속한 조회가 가능하다.
 ㄴ 적용기준: 인덱스 분포도가 10~15% 이내인 경우 아래 수식 참고((분포도 = 1 / 컬럼 값의 종류) x 100), 분포도 = (컬럼 값의 평균 Row 수 / 테이블의 총 Row 수) x 100
           분포도가 범위 이상이더라도 부분처리를 목적으로 하는 경우 적용, 조회 및 출력 조건으로 사용되는 컬럼일 경우 적용

66. 분포도: 특정 컬럼의 데이터가 테이블에 평균적으로 분포되어 있는 정도,=

67. 인덱스 컬럼 선정: 분포도가 좋은 컬럼은 단독적으로 생성한다. 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성, 가능한 수정이 빈번하지 않은 컬럼을 선정 등

68. 설계 시 고려 사항: 지나치게 많은 인덱스는 오버헤드로 작용한다. 인덱스는 추가적인 저장 공간이 필요함을 고려해야 한다, 넓은 범위 인덱스 처리시 오히려 전체 처리보다 더 많은 오버해드 발생시킬 수 있음, 인덱스와 테이블의 저장 공간을 적절히 분리 될 수 있도록 설계해야한다.

69. 뷰속성
 ㄴ REPLACE: 뷰가 이미 존재하는 경우 재생성
 ㄴ FORCE: 본 테이블의 존재 여부에 관계없이 뷰 생성
 ㄴ NOFORCE: 기본 테이블이 존재할 떄 뷰 생성
 ㄴ WITH CHECK OPTION: 서브쿼리 내의 조건을 만족하는 행만 변경
 ㄴ WITH READ ONLY: 데이터 조작어 작업 불가

70. 클러스터 적용기준
 ㄴ 인덱스의 단점을 해결한 기법으로, 분포도가 넓을 수록 오히려 유리하다.
 ㄴ 엑세스 기법이 아니라 엑세스 효율 향상을 위한 물리적 저장 방법이다.
 ㄴ 분포도가 넓은 테이블의 클러스터링은 저장 공간의 절약이 가능하다.
 ㄴ 대량의 범위를 자주 엑세스 하는 경우 적용한다.
 ㄴ 인덱스를 사용한 처리 부담이 되는 넓은 분포도에 활용한다.
 ㄴ 여러개의 테이블이 빈번하게 조인을 일으킬 때 활용한다.

71. 파티션 종류: 레해리컴
 ㄴ 레인지 파티셔닝: 연속적인 숫자나 날짜를 기준으로 하는 파티셔닝 기법, 손쉬운 관리 기법을 제공하여 관리 시간의 단축이 가능하다.
 ㄴ 해시 파티셔닝: 파티션 키의 해시 함수 값에 의한 파티셔닝 기법이다, 균등한 데이터 분할이 가능하고 질의 성능이 향상 가능하다.
 ㄴ 리스트 파티셔닝: 특정 파티션에 저장 될 데이터에 대한 명시적 제어가 가능한 파티셔닝 기법이다, 분포도가 비슷하고 데이터가 많은 SQL에서 컬러므이 조건이 많이 들어오는 경우 유용하다.
 ㄴ 컴포지트 파티셔닝: 레인지, 해시, 리스트 중 2개 이상의 파티셔닝을 결합하는 파티셔닝 기법이다. 큰 파티션에 대한 I/O 요청을 여러 파티션으로 분산할 수 있다.

72. 파티션의 장점: 성가백합(성능 향상, 가용성 향상, 백업 가능, 경합 감소)

73. 데이터베이스 개념
 ㄴ 다수의 인원, 시스템, 또는 프로그램이 사용할 목적으로 통합하여 관리되는 데이터의 집합이다.
 ㄴ 데이터에 대한 효과적인 관리를 위해 자료 중복성 제거, 무결성 확보, 일관성 유지, 유용성 보장이 중요하다.
 ㄴ 데이터베이스는 통합된 데이터, 저장된 데이터, 운영 데이터, 공용 데이터이다.

74. 데이터베이스 특성: 실시간 접근성, 계속적인 변화, 동시 공용, 내용 참조

75. RDBMS: Relational Database Management System: 관계형 모델을 기반으로 하는 가장 보편화된 데이터베이스 관리 시스템
 
76. DBMS(DataBase Management System) 개념
 ㄴ 데이터 관리의 복잡성을 해결하는 동시에, 데이터 추가, 변경, 검색, 삭제 및 백업, 복구, 보안 등의 기능을 지원하는 소프트웨어
 ㄴ 저장되는 정보는 텍스트, 이미지, 음악 파일, 지도 데이터 등 매우 다양하며, SNS의 발달과 빅 데이터의 폭 넓은 활용으로 인해 데이터의 종류와 양은 급격히 증가 중이다.

77. DBMS 유형: 키컬도그
 ㄴ 키-값(Key-Value) DBMS: 키 기반 Get/Put/Delete 제공, 메모리 기반에서 성능 우선 시스템 및 빅데이터 처리 가능. Unique한 키에 하나의 값을 가지고 있는 형태 ex) Redis, DynamoDB
 ㄴ 컬럼 기반 데이터 저장: Key 안에(Column, Value) 조합으로 된 여러 개의 필드를 가짐. 테이블 기반, 조인 미지원, 컬럼 기반으로 구글의 Bigtable 기반으로 구현 ex)HBase, Cassandra
 ㄴ 문서 저장: 값의 데이터 타입이 문서라는 타입을 사용. 문서 타입은 XML, JSON과 같이 구조화된 데이터 타입으로, 복잡한 계층 구조 표현 가능
 ㄴ 그래프: 시맨틱 웹과 온톨로지 분야에서 활용되는 그래프로 데이터를 표현하는 DBMS, 노드와 엣지로 특징되는 요소 특화, 노드 간 관계를 구조화하여 저장 ex) Neo4j, AllegroGraph

78. DBMS 특징: 데이터 무결성, 일관성, 회복성, 보안성, 효율성

79. 빅데이터: 시스템, 서비스, 조직(회사) 등에서 주어진 비용, 시간 내에 처리 가능한 데이터 범위를 넘어서는 수십 페타바이트 크기의 비정형 데이터이다.

80. 빅데이터 특성
 ㄴ 데이터의 양(Volume): 페타바이트 수준의 대규모 데이터, 빅데이터 분석 규모에 관련된 특성, 디지털 정보량이 기하급수적으로 폭증하는 것을 의미 
 ㄴ 데이터의 다양성(Variety): 정형, 비정형, 반정형의 다양한 데이터, 빅데이터 자원 유형에 관련된 특성, 로그, 소셜, 위치 등 데이터 유형이 다양해지는 것을 의미
 ㄴ 데이터의 속도(Velocity): 빠르게 증가하고 수집되며, 처리되는 데이터, 빅데이터 수집, 분석, 활용 속도와 관련된 특성, 가치있는 정보 활용을 위해 실시간 분석이 중요해지는 것을 의미

81. 빅데이터 수집, 저장, 처리 기술
 ㄴ 비정형/반정형 데이터 수집: 내외부 정제되지 않은 데이터를 확보, 이를 통해 필요 정보를 추출하여 활용하기 위해서 효과적으로 수집 및 전송하는 기술 ex) 척와, 플럼, 스크라이브
 ㄴ 정형 데이터 수집: 내외부 정제된 대용량 데이터의 수집 및 전송 기술 ex) ETL, FTP, 스쿱, 하이호
 ㄴ 분산데이터 저장/처리: 대용량 파일의 효과적인 분산 저장 및 분산 처리 기술 ex) HDFS, 맵 리듀스
 ㄴ 분산데이터 베이스: HDFS의 칼럼 기반 데이터베이스로 실시간 랜덤 조회 및 업데이트가 가능한 기술 ex) HBase

82. 빅데이터 분석, 실시간 처리 및 시각화를 위한 주요기술
 ㄴ 빅데이터 분석: 데이터 가공과 분류, 클러스터링, 패턴 분석을 처리하는 기술, 데이터 가공을 위한 대표적인 솔루션에는 피그, 하이브가 있고, 데이터 마이닝을 위한 대표적인 솔루션에는 머하웃가 있음
 ㄴ 실시간처리: 하둡 기반의 실시간 SQL질의 처리와 요청된 작업을 최적화하기 위한 워크플로우 관리 기술, 실시간 SQL 질의를 위한 대표적인 솔루션에는 임팔라가 있고, 워크플로우 관리를 위한 대표적인 솔루션은 우지가 있음
 ㄴ 분산 코디네이션: 분산 환경에서 서버들 간에 상호조정이 필요한 다양한 서비스를 분산 및 동시처리 제공 기술, 대표적인 솔루션은 주키퍼가 있음
 ㄴ 분석 및 시각화: 빅데이터 분석 기술을 통해 분석된 데이터의 의미와 가치를 시각적으로 표현하기 위한 기술, 대표적인 솔루션은 R이 있음

83. NoSQL(Not Only SQL) 개념: 전통적인 RDBMS와 다른 DBMS를 지칭하기 위한 용어로 데이터 저장에 고정된 테이블 스키마가 필요하지 않고 조인(Join) 연산을 사용할 수 없으며, 수평적으로 확장이 가능한 DBMS이다.

84. NoSQL 특성
 ㄴ Basically Available: 언제든지 데이터는 접근할 수 있어야 하는 속성, 분산 시스템이기 때문에 항상 가용성 중시
 ㄴ Soft-State: 노드의 상태는 내부에 포함된 정보에 의해 경정되는 것이 아니라 외부에서 전송된 정보를 통해 결정되는 속성, 특정 시점에서는 데이터의 일관성이 보장되지 않음
 ㄴ Eventually Consistency: 일정 시간이 지나면 데이터의 일관성이 유지되는 속성, 일관성을 중시하고 지향

85. 데이터 마이닝: 대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 기술, 대규모 데이터에서 의미 있는 패턴을 파악하거나 예측해서 의사결정에 활용하는 기법이다, 데이터의 숨겨진 정보를 찾아내어 이를 기반으로 서비스와 제품에 도입하는 과정, 통계분석은 가설이나 가정에 따른 분석, 검증을 하지만 데이터 마이닝은 수리 알고리즘을 활용하여 대규모 데이터에서 의미 있는 정보를 찾아낸다.

86. 데이터 마이닝 절차
 ㄴ 1단계: 목적 설정, 2단계: 데이터 준비, 3단계: 가공, 4단계: 마이닝 기법 적용, 5단계: 정보 검증

87. 데이터마이닝 주요 기법: 분연연데
 ㄴ 분류 규칙: 과거 데이터로부터 특성을 찾아내어 분류모형을 만들어 이를 토대로 새로운 레코드의 결과 값을 예측하는 기
 ㄴ 연관 규칙: 데이터 안에 존재하는 항목들 간의 종속 관계를 찾아내는 기법
 ㄴ 연속 규칙: 연관 규칙에 시간 관련 정보가 포함된 형태의 기법
 ㄴ 데이터 군집화: 대상 레코드들을 유사한 특성을 지닌 몇 개의 소그룹으로 분할하는 작업으로 작업의 특성이 분류규칙과 유사, 정보가 없는 상태에서 데이터를 분류하는 기법.

88. 연계 요구사항 분석의 개념: 서로 다른 두 시스템, 장치, 소프트웨어를 이어주는 중계 역할을 하는 연계 시스템과 관련된 요구사항을 분석하는 과정이다. 사용자 인터뷰 및 면담을 통해 식별되고 시스템 구성도, 테이블 정의서, 코드 정의서 등을 참고한다.

89. 요구사항 분석 기법: 인체설델브(인터뷰, 체크리스트, 설문지, 델파이 기법, 브레인스토밍)

90. 요구사항 분석 참고문서: 코테응시(코드 정의서, 테이블 정의서, 응용 프로그램 구성도, 시스템 구성도)

91. 인터페이스 명세서 구성요소: 인최크시데(인터페이스 ID, 최대 처리 횟수, 데이터 크기(평균/최대), 시스템 정보, 데이터 정보)

92. 연계 요구사항 분석 절차: 시스템 현황 확인, 정의서 확인, 체크리스트 작성, 인터뷰 및 면담, 연계 요구사항 분석서 작성

93. 연계 시스템의 구성: 송신 시스템, 수신 시스템, 중계 서버

94. 연계 데이터 표준화: 인터페이스 시스템 사이에서 교환되는 데이터는 규격화된 표준 형식을 정의하여 사용하여야 한다, 인터페이스 설계 단계에서 송수신 시스템 사이에 전송되는 표준항목과 업무처리 데이터, 공통 코드 정보 등을 누락 없이 식별하고 인터페이스 명세서를 작성해야 한다. 
 ㄴ 인터페이스 데이터 공통부, 개별부, 종료부로 구성된다.

95. 연계 메커니즘: 응용 소프트웨어와 연계 대상 모듈 간의 데이터 연계 시 요구사항을 고려한 연계방법과 주기를 설계하기 위한 메커니즘이다.

96. 연계 매커니즘 기능
 ㄴ 데이터를 생성하여 전송하는 송신 시스템과 송신 데이터를 수신하여 DB에 반영하는 수신 시스템으로 구성된다.
 ㄴ 송신 시스템은 운영 데이터베이스, 애플리케이션으로부터 연꼐 데이터를 연계 테이블 또는 파일로 생성하여 송신한다.
 ㄴ 수신 시스템은 송신 시스템으로부터 전송된 데이터를 변환 처리 후 데이터베이스에 반영한다.

97. 연계 방식
 ㄴ 직접연계 장점: 연계 및 통합 구현이 단순하며 용이, 개발 소요 비용 및 기간이 짧음, 중간 매개체가 없으므로 데이터 연계 처리 성능이 대체로 좋음
 ㄴ 직접연계 단점: 시스템 간 결합도가 높아 변경에 민감, 암복호화 처리 불가, 연계 및 통합 가능한 시스템 환경이 제한적
 ㄴ 간접연계 장점: 서로 상이한 네트워크, 프로토콜 연계 및 통합 가능, 인터페이스 변경시에도 장애나 오류 없이 서비스 가능, 보안이나 업무 처리 로직을 자유롭게 반영 가능
 ㄴ 간접연계 단점: 연계 아키텍처 및 메커니즘이 복잡해 성능 저하 요소 존재, 개발 및 적용을 위한 테스트 기간이 상대적 장기간 소요

98. 주요 연계 기술
 ㄴ 직접 - DB링크, DB연결, API/Open API, JDBC, 하이퍼링크
 ㄴ 간접 - 연계솔루션(EAI), Web Service/ESB, 소켓

 ㄴ DB 링크(Link): 데이터베이스에서 제공하는 DB 링크 객체를 이용, 수신 시스템에서 DB 링크를 생성하고 송신 시스템에서 해당 DB 링크를 직접 참조하는 방식
 ㄴ DB 연결(connection): 수신 시스템의 WAS(Web Application Server)에서 송신 시스템 DB로 연결하는 DB 커넥션 풀을 생성하고 연계 프로그램에서 해당 DB 커넥션 풀 명을 이용하여 연결
 ㄴ API/Open API: 송신 시스템의 DB에서 데이터를 읽어서 제공하는 애플리케이션 프로그래밍 인터페이스 프로그램
 ㄴ JDBC: 수신 시스템의 프로그램에서 JDBC 드라이버를 이용하여 송신 시스템 DB와 연결
 ㄴ 하이퍼링크: 현재 페이지에서 다른 부분으로 가거나, 전혀 다른 페이지로 이동하게 해주는 속성

 ㄴ 연계 솔루션: 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간의 정보 전달, 연계, 통합을 가능하게 해주는 솔루션 
 ㄴ Web Service/ ESB:  웹서비스가 설명된 WSDL과 SOAP 프로토콜을 이용한 시스템 간 연계
 ㄴ 소켓: 소켓을 생성하여 포트를 할당하고, 클라이언트의 요청을 연결하여 통신

99. EAI(Enterprise Application Integration)
 ㄴ EAI는 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계, 통합이 가능하도록 해주는 솔루션이다.
 ㄴ EAI를 사용함으로써 각 비즈니스 간 통합 및 연계성을 증대시켜 효율성을 높여 줄 수 있으며 각 시스템 간의 확장성을 높여줄 수 있다. 

100. EAI 구성요소: EAI 플랫폼, 어댑터, 브로커, 메시지 큐, 비즈니스 워크플로우

101. EAI 구축 유형: 포허메하(포인트 투 포인트, 허브 앤 스포크, 메세지 버스, 하이브리드)
 ㄴ 포인트 투 포인트: 기초적인 애플리케이션 통합방법, 1:1 단순 통합방법, 솔루션을 구매하지 않고 개발자 간 커뮤니케이션을 통해서도 통합가능
 ㄴ 허브 앤 스포크: 단일한 접점의 허브 시스템을 통하여 데이터를 전송하는 중앙 집중식 방식, 허브 장애 시 전체 장애 발생
 ㄴ 메시지 버스: 애플리케이션 사이 미들웨어를 두어 연계하는 미들웨어 통합 방식, 뛰어난 확장성과 대용량 데이터 처리 가능
 ㄴ 하이브리드: 그룹 내는 허브 앤 스포크 방식을 사용하고, 그룹 간에는 메시지 버스 방식을 사용한 통합 방식, 그룹 내 환경에 맞는 작업 가능

102. ESB(Enterprise Service Bus) 
 ㄴ 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간을 하나의 시스템으로 관리 운영할 수 있도록 서비스 중심의 통합을 지향하는 아키텍처, ESB는 미들웨어를 중심으로 각각 프로토콜이 호환할 수 있도록 애플리케이션의 통합을 느슨한 결합 방식으로 지원하는 방식
 ㄴ 느슨한 결합: 특정 서비스를 변경하더라도 연결된 다른 서비스에는 영향을 주지 않는 유연한 구조라는 의미
 
103. ESB 특징: 서비스들을 컴포넌트화된 논리적 집합으로 묶는 핵심 미들웨어이며, 비즈니스 프로세스 환경에 맞게 설계 및 전개할 수 있는 아키텍처 패턴이다. 버스방식으로 확장성, 유연한 아키텍처 구성이 가능하다.


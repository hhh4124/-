정보처리기사 중요부분 요약


1. 소프트웨어 생명주기 모델(SDLC: Software Development Life Cycle)
  ㄴ 소프트웨어 생명주기는 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차.
  
 가. 소프트웨어 생명주기 모델 프로세스
  ㅇ 요설구테유
    - 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 

 나. 소프트웨어 생명주기 모델 종류
   ㅇ 폭프나반: 폭포수 모델, 프로토타이핑 모델, 나선형 모델, 반복적 모델
     1) 폭포수 모델
      - 폭포수 모델은 가장 오래된 모델이자 순차적 모형, 성공 사례가 많고 산출물이 명확하지만 요구사항 변경이 어려움 
      - 절차: 타당성 검토 -> 계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수
  
     2) 나선형 모델
      - 시스템 개발 시 위험을 최소화 하기 위해 점진적으로 완벽한 시스템으로 개발해나가는 모델
      - 절차: 계획 및 정의 -> 위험 분석 -> 개발 -> 고객 평가
  
     3) 프로토 타이핑 모델 
      - 고객이 요구한 주요 기능을 프로토타입으로 구현하여, 고객의 피드백을 반영하여 소프트웨어를 만들어가는 모델
      - 프로토 타입은 발주자나 개발자 모두에게 공동의 참조모델 제공
   
     4) 반복적 모델
      - 구축 대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적을 개발하여 점증 완성시키는 모델

 다. 소프트웨어 개발 방법론
  ㄴ 소프트웨어 개발 방법론은 소프트웨어 개발 전 과정에 지속적으로 적용할 수 있는 방법, 절차, 기법이다.
    SW를 하나의 생명체로 간주하고 개발의 시작부터 시스템을 사용하지 않는 과정까지의 전 과정 형상화
  
   ㅇ 소프트웨어 개발 방법론 종류
     - 구정객컴애제: 구조적, 정보공학, 객체지향, 컴포넌트 기반, 애자일, 제품 계열 방법론
   가. 구조적 방법론
     - 전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 분할과 정복  접근 방식의 방법론
     - 프로세스 중심의 하향식 방법론
     - 나씨-슈나이더만 차트 사용(논리의 기술에 중점을 둔 도형식 표현 방법, 연속, 선택 및 다중선택, 반복 등의 제어 논리 구조로 표현, 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합)
   나. 정보공학 방법론
     - 정보시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
     - 개발 주기를 이용해 대형 프로젝트를 수행하는 체계적인 방법론
   다. 객체지향 방법론
     - 객체라는 기본 단위로 시스템을 분석 및 설계하는 방법론
     - 복잡한 현실 세계를 사람이 이해하는 방식으로 시스템에 적용, 객체, 클래스, 메시지 사용ㅓㅓ
   라. 컴포넌트 기반 방법론
     - 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
     - 개발 기간 단축으로 생산성 향상, 새로운 기능 추가 쉬움, 소프트웨어 재사용 가능
   마. 애자일 방법론
     - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론
     - 애자일은 개발 과정의 어려움을 극복하기 위해 적극적으로 모색한 방법론
   바. 제품 계열 방법론
     - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
     - 임베디드 소프트웨어를 작성하는 데 유용한 방법론
     
  ㅁ 애자일 방법론의 개념
   ㅇ 애자일 방법론은 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발 방법론이다.
   ㅇ 개발기간이 짧고 신속하며, 폭포수 모형에 대비되는 방법론으로 개발과 함께 즉시 피드백을 받아서 유동적으로 개발할 수 있다. 
   
   ㅇ 애자일 방법론은 대표적으로 XP, 린(Learn), 스크럼(SCRUM) 등이 있다.
   ㅇ XP(extrema Programming)
    - XP의 5가지 가치: 용단의피존(용기, 단순성, 의사소통, 피드백, 존중)
    - XP 12가지 기본원리: 짝 프로그래밍, 공동 코드 소유, 지속적인 통합, 계획 세우기, 작은 릴리즈, 메타포어, 간단한 디자인, 테스트 기반 개발, 리팩토링, 40시간 작업, 고객 상주, 코드 표준
   ㅇ 스크럼
    - 백로그, 스프린트, 스크럼 미팅, 스크럼 마스터, 스프린트 회고, 번 다운 차트
   ㅇ 린
    - 도요타의 린 시스템 품질 기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론
    - JIT, 칸반 보드 사용
    - 7가지 원칙: 낭품지늦빠사전 - 낭비제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화

2. 비용산정 모형
  ㄴ 비용산정 모형은 소프트웨어 규모파악을 통한 투입자원, 소요시간을 파악하여 실행 가능한 계획을 수립하기 위해 비용을 산정하는 방식이다.
  ㄴ 하향식 산정방법, 상향식 산정방법이 있다.
  ㄴ 하향식 산정 방법에는 델파이 기법, 전문가 판단이 있다.
  
  ㄴ 상향식 산정방법에는 코드라인 수(Loc), Man Month COCOMO 푸트남 기능점수(FP)모형이 있따.

  가. Loc(Lines of Code) 모형: 소프트웨어 각 기능의 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구하여 비용을 산정하는 방식, 측정이 쉽고 이해하기 쉬워 많이 사용된다.
  낙관치 + 4중간치 + 비관치 / 6

  나. Moan Month 모형은 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 프로젝트 비용을 산정하는 방식
     MM = Loc/월간 생산성, 프로젝트 기간 = MM/프로젝트 인력
  다. COCOMO 모형: 보헴이 제안한 ㅁ형으로 프로그램 규모에 따라 비용을 산정하는 방식. 비용산정 결과는 Man Month로 산정
     규모에 따라 조직형, 반분리형, 임베디드형으로 나뉜다.(Organic, Semi-Detached, Embedded)
  라. 푸트남 모형: 소프트웨어 개발주기의 단계별로 요구할 인력의 분포를 가정하는 방식, 푸트남이 제안한 것으로 생명주기 예측 모형이라고 한다. Rayleigh-Norden 곡선의 노력 분포도를 기준으로 한다.
  마. 기능점수(Function Point) 모형: 요구 기능을 증가시키는 인자별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능점수 계산하여 비용을 산정하는 방식 경험을 바탕으로 단순, 보통, 복잡에 따라 가중치 부여
  
3. 일정관리 모델
주 공정법, PERT, 중요 연쇄 프로젝트 관리가 있다.
CPM 일정계산 - 가장 긴 경로 계싼
PERT - 비관치, 중간치, 낙관치의 3점 추정방식을 통해 일정을 관리하는 기법
CCPM - CPM으로 자원제약사항을 고려하여 일정을 작성

4. 소프트웨어 아키텍쳐
 ㄴ 소프트웨어 아키텍처는 여러가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체이다.
 ㄴ 소프트웨어 아키텍쳐 프레임워크: 소프트웨어 집약적인 시스템에서 아키텍처가 표현해야하는 내용 및 이들 간의 관계를 제공하는 아키텍처 기술 표준이다.
 ㄴ 소프트웨어 아키텍처 구성요소: 아키텍처 명세서, 이해관계자, 관심사, 관점, 뷰, 근거, 목표, 환경, 시스템

5. 소프트웨어 아키텍처 4+1뷰
 ㄴ 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법
 ㄴ 4개의 분리된 구조로 구성되는 아키텍처 개념을 제시하고, 서로 충돌되거나 요구사항 충족을 증명하기 위해 유스케이스를 사용
 ㄴ 구성요소: 유논프구배(유스케이스뷰, 논리뷰, 프로세스뷰, 구현뷰, 배포뷰)

6. 소프트웨어 아키텍처 패턴
 ㄴ 소프트웨어를 설계할 때 참조할 수 있는 전형적인 해결 방식.
 ㄴ 일반화되고 재사용 가능한 솔루션
 ㄴ 패턴유형: 계층화 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 브로커 패턴, 모델-뷰-컨트롤러 패턴(MVC)

7. 소프트웨어 아키텍처 비용 평가 모델
 ㄴ SAAM, ATAM, CBAM, ADR, ARID

8. 디자인 패턴
 ㄴ 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴
 ㄴ 개발 효율성, 유지보수성, 운용성, 프로그램 최적화
 ㄴ 구성요소: 패문솔 사결샘(패턴의 이름, 문제 및 배경, 솔루션, 사례, 결과, 샘플코드)

9. 디자인 패턴 유형
 목적 - 생성, 구조, 행위 / 범위 - 클래스, 객체

10. 디자인 패턴 종류
 생성 - Builder, Prototype, Factory Method, Abstract Factory, Singleton
 구조 - Bridge, Decorator, Facade, Flyweight, Proxy, Composite, Adapter
 행위 - Mediator, Interpreter, Iterator, Template Method, Observer, State, Visitor, Command, Strategy, Memento, Chain of Responsibility

11. 현행 시스템 분석서 작성 및 검토
 ㄴ 분석 산출물의 종류: 현기인 아소하네(정보시스템 구성 현황, 정보 시스템 기능 구성도, 인터페이스 현황, 현행 시스템 아키텍처 구성도, 소프트웨어 구성도, 하드웨어 구성도, 네트워크 구성도)
 ㄴ 각 구성도의 사례 확인

12. 운영체제 개념: 컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있도록 해주고, 사용자와 하드웨어간 인터페이스 담당
 ㄴ 현행 시스템 분석
   품질측면 - 신뢰도, 성능
   지원측면 - 기술지원, 주변기기, 구축비용

13. 운영체제 종류 및 특징
 ㄴ PC - 윈도우, 유닉스, 리눅스 / 모바일 - 안드로이드, iOS

14. 네트워크 현행 시스템 분석
 ㄴ 네트워크 개념: 컴퓨터 장치들의 노드 간 연결(데이터 링크)을 사용하여 서로에게 데이터를 교환할 수 있도록 하는 기술
 OSI 7계층: 네트워크 통신에서 생긴 여러가지 충돌 문제를 완화하기 위해 국제 표준화 기구(ISO)에서 제시한 네트워크 기본 모델

 OSI 7계층 구성요소: Application, Presentation, Session, Transport, Network, Data Link, Physical
 
 네트워크 현행 시스템 분석: 네트워크 구조를 구성도를 통해 분석
 백본망, 라우터, 스위치, 게이트웨이, 방화벽 등을 대상으로 분석

15 DBMS 형행 시스템 분석
 - 가성호기구(성능 측면 - 가용성, 성능, 상호 호환성 / 지원 측면 - 기술 지원, 구축 비용)

16. 미들웨어 현행 시스템 분석: 가성기구(성능 측면: 가용성, 성능 / 지원 측면 - 기술 지원, 구축 비용)


17. 요구사항 확인
 - 요구공학: 사용자의 요구가 반영된 시스템을 개발하기 위하여 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동
 - 요구공학의 목적: 이해관계자 사이 효과적인 의사소통 수단 제공, 공통된 이해 설정, 요구사항 누락 방지 및 이해 오류로 인한 불필요한 비용 절감, 요구사항 변경 추적, 개발 비용 시간 절약
 - 요구사항의 분류: 기능적 요구사항(특성: 기완일 - 기능성, 완전성, 일관성) / 비기능적 요구사항(신사효유이보품제 - 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성, 품질 관련 요구사항, 제약사항)
 
18. 요구공학 프로세스: 도분명확(도출, 분석, 명세, 확인)

19. 요구사항 도출단계: 소프트웨어가 해결해야할 문제를 이해하고, 고갱르ㅗ 부터 제시되는 추상적 요구에 대해 관련 정보를 식별하고 수집방법 결정, 요구사항 구체적으로 표현하는 단계
 주요기법: 인터뷰, 브레인스토밍, 델파이, 롤 플레잉, 워크숍, 설문조사

20 요구사항 분석 단계: 요구사항 분석 단계는 추출된 요구사항에 대해 충돌, 중복, 누락 등의 분석을 통해 완전성과 일관성을 확보하는 단계
 분석 단계 절차: 요구사항 분류 -> 개념 모델링 생성 및 분석 -> 요구사항 할당 -> 요구사항 협상 -> 정형분석
 분석 단계 기법: 자료 흐름 지향 분석, 객체 지향 분석
 분석기술: 청취, 인터뷰와 질문, 분석, 중재, 관찰, 작성, 조직, 모델 작성

21. 요구사항 명세 단계: 체계적으로 검토, 평가, 승인될 수 있는 문서를 작성
 주요기법: 비정형 명세 기법, 정형 명세 기법
 산출물: 요구사항 명세서
 명세 원리 및 검증 항목: 명완검일수추개(명확성, 완전성, 검증 가능성, 일관성, 수정 용이성, 추적 가능성, 개발 후 이용성)

22. 요구사항 확인 및 검증 단계: 사용자의 요구가 올바르게 기술 되었는지에 대한 검토 / 요구사항을 이해했는지 확인(Validation)하고 욕사항 문서가 회사 표준에 적합한지, 일관성을 만족하는지, 완전한지 검증(Verification) 해야한다.

 ㄴ 요구사항 확인 및 검증 절차: 요구사항 목록 확인, 정의서 작성 여부 확인, 비기능적 요구사항 확인, 타 시스템 연계 및 인터페이스 요구사항 확인
 ㄴ 요구사항 확인 및 검증 단계의 주요기법 및 산출물: 
   - 요구사항 검토, 정형 기술 검토 활용(동료 검토, 워크스루, 인스펙션), 프로토 타이핑 활용, 모델 검증, 테스트 케이스 및 테스트를 통한 확인, CASE 도구 활용 검증, 베이스라인을 통한 검증, 요구사항 추적표

 - 상세 정형 기술 검토 기법: 관리 리뷰, 기술 리뷰, 인스펙션, 워크 스루, 감사

23. 요구사항 관리 단계: 프로젝트 진행 과정에서 발생하는 요구사항의 변경에 대해 일치성과 무결성을 제공하기 위해 변경제어와 추적 등 일련의 관리를 수행하는 활동
 주요산출물: 요구사항 변경요청서, 변경 승인서, 추적표

 - 요구사항 관리 단계 절차: 협기변확(요구사항 협상 -> 요구사항 기준선 설정 -> 요구사항 변경관리 -> 요구사항 확인 및 검증)

24. 분석모델 검증: 요구사항 도출 기법을 활용하여 업무 분석가가 제시한 분석 모델에 대해서 확인하는 활동
 ㄴ 분석모델 검증 방법: 유스케이스 모델 검증, 개념 수준의 분석 클래스 검증, 분석 클래스 검증


25. UI 요구사항 확인
 UI(User Interface) - 사용자와 시스템 사이에서 의사소통할 수 있도록 고안된 물리적, 가상의 매개체이다. 정보기기나 소프트웨어의 화면 등에서 사람이 접하게 되는 화면
 UX(User eXperience) - 제품과 시스템, 서비스 드응ㄹ 사용자가 직/간접적으로 경험하면서 느끼고 생각하는 총체적 경험

26. UI 유형: CLI, GUI, NUI, OUI
 CLI - 정적인 텍스트 기반, GUI - 그래픽 반응 기반, NUI - 직관적 사용자 반응 기반, OUI - 유기적 상호작용 기반
27. UI 설계원칙: 직유학유(직관성, 유효성, 학습성, 유연성)

28. UI 설계지침: 사일단결 가표접명오(사용자 중심, 일관성, 단순성, 결과 예측 가능, 가시성, 표준화, 접근성, 명확성, 오류 발생 해결)

29. UI 품질 요구사항: 기신사효유이(기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성)
 
30. UI 표준: 디자인 철학과 원칙 기반 하에 전체 시스템에 공통으로 적용되는 화면 간 이동, 화면구성 등에 관한 규약
 ㄴ UI 표준 구성: 액정스패조(전체적인 UX원칙, 정책 및 철학, UI 스타일 가이드, uI 패턴 모델 정의, UI표준 수립을 위한 조직 구성
 ㄴ CRUD 방식: 대부분의 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create, Read, Update, Delete를 묶어서 이르는 말

31. UI 개발을 위한 주요 기법: 3C 분석, SWOT 분석, 시나리오 플래닝, 사용성 테스트, 워크숍

32. 사용자 요구사항 도출: 페르소나 정의, 콘셉트 모델 정의, 사용자 요구사항 정의, UI컨셉션

33. 스토리보드 개념: UI 화면 설계를 위해서 정책이나 프로세스 및 콘텐츠의 구성, 와이어 프레임(UI, UX), 기능에 대한 정의, 데이터 베이스의 연동 등 구축하는 서비스를 위한 대부분 정보가 수록된 문서, 디자이너와 개발자가 최종적으로 참고하는 산출 문서

34. UI 화면설계 구분: 와스프(와이어 프레임, 스토리보드, 프로토타입)
 ㄴ 와이어 프레임: 이해 관계자들과의 화면구성을 협의하거나 서비스의 간략한 흐름을 공유하기 위해 화면 단위의 레이아웃을 설계하는 작업
 ㄴ 스토리보드: 정책, 프로세스, 콘텐츠 구성, 와이어 프레임, 기능 정의, 데이터베이스 연동 등 서비스 구축을 위한 모든 정보가 담겨 있는 설계 산출물
 ㄴ 프로토타입: 정적인 화면으로 설계된 와이어 프레임 또는 스토리보드에 동적 효과를 적용하여 실제 구현된 것처럼 시뮬레이션 할 수 있는 모형

35. UI 설계를 위한 UML
 ㄴ UML 개념: 객체지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화 할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어
 ㄴ UML 특징: 가구명문(가시화 언어, 구축 언어, 명세화 언어, 문서화 언어)
 ㄴ 가시화 언어: 개념 모델 작성 시 오류가 적고 의사소통 용이
 ㄴ 구축 언어: 다양한 프로그래밍 언어로 실행 시스템의 예측 가능, UML을 소스 코드로 변환하여 구축 가능, 역 변환하여 역공학 가능
 ㄴ 명세화 언어: 정확한 모델 제시, 완전한 모델 작성 가능
 ㄴ 문서화 언어: 시스템에 대한 평가 및 의사소통의 문서

36. UML 구성요소: 사관다(사물 관계 다이어그램)
 ㄴ 사물: 추상적인 개념으로, 주제를 나타내는 요소, 단어 관점에서 '명사'또는 '동사'를 의미
 ㄴ 관계: 사물의 의미를 확장하고 명확히 하는 요소, 사물과 사물을 연결하여 관계를 표현하는 요소, 단어 관점에서 '형용사'또는 '부사'를 의미
 ㄴ 다이어그램: 사물과 관계를 모아 그림으로 표현한 형태, 형식과 목적에 따라 9가지로 정의

37. UML 다이어그램: 구분에 따라 구조적(정적) 다이어그램과 행위적(동적) 다이어그램으로 구분된다.
 ㄴ 구조적(정적) 다이어그램: 클객 컴배 복패(클래스, 객체, 컴포넌트, 배치, 복합체 구조, 패키지)
 ㄴ 행위적(동적) 다이어그램: 유시커 상활타(유스케이스, 시퀀스, 커뮤니케이션, 상태, 활동, 타이밍)

38. UML 확장 모델의 스테레오 타입: UML 기본 요소 이외의 새로운 요소를 만들어내기 위한 확장 메커니즘, 형태는 기존 UML 요소를 그대로 사용하지만 내부 의미는 다른목적으로 사용, <<>>길러멧 기호를 사용하여 표현한다.

39. 클래스 다이어그램: 객체지향 모델링 시 클래스의 속성 및 연산과 클래스 간 정적인 관계를 표현한 다이어그램
 ㄴ 구성요소: 클래스, 속성, 연산, 접근제어자(-, +, #, ~)
 ㄴ 클래스 간의 관계: 연집복 일의실(연관 집합 복합 일반화 의존 실체화)


40. 유스케이스 다이어그램: 시스템이 제공하고 있는 기능 및 그와 관련된 외부 요소를 사용자의 관점에서 표현하는 다이어그램
 ㄴ 구성요소: 유스케이스, 액터, 시스템, 시나리오, 이벤트의 흐름
 ㄴ 유스케이스 다이어그램의 관계: 포함관계, 확장관계, 일반화관계

41. 시퀀스 다이어그램: 객체 간 상호작용을 메시지 흐름으로 표현한 다이어그램, 객체 간의 동적 상호작용을 시간적 개념을 중심으로 모델링하는 과정이다.
      		 객체의 오퍼레이션과 속성을 상세히 정의해야 한다. 유스케이스를 실현한다.
 ㄴ 구성요소: 객생실메(객체, 생명선, 실행, 메시지)

42. 패키지 다이어그램: 시스템의 서로 다른 패키지들 사이의 의존 관계를 표현하기 위한 다이어그램
 ㄴ 구성요소: 패키지, 의존관계

43. 활동 다이어그램: 시스템이 어떤 기능을 수행하는지를 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서대로 표현하는 다이어그램, 오퍼레이션이나 처리과정이 수행되는 동안 일어나는 일들을 단계적으로 표현한다. 활동 다이어그램은 하나의 유스케이스 안이나, 유스케이스 사이에서 발생하는 복잡한 처리의 흐름을 명확하게 표현할 수 있다.
 ㄴ 구성요소: 시작점, 전이, 액션/액티비티, 종료점, 조건(판단)노드, 병합노드, 포크노드, 조인노드, 구획면

44. 상태다이어그램: 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호작용에 따라 상태가 어떻게 변화하는지 표현하는 다이어그램. 어떤 이벤트에 의해 객체 자신이 속한 클래스의 상태 변화나 객체 간 상호작용을 하는 과정에서의 상태 변화를 표현한다. 객체는 파악된 상태들 이외의 상태는 가질 수 없고, 특정 순간에는 오직 한 상태로만 존재할 수 있다. 객체의 상태란 객체가 갖는 속성값의 변화이다. 
 ㄴ 구성요소: 상태, 시작상태, 종료상태, 전이, 이벤트, 전이조건

45. 커뮤니케이션 다이어그램: 시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하고, 메시지 뿐만 아니라 객체 간의 연관까지 표현하는 다이어그램이다. 커뮤니케이션 다이어그램은 시스템이나 객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호작용하는 과정을 표현한 다이어그램
 ㄴ 구성요소: 액터, 객체, 링크, 메시지

46. 컴포넌트 다이어그램: 시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존 관계를 나타내는 다이어그램이다. 코드 컴포넌트 기반의 물리적 구조료 표현된다. 실질적 프로그래밍 작업에 사용된다.
 ㄴ 구성요소: 컴포넌트, 인터페이스, 의존관계

47. UI 시나리오 문서의 작성 요건: 완일이가 추수(완전성 일관성 이해성 가독성 추적용이성 수정용이성)

48. 데이터 모델: 현실 세계의 정보를 인간과 컴퓨터가 이애할 수 있도록 추상화하여 표현한 모델
 ㄴ 표시해야할 요쇠: 논리적 데이터 구조, 연산, 제약조건

49. 데이터 모델 절차: 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델
 ㄴ 개념적: 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 데이터 모델, 트랜잭션 모델링, View 통합방법 및 Attribute 합성 고려, DB 종류 관계 X, 주요산출물로는 개체관계 다이어그램이 있다.
 ㄴ 논리적: 업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현한 데이터 모델, 논리적 데이터 몰델을 통해 관계 데이터 모델, 계층 데이터 모델, 네트워크 데이터 모델, 객체지향 데이터 모델, 객체-관계 데이터 모델 중 하나의 모델에 맞게 설계, 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계, 정규화 수행, 매핑, 스키마의 평가 및 정제
 ㄴ 물리적: 논리 데이터 모델을 특정 DBMS의 특성 및 성능을 고려하여 물리적인 스키마를 만드는 일련의 데이터 모델. 각 DBMS의 특성을 고려하여 데이터베이스 저장 구조로 변환, 테이블 인덱스, 뷰, 파티션 등 객체를 생성, 응답시간, 저장 공간의 효율화, 트랜잭션 처리를 고려하여 설계, 성능 측면에서 반 정규화를 수행, 레코드 집중의 분석 및 설꼐, 저장 레코드 양식 설계, 접근 경로 설계

50. 논리 데이터 모델 검증: 업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현하는 프로세스, 개념 모델로부터 업무 영역의 업무 데이터 및 규칙을 구체적으로 표현한 모델

51. 논리적 데이터 모델링 종류
 ㄴ 관계 데이터 모델: 논리적 구조가 2차원 테이블 형태로 구성된 모델, 기본 키와 이를 참조하는 외래 키로 관계 표현 1:1, 1:N, N:M	 관계를 자유롭게 표현
 ㄴ 계층 데이터 모델: 논리적 구조가 트리 형태로 구성된 모델, 상하 관계 존재(부모-자식), 1:N 관계만 허용
 ㄴ 네트워크 데이터 모델: 논리적 구조가 그래프 형태로 구성된 모델, CODASYL DBTG 모델이라고 불림, 상위와 하위 레코드 사이에 다대다(N:M) 관계를 만족하는 구조

52. 관계 데이터 모델의 구성
 ㄴ 릴레이션: 행과 열로 구성된 테이블
 ㄴ 튜플: 릴레이션의 행(Row)에 해당되는 요소
 ㄴ 속성: 릴레이션의 열(Column)에 해당되는 요소
 ㄴ 카디널리티: 튜플의 수
 ㄴ 차수: 애트리뷰트의 수
 ㄴ 스키마: 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조  

53. 관계 대수: 데이터베이스에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 정형 언어이다.
 ㄴ 관계대수 연산자의 종류는 일반 집합 연산자와 순수 관계 연산자로 나뉘어짐
 ㄴ 일반집합연산자의 종류: 합교차카(합집합, 교집합, 차집합, 카디션 프로덕트)
 ㄴ 순수관계연산자의 종류: 셀프조디(셀렉트, 프로젝트, 조인, 디비전)

54. 관계해석: 관계 해석은 튜플 관계 해석과 도메인 관계 해석을 하는 비절차적 언어
 ㄴ 특징: 프레디킷 해석(Predicate Calculus)에 기반한 언어이며 비절차적 언어(원하는 정보가 무엇이라는 것만 선언)이다.

55. 논리 데이터 모델링 속성: 개속관(개체, 속성, 관계)
 ㄴ 개체: 개체는 사물 또는 사건이라고 정의. 피터 챈 모델에서는 개체를 사각형으로 표시, 까마귀발 모델에서는 개체를 표 형식으로 표시
 ㄴ 속성: 개체가 가지고 있는 요소 또는 성질이다. 피터 챈 모델에서는 속성을 타원형으로, 까마귀발 모델에서는 속성을 표 내부에 표시.
 ㄴ 관계: 두 개체 간의 관계를 정의, 피터 챈 모델에서는 관계를 마름모로, 까마귀발 모델에서는 관계를 그림과 같이 표시(그림 참조)

56. 개체-관계(E-R) 모델: 현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 표현하기 위해 가장 널리 사용되고 있는 모델, 논리 데이터 모델링에서는 모든 이해당사자와 의사소통의 보조 자료로 E-R 모델 활용. 
 ㄴ 기호: 개체-사각형, 관계-마름모, 속성-타원, 다중 값 속성-이중 타원, 관계와 속성을 연결-선

57. 정규화: 정규화는 관계형 데이터 모델에서 데이터의 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성과 정확성을 유지하기 위해 무손실 분해하는 과정이다.

58. 이상현상: 데이터 중복성으로 인해 릴레이션을 조작할 때 발생하는 비합리적 현상, 삽삭갱(삽입, 삭제, 갱신)이 있다.
 ㄴ 삽입 이상: 정보 저장 시 해당 정보의 불필요한 세부정보를 입력해야 하는 경우
 ㄴ 삭제 이상: 정보 삭제 시 원치 않는 다른 정보가 같이 삭제되는 경우
 ㄴ 갱신 이상: 중복 데이터 중에서 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우

59. 데이터베이스 정규화 단계: 원부이결다조(원자화, 부분함수 종속 제거, 이행함수 종속 제거, 결정자 함수 종속 제거, 다치 종속 제거, 조인 종속 제거)

60. 반 정규화: 정규화된 엔터티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법이다
 ㄴ 장점: 반 정규화된 데이터 구조는 성능 향상과 관리의 효율성이 증가
 ㄴ 단점: 데이터의 일관성 및 정합성 저하, 유지를 위한 비용이 별도로 발생하여 성능에 나쁜 영향을 미칠 수 있음

61. 반 정규화 기법: 테병분중 컬중 관중( 테이블- 병합/분할/중복, 컬럼- 중복, 관계- 중복)

62. 물리 데이터 모델링: 논리모델을 적용하고자 하는 기술에 맞도록 상세화해가는 과정이다.

63. 논리 데이터 저장소에서 물리 데이터 저장소로 모델링 변환 절차: 계속U관컬반(개체를 테이블로 변환, 속성을 컬럼으로 변환, UID를 기본키로 변환, 관계를 외래키로 변환, 컬럼 유형과 길이 정의, 반 정규화 수행)

64. 참조 무결성 제약조건: 릴레이션과 릴레이션 사이에 대해 참조의 일관성을 보장하기 위한 조건, 두 개의 릴레이션이 기본키, 외래키를 통해 참조관계를 형성할 경우, 참조 하는 외래키의 값은 항상 참조되는 릴레이션에 기본키로 존재해야 한다.
 ㄴ 제한: 참조 무결성 원칙을 위배하는 연산을 거절하는 옵션
 ㄴ 연쇄: Cascade 참조되는 릴레이션에서 튜플을 삭제하고, 참조되는 릴레이션에서 이 튜플을 참조하는 튜플들도 함께 삭제하는 옵션
 ㄴ 널값: Nullify 참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 릴레이션에서 해당 튜플을 참조하는 튜플들의 외래 키에 NULL값을 넣는 옵션.

65. 인덱스: 검색 연산의 최적화를 위해 데이터베이스 내 열에 대한 정보를 구성한 데이터구조, 전체 데이터의 검색 없이 필요한 정보에 대해 신속한 조회가 가능하다.
 ㄴ 적용기준: 인덱스 분포도가 10~15% 이내인 경우 아래 수식 참고((분포도 = 1 / 컬럼 값의 종류) x 100), 분포도 = (컬럼 값의 평균 Row 수 / 테이블의 총 Row 수) x 100
           분포도가 범위 이상이더라도 부분처리를 목적으로 하는 경우 적용, 조회 및 출력 조건으로 사용되는 컬럼일 경우 적용

66. 분포도: 특정 컬럼의 데이터가 테이블에 평균적으로 분포되어 있는 정도,=

67. 인덱스 컬럼 선정: 분포도가 좋은 컬럼은 단독적으로 생성한다. 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성, 가능한 수정이 빈번하지 않은 컬럼을 선정 등

68. 설계 시 고려 사항: 지나치게 많은 인덱스는 오버헤드로 작용한다. 인덱스는 추가적인 저장 공간이 필요함을 고려해야 한다, 넓은 범위 인덱스 처리시 오히려 전체 처리보다 더 많은 오버해드 발생시킬 수 있음, 인덱스와 테이블의 저장 공간을 적절히 분리 될 수 있도록 설계해야한다.

69. 뷰속성
 ㄴ REPLACE: 뷰가 이미 존재하는 경우 재생성
 ㄴ FORCE: 본 테이블의 존재 여부에 관계없이 뷰 생성
 ㄴ NOFORCE: 기본 테이블이 존재할 떄 뷰 생성
 ㄴ WITH CHECK OPTION: 서브쿼리 내의 조건을 만족하는 행만 변경
 ㄴ WITH READ ONLY: 데이터 조작어 작업 불가

70. 클러스터 적용기준
 ㄴ 인덱스의 단점을 해결한 기법으로, 분포도가 넓을 수록 오히려 유리하다.
 ㄴ 엑세스 기법이 아니라 엑세스 효율 향상을 위한 물리적 저장 방법이다.
 ㄴ 분포도가 넓은 테이블의 클러스터링은 저장 공간의 절약이 가능하다.
 ㄴ 대량의 범위를 자주 엑세스 하는 경우 적용한다.
 ㄴ 인덱스를 사용한 처리 부담이 되는 넓은 분포도에 활용한다.
 ㄴ 여러개의 테이블이 빈번하게 조인을 일으킬 때 활용한다.

71. 파티션 종류: 레해리컴
 ㄴ 레인지 파티셔닝: 연속적인 숫자나 날짜를 기준으로 하는 파티셔닝 기법, 손쉬운 관리 기법을 제공하여 관리 시간의 단축이 가능하다.
 ㄴ 해시 파티셔닝: 파티션 키의 해시 함수 값에 의한 파티셔닝 기법이다, 균등한 데이터 분할이 가능하고 질의 성능이 향상 가능하다.
 ㄴ 리스트 파티셔닝: 특정 파티션에 저장 될 데이터에 대한 명시적 제어가 가능한 파티셔닝 기법이다, 분포도가 비슷하고 데이터가 많은 SQL에서 컬러므이 조건이 많이 들어오는 경우 유용하다.
 ㄴ 컴포지트 파티셔닝: 레인지, 해시, 리스트 중 2개 이상의 파티셔닝을 결합하는 파티셔닝 기법이다. 큰 파티션에 대한 I/O 요청을 여러 파티션으로 분산할 수 있다.

72. 파티션의 장점: 성가백합(성능 향상, 가용성 향상, 백업 가능, 경합 감소)

73. 데이터베이스 개념
 ㄴ 다수의 인원, 시스템, 또는 프로그램이 사용할 목적으로 통합하여 관리되는 데이터의 집합이다.
 ㄴ 데이터에 대한 효과적인 관리를 위해 자료 중복성 제거, 무결성 확보, 일관성 유지, 유용성 보장이 중요하다.
 ㄴ 데이터베이스는 통합된 데이터, 저장된 데이터, 운영 데이터, 공용 데이터이다.

74. 데이터베이스 특성: 실시간 접근성, 계속적인 변화, 동시 공용, 내용 참조

75. RDBMS: Relational Database Management System: 관계형 모델을 기반으로 하는 가장 보편화된 데이터베이스 관리 시스템
 
76. DBMS(DataBase Management System) 개념
 ㄴ 데이터 관리의 복잡성을 해결하는 동시에, 데이터 추가, 변경, 검색, 삭제 및 백업, 복구, 보안 등의 기능을 지원하는 소프트웨어
 ㄴ 저장되는 정보는 텍스트, 이미지, 음악 파일, 지도 데이터 등 매우 다양하며, SNS의 발달과 빅 데이터의 폭 넓은 활용으로 인해 데이터의 종류와 양은 급격히 증가 중이다.

77. DBMS 유형: 키컬도그
 ㄴ 키-값(Key-Value) DBMS: 키 기반 Get/Put/Delete 제공, 메모리 기반에서 성능 우선 시스템 및 빅데이터 처리 가능. Unique한 키에 하나의 값을 가지고 있는 형태 ex) Redis, DynamoDB
 ㄴ 컬럼 기반 데이터 저장: Key 안에(Column, Value) 조합으로 된 여러 개의 필드를 가짐. 테이블 기반, 조인 미지원, 컬럼 기반으로 구글의 Bigtable 기반으로 구현 ex)HBase, Cassandra
 ㄴ 문서 저장: 값의 데이터 타입이 문서라는 타입을 사용. 문서 타입은 XML, JSON과 같이 구조화된 데이터 타입으로, 복잡한 계층 구조 표현 가능
 ㄴ 그래프: 시맨틱 웹과 온톨로지 분야에서 활용되는 그래프로 데이터를 표현하는 DBMS, 노드와 엣지로 특징되는 요소 특화, 노드 간 관계를 구조화하여 저장 ex) Neo4j, AllegroGraph

78. DBMS 특징: 데이터 무결성, 일관성, 회복성, 보안성, 효율성

79. 빅데이터: 시스템, 서비스, 조직(회사) 등에서 주어진 비용, 시간 내에 처리 가능한 데이터 범위를 넘어서는 수십 페타바이트 크기의 비정형 데이터이다.

80. 빅데이터 특성
 ㄴ 데이터의 양(Volume): 페타바이트 수준의 대규모 데이터, 빅데이터 분석 규모에 관련된 특성, 디지털 정보량이 기하급수적으로 폭증하는 것을 의미 
 ㄴ 데이터의 다양성(Variety): 정형, 비정형, 반정형의 다양한 데이터, 빅데이터 자원 유형에 관련된 특성, 로그, 소셜, 위치 등 데이터 유형이 다양해지는 것을 의미
 ㄴ 데이터의 속도(Velocity): 빠르게 증가하고 수집되며, 처리되는 데이터, 빅데이터 수집, 분석, 활용 속도와 관련된 특성, 가치있는 정보 활용을 위해 실시간 분석이 중요해지는 것을 의미

81. 빅데이터 수집, 저장, 처리 기술
 ㄴ 비정형/반정형 데이터 수집: 내외부 정제되지 않은 데이터를 확보, 이를 통해 필요 정보를 추출하여 활용하기 위해서 효과적으로 수집 및 전송하는 기술 ex) 척와, 플럼, 스크라이브
 ㄴ 정형 데이터 수집: 내외부 정제된 대용량 데이터의 수집 및 전송 기술 ex) ETL, FTP, 스쿱, 하이호
 ㄴ 분산데이터 저장/처리: 대용량 파일의 효과적인 분산 저장 및 분산 처리 기술 ex) HDFS, 맵 리듀스
 ㄴ 분산데이터 베이스: HDFS의 칼럼 기반 데이터베이스로 실시간 랜덤 조회 및 업데이트가 가능한 기술 ex) HBase

82. 빅데이터 분석, 실시간 처리 및 시각화를 위한 주요기술
 ㄴ 빅데이터 분석: 데이터 가공과 분류, 클러스터링, 패턴 분석을 처리하는 기술, 데이터 가공을 위한 대표적인 솔루션에는 피그, 하이브가 있고, 데이터 마이닝을 위한 대표적인 솔루션에는 머하웃가 있음
 ㄴ 실시간처리: 하둡 기반의 실시간 SQL질의 처리와 요청된 작업을 최적화하기 위한 워크플로우 관리 기술, 실시간 SQL 질의를 위한 대표적인 솔루션에는 임팔라가 있고, 워크플로우 관리를 위한 대표적인 솔루션은 우지가 있음
 ㄴ 분산 코디네이션: 분산 환경에서 서버들 간에 상호조정이 필요한 다양한 서비스를 분산 및 동시처리 제공 기술, 대표적인 솔루션은 주키퍼가 있음
 ㄴ 분석 및 시각화: 빅데이터 분석 기술을 통해 분석된 데이터의 의미와 가치를 시각적으로 표현하기 위한 기술, 대표적인 솔루션은 R이 있음

83. NoSQL(Not Only SQL) 개념: 전통적인 RDBMS와 다른 DBMS를 지칭하기 위한 용어로 데이터 저장에 고정된 테이블 스키마가 필요하지 않고 조인(Join) 연산을 사용할 수 없으며, 수평적으로 확장이 가능한 DBMS이다.

84. NoSQL 특성
 ㄴ Basically Available: 언제든지 데이터는 접근할 수 있어야 하는 속성, 분산 시스템이기 때문에 항상 가용성 중시
 ㄴ Soft-State: 노드의 상태는 내부에 포함된 정보에 의해 경정되는 것이 아니라 외부에서 전송된 정보를 통해 결정되는 속성, 특정 시점에서는 데이터의 일관성이 보장되지 않음
 ㄴ Eventually Consistency: 일정 시간이 지나면 데이터의 일관성이 유지되는 속성, 일관성을 중시하고 지향

85. 데이터 마이닝: 대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 기술, 대규모 데이터에서 의미 있는 패턴을 파악하거나 예측해서 의사결정에 활용하는 기법이다, 데이터의 숨겨진 정보를 찾아내어 이를 기반으로 서비스와 제품에 도입하는 과정, 통계분석은 가설이나 가정에 따른 분석, 검증을 하지만 데이터 마이닝은 수리 알고리즘을 활용하여 대규모 데이터에서 의미 있는 정보를 찾아낸다.

86. 데이터 마이닝 절차
 ㄴ 1단계: 목적 설정, 2단계: 데이터 준비, 3단계: 가공, 4단계: 마이닝 기법 적용, 5단계: 정보 검증

87. 데이터마이닝 주요 기법: 분연연데
 ㄴ 분류 규칙: 과거 데이터로부터 특성을 찾아내어 분류모형을 만들어 이를 토대로 새로운 레코드의 결과 값을 예측하는 기
 ㄴ 연관 규칙: 데이터 안에 존재하는 항목들 간의 종속 관계를 찾아내는 기법
 ㄴ 연속 규칙: 연관 규칙에 시간 관련 정보가 포함된 형태의 기법
 ㄴ 데이터 군집화: 대상 레코드들을 유사한 특성을 지닌 몇 개의 소그룹으로 분할하는 작업으로 작업의 특성이 분류규칙과 유사, 정보가 없는 상태에서 데이터를 분류하는 기법.

88. 연계 요구사항 분석의 개념: 서로 다른 두 시스템, 장치, 소프트웨어를 이어주는 중계 역할을 하는 연계 시스템과 관련된 요구사항을 분석하는 과정이다. 사용자 인터뷰 및 면담을 통해 식별되고 시스템 구성도, 테이블 정의서, 코드 정의서 등을 참고한다.

89. 요구사항 분석 기법: 인체설델브(인터뷰, 체크리스트, 설문지, 델파이 기법, 브레인스토밍)

90. 요구사항 분석 참고문서: 코테응시(코드 정의서, 테이블 정의서, 응용 프로그램 구성도, 시스템 구성도)

91. 인터페이스 명세서 구성요소: 인최크시데(인터페이스 ID, 최대 처리 횟수, 데이터 크기(평균/최대), 시스템 정보, 데이터 정보)

92. 연계 요구사항 분석 절차: 시스템 현황 확인, 정의서 확인, 체크리스트 작성, 인터뷰 및 면담, 연계 요구사항 분석서 작성

93. 연계 시스템의 구성: 송신 시스템, 수신 시스템, 중계 서버

94. 연계 데이터 표준화: 인터페이스 시스템 사이에서 교환되는 데이터는 규격화된 표준 형식을 정의하여 사용하여야 한다, 인터페이스 설계 단계에서 송수신 시스템 사이에 전송되는 표준항목과 업무처리 데이터, 공통 코드 정보 등을 누락 없이 식별하고 인터페이스 명세서를 작성해야 한다. 
 ㄴ 인터페이스 데이터 공통부, 개별부, 종료부로 구성된다.

95. 연계 메커니즘: 응용 소프트웨어와 연계 대상 모듈 간의 데이터 연계 시 요구사항을 고려한 연계방법과 주기를 설계하기 위한 메커니즘이다.

96. 연계 매커니즘 기능
 ㄴ 데이터를 생성하여 전송하는 송신 시스템과 송신 데이터를 수신하여 DB에 반영하는 수신 시스템으로 구성된다.
 ㄴ 송신 시스템은 운영 데이터베이스, 애플리케이션으로부터 연꼐 데이터를 연계 테이블 또는 파일로 생성하여 송신한다.
 ㄴ 수신 시스템은 송신 시스템으로부터 전송된 데이터를 변환 처리 후 데이터베이스에 반영한다.

97. 연계 방식
 ㄴ 직접연계 장점: 연계 및 통합 구현이 단순하며 용이, 개발 소요 비용 및 기간이 짧음, 중간 매개체가 없으므로 데이터 연계 처리 성능이 대체로 좋음
 ㄴ 직접연계 단점: 시스템 간 결합도가 높아 변경에 민감, 암복호화 처리 불가, 연계 및 통합 가능한 시스템 환경이 제한적
 ㄴ 간접연계 장점: 서로 상이한 네트워크, 프로토콜 연계 및 통합 가능, 인터페이스 변경시에도 장애나 오류 없이 서비스 가능, 보안이나 업무 처리 로직을 자유롭게 반영 가능
 ㄴ 간접연계 단점: 연계 아키텍처 및 메커니즘이 복잡해 성능 저하 요소 존재, 개발 및 적용을 위한 테스트 기간이 상대적 장기간 소요

98. 주요 연계 기술
 ㄴ 직접 - DB링크, DB연결, API/Open API, JDBC, 하이퍼링크
 ㄴ 간접 - 연계솔루션(EAI), Web Service/ESB, 소켓

 ㄴ DB 링크(Link): 데이터베이스에서 제공하는 DB 링크 객체를 이용, 수신 시스템에서 DB 링크를 생성하고 송신 시스템에서 해당 DB 링크를 직접 참조하는 방식
 ㄴ DB 연결(connection): 수신 시스템의 WAS(Web Application Server)에서 송신 시스템 DB로 연결하는 DB 커넥션 풀을 생성하고 연계 프로그램에서 해당 DB 커넥션 풀 명을 이용하여 연결
 ㄴ API/Open API: 송신 시스템의 DB에서 데이터를 읽어서 제공하는 애플리케이션 프로그래밍 인터페이스 프로그램
 ㄴ JDBC: 수신 시스템의 프로그램에서 JDBC 드라이버를 이용하여 송신 시스템 DB와 연결
 ㄴ 하이퍼링크: 현재 페이지에서 다른 부분으로 가거나, 전혀 다른 페이지로 이동하게 해주는 속성

 ㄴ 연계 솔루션: 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간의 정보 전달, 연계, 통합을 가능하게 해주는 솔루션 
 ㄴ Web Service/ ESB:  웹서비스가 설명된 WSDL과 SOAP 프로토콜을 이용한 시스템 간 연계
 ㄴ 소켓: 소켓을 생성하여 포트를 할당하고, 클라이언트의 요청을 연결하여 통신

99. EAI(Enterprise Application Integration)
 ㄴ EAI는 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계, 통합이 가능하도록 해주는 솔루션이다.
 ㄴ EAI를 사용함으로써 각 비즈니스 간 통합 및 연계성을 증대시켜 효율성을 높여 줄 수 있으며 각 시스템 간의 확장성을 높여줄 수 있다. 

100. EAI 구성요소: EAI 플랫폼, 어댑터, 브로커, 메시지 큐, 비즈니스 워크플로우

101. EAI 구축 유형: 포허메하(포인트 투 포인트, 허브 앤 스포크, 메세지 버스, 하이브리드)
 ㄴ 포인트 투 포인트: 기초적인 애플리케이션 통합방법, 1:1 단순 통합방법, 솔루션을 구매하지 않고 개발자 간 커뮤니케이션을 통해서도 통합가능
 ㄴ 허브 앤 스포크: 단일한 접점의 허브 시스템을 통하여 데이터를 전송하는 중앙 집중식 방식, 허브 장애 시 전체 장애 발생
 ㄴ 메시지 버스: 애플리케이션 사이 미들웨어를 두어 연계하는 미들웨어 통합 방식, 뛰어난 확장성과 대용량 데이터 처리 가능
 ㄴ 하이브리드: 그룹 내는 허브 앤 스포크 방식을 사용하고, 그룹 간에는 메시지 버스 방식을 사용한 통합 방식, 그룹 내 환경에 맞는 작업 가능

102. ESB(Enterprise Service Bus) 
 ㄴ 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간을 하나의 시스템으로 관리 운영할 수 있도록 서비스 중심의 통합을 지향하는 아키텍처, ESB는 미들웨어를 중심으로 각각 프로토콜이 호환할 수 있도록 애플리케이션의 통합을 느슨한 결합 방식으로 지원하는 방식
 ㄴ 느슨한 결합: 특정 서비스를 변경하더라도 연결된 다른 서비스에는 영향을 주지 않는 유연한 구조라는 의미
 
103. ESB 특징: 서비스들을 컴포넌트화된 논리적 집합으로 묶는 핵심 미들웨어이며, 비즈니스 프로세스 환경에 맞게 설계 및 전개할 수 있는 아키텍처 패턴이다. 버스방식으로 확장성, 유연한 아키텍처 구성이 가능하다.

104. 웹 서비스 개념: 네트워크에 분산된 정보를 서비스 형태로 개방하여 표준화된 방식으로 공유하는 기술로써 서비스 지향 아키텍처 개념을 실현하는 대표적인 기술이다.

105. 웹 서비스 유형: SOAP(Simple Object Access Protocol), WSDL(Web Service Description Language), UDDI(Universal Description Discovery and Integration)
 ㄴ SOAP: HTTP, HTTPS, SMTP 등을 사용하여 XML 기반의 메시지를 네트워크 상태에서 교환하는 프로토콜, HTTP 프로토콜 상에 SOAP Envelope, Header, Body 등이 추가된 XML 문서로 기본적인 송수신은 HTTP로 수행한다, SOAP는 보통의 경우 원격 프로시저 호출(RPC)을 하는 메시지 패턴을 사용한다, 네트워크 노드(클라이언트)에서 다른 쪽 노드(서버)로 메시지를 요청하고, 서버는 메시지를 즉시 응답하게 된다.
 
 ㄴ WSDL:  웹 서비스명, 제공 위치, 메시지 포맷, 프로토콜 정보 등 웹 서비스에 대한 상세 정보가 기술된 XML 형식으로 구현되어 있는 언어다. SOAP와 XML 스키마와 결합하여 인터넷 상에 웹 서비스를 제공하기 위해 사용되기도 한다.

 ㄴ UDDI: 웹 서비스에 대한 정보인 WSDL을 등록하고 검색하기 위한 저장소로 공개적으로 접근, 검색이 가능한 레지스트리이자 표준이다. 서비스 제공자는 UDDI라는 서비스 소비자에게 이미 알려진 온라인 저장소에 그들이 제공하는 서비스 목록들을 저장하게 되고, 서비스 소비자들은 그 저장소에 접근함으로써 원하는 서비스들의 목록을 찾을 수 있게 된다. 알려진 송수신 시스템의 통합 구현에서는 서비스의 공개 및 검색과정이 필요 없으므로 UDDI를 구축하지 않는다.

106. 시스템 인터페이스 설계서: 시스템 인터페이스 설계서는 이 기종 시스템 및 컴포넌트 간 데이터 교환 및 처리를 위해 각 시스템의 교환되는 데이터, 업무, 송수신 주체 등이 정의된 문서이다.

107. 상세 기능별 인터페이스 명세서: 데이터 송수신 시스템 간의 데이터 저장과 속성 등의 상세 내역을 포함한다.
 ㄴ 주요항목: 아명오개 전후파반(인터페이스 ID, 인터페이스 명, 오퍼레이션 명, 오퍼레이션 개요, 사전조건, 사후조건, 파라미터, 반환 값)

108. 외부, 내무 모듈 연계 방법(EAI, ESB): 기업 시스템이나 공공 서비스를 위한 시스템에서 인터페이스를 위해 외부 및 내부 모듈을 연계하는 대표적인 방법은 EAI와 ESB가 있다.

109. 인터페이스 데이터 표준 확인: 데이터 표준 확인은 상호 연계하고자 하는 시스템 간 인터페이스가 되어야 할 범위의 데이터 형식과 표준을 정의하는 활동이다. 데이터 전송 시 데이터 형태가 동일하면 그대로 전송, 동일하지 않으면 변환하여 전송

110. 인터페이스 기능 구현 정의: 개발하고자 하는 응용 소프트웨어와 연계 대상 모듈 간의 세부 설계서를 확인하여 일관되고 정형화된 인터페이스 기능을 구현할 수 있다.

111. 컴포넌트 명세서: 컴포넌트의 개요, 내부 클래스의 동작, 인터페이스를 통해 외부와 통신하는 명세를 정의
 ㄴ 컴포넌트란? 특정한 기능을 수행하기 위해 독립적으로 개발되어 보급되는, 잘 정의된 인터페이스를 가지며 다른 부품과 조립되어 응용 시스템을 구축하기 위해 사용되는 소프트웨어 프로그램.

112. 인터페이스 명세서: 인터페이스 명세서는 컴포넌트 명세서에 명시된 인터페이스 클래스의 세부적인 조건 및 기능을 명시한 명세서이다. 인터페이스 명칭, 사전/사후 조건, 인터페이스 데이터 및 인터페이스 완료 후 성공 여부를 반환바는 반환 값 등이 정의되어 있다.

113. 제이슨(JSON): 비동기 브라우저/서버 통신(AJAX)을 위해 "속성-값 쌍", "키-값 쌍"으로 이루어진 데이터 오브젝트를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷이다.

114. JSON 특징
 ㄴ AJAX(Asynchronous JavaScript and XML)에서 많이 사용되고 XML(eXtensible Markup Language)을 대체하는 주요 데이터 포맷이다.
 ㄴ 언어 독립형 데이터 포맷으로 다양한 데이터 프로그래밍 언어에서 사용된다.
 ㄴ 사람이 읽고 쓰기에 용이하며, 기계가 분석하고 생성하기에 용이하다.

115. JSON 표현 자료형
 ㄴ 숫자: 기본 자료형의 수는 정수, 실수(고정 소수점), 실수(부동 소수점)로 표현
 ㄴ 문자열: 항상 큰 따옴표로 묶어야 하며, 그 안에는 유니코드 문자들이 나열
 ㄴ 배열: 배열은 대괄호로 표시. 배열의 각 요소는 기본 자료형이거나 배열, 객체임. 각 요소들은 쉼표로 구별되고 각 요소가 나타나는 순서에 의미가 있음.
 ㄴ 객체: 객체는 이름/값 쌍의 집합으로, 중괄호를 사용, 이름은 문자열이기 떄문에 반드시 따옴표를 하며, 값은 기본 자료형, 각 쌍들은 쉼표로 구별되고, 각 쌍이 나오는 순서는 의미 없음.

116. JSON 문법
 ㄴ 구조: name/value 쌍으로 구성. {로 시작하고 }로 끝남, 배열은 []로 나타냄, 각각의 이름은 '와', '로' 구분된 name/value 쌍의 형식을 다룸

117. JSON 장점/단점
 ㄴ 장점: XML보다 가볍고 빠름, 자료 종류에 큰 제한이 없음, XML은 모두 string이고, JSON은 string, number, array, boolean 등 다양, Javascript 코드 안에서 JSON 객체에 접근 쉬움.
 ㄴ 단점: 태그가 없어서 가독성이 떨어짐, DTD 같은 것이 없기 때문에 데이터 형식이 틀렸을 경우 체크가 쉽지 않음

118. XML(Extensible Markup Language)
 ㄴ HTML의 단점을 보완한 인터넷 언어로, SGML의 복잡한 단점을 개선한 특수한 목적을 갖는 마크업 언어

119. XML 특징
 ㄴ XML은 송수신 시스템 간 데이터 연계의 편의성을 위해서 전소오디는 데이터 구조를 동일한 형태로 정의한다. 
 ㄴ 인간과 기계가 모두 이해할 수 있는 텍스트 형태로 마크업 포맷을 정의하기 위한 메타언어이다.
 ㄴ 사용자가 직접 문서의 태그를 정의할 수 있으며, 다른 사용자가 정의한 태그를 사용할 수 있다.

120. AJAX(Asynchronous Javascript And XML)
 ㄴ AJAX는 자바스크립트를 사용하여 웹 서버와 클라이언트 간 비동기적으로 XML 데이터를 교환하고 조작하기 위한 웹 기술이다.
 ㄴ 브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 로드하지 않고 필요한 일부 페이지의 데이터만을 로드하는 기법이다. 
 ㄴ 하이퍼텍스트 표기 언어(HTML)만으로는 어려운 다양한 작업을 웹 페이지에서 구현해서 이용자가 웹 페이지와 자유롭게 상호 작용할 수 있도록 구현하는 기법이다.

121. AJAX 주요기술
 ㄴ XMLHttpRequest: 웹 브라우저와 웹 서버 간에 메서드가 데이터를 전송하는 객체 폼의 API, 비동기 통신을 담당하는 자바스크립트 객체
 ㄴ Javascript: 객체기반 스크립트 프로그래밍 언어, 웹 브라우저 내에서 주로 사용하며, 다른 응용 프로그램의 내장 객체에도 접근할 수 있는 기능 소유
 ㄴ XML: HTML의 단점을 보완한 인터넷 언어로서 SGML의 복잡한 단점을 개선한 특수한 목적을 갖는 마크업 언어
 ㄴ DOM(Document Object Model): XML문서를 트리 구조의 형태로 접근할 수 있게 해주는 API, 플랫폼/언어 중립적으로 구조화된 문서를 표현하는 객체지향 모델
 ㄴ XSLT(Extensible Stylesheet Language Transformations): XML문서를 다른 XML 문서로 변환하는데 사용하는 XML 기반 언어
 ㄴ HTML(HyperTextMarkupLanguage): 인터넷 웹 문서를 표현하는 표준화된 마크업 언어
 ㄴ CSS(Cascading Style Sheets): 마크업 언어가 실제 표시되는 방법을 기술하는 언어, 운영체제나 사용 프로그램과 관계없이 글자 크기, 글자체, 줄 간격, 색상 등을 자유롭게 선택할 수 있는 스타일 시트

122. REST(Representational State Transfer) 
 ㄴ REST는 웹과 같은 분산 하이퍼미디어 환경에서 자원의 존재/상태 정보를 표준화된 HTTP 메서드로 주고받는 웹 아키텍처이다.
 ㄴ 기본형태: 리소스, 메서드, 메시지 3가지 요소로 구성된다.
 ㄴ 메서드: POST, GET, PUT, DELETE

123. 인터페이스 구현 방식에는 데이터 통신을 사용하는 인터페이스 구현 방식과 인터페이스 개체를 사용하는 구현 방식이 있다.
 
124. 데이터 통신을 사용하는 인터페이스 구현
 ㄴ 인터페이스 객체 생성 구현: 인터페이스 객체를 생성하기 위해서 데이터베이스에 있는 정보를 SQL을 통하여 선택한 후 이를 제이슨(JSON)으로 생성
 ㄴ 인터페이스 객체 전송 후 전송 결과를 수신 측에서 반환 받도록 구현: 송신 측에서 제이슨으로 작성된 인터페이스 객체를 AJAX 기술을 이용하여 수신 측에 송신, 수신 측에서는 제이슨 인터페이스 객체를 수신받고 이를 파싱 후 처리, 처리 결괏값은 송신 측에 True/False 값을 전달하여 인터페이스 성공 여부를 전달

125. 인터페이스 개체를 사용하는 인터페이스 구현
 ㄴ 송신 시스템의 인터페이스 테이블: 송신 관련 정보를 관리하기 위한 항목과 송신 시스템에서 필요한 항목 구현. 인터페이스 이벤트 발생 시 인터페이스 테이블에 내용이 기록되도록 구현, 데이터 전송을 위해서 DB 커넥션이 수신 측 인터페이스 테이블과 연계되도록 구현, 프로시저, 트리거, 배치 작업 등의 방법을 통해서 수신 테이블로 데이터를 전송하도록 구현
 ㄴ 수신 시스템의 인터페이스 테이블: 수신 관련 정보를 관리하기 위한 항목과 수신 시스템에서 필요한 항목 구현, 인터페이스 데이터를 읽은 후 산전에 정의된 데이터 트랜잭션을 진행할 수 있도록 구현, 오류 발생 시 오류 코드 칼럼에 정의된 오류 코드와 내용을 입력하도록 구현

126. 스니핑: 스니핑이란 공격 대상에게 직접 공격을 하지 않고 데이터만 몰래 들여다보는 수동적 공격기법이다.

127. 시큐어 코딩 가이드 적용: 입보시 에코캡아(입력데이터 검증 및 표현, 보안 기능, 시간 및 상태, 에러 처리, 코드 오류, 캡슐화, API 오용)
 
128. 데이터 베이스 암호화 알고리즘: 대비해(대칭 키 암호화 알고리즘/비대칭/해시)
 ㄴ 대칭 키 암호화 알고리즘: 암호화 알고리즘의 한 종류로, 암복호화에 같은 암호 키를 쓰는 알고리즘을 의미 ex) ARIA 128/192/256, SEED
 ㄴ 비대칭 키 암호화 알고리즘: 공기키는 누구나 알 수 있지만, 그에 대응하는 비밀키는 키의 소유자만이 알 수 있도록 공개키와 비밀키를 사용하는 알고리즘 ex) RSA, ECC, ECDSA
 ㄴ 해시 암호화 알고리즘: 해시 값으로 원래 입력값을 찾아낼 수 없는 일방향성의 특성을 가진 알고리즘 ex) SHA-256/384/512, HAS-160

129. 데이터 베이스 암호화 기법: 애플티하(API, Plug-in, TDE, Hybrid)
 ㄴ API 방식: 애플리케이션 레벨에서 암호모듈(API)을 적용하는 애플리케이션 수정 방식, 애플리케이션 서버에 암복호화, 정책 관리, 키 관리 등의 부하 발생
 ㄴ Plug-in 방식: 암복호화 모듈이 DB 서버에 설치된 방식, DB 서버에 암 복호화, 정책관리, 키 관리 등의 부하 발생
 ㄴ TDE 방식: DB 서버의 DBMS 커널이 자체적으로 암복호화 기능을 수행하는 방식, 내장되어 있는 암호화 기능 TDE(Transparent Data Encryption)을 이용
 ㄴ Hybrid 방식: API방식과 Plug-in 방식을 결합하는 방식, DB 서버와 애플리케이션 서버로 부하 분산

130. 중요 인터페이스 데이터의 암호화 전송
 ㄴ IPSec(IP Security): IP 계층(3계층)에서 무결성과 인증을 보장하는 인증 헤더와 기밀성을 보장하는 암호화를 이용하여 양 종단 간 구간에 보안 서비스를 제공하는 터널링 프로토콜, 동작모드는 전송 모드와 터널 모드가 있음
 ㄴ SSL/TLS: 전송계층과 응용계층 사이에서 클라이언트와 서버 간의 웹 데이터 암호화(기밀성), 상호 인증 및 전송 시 데이터 무결성을 보장하는 보안 프로토콜. IP Sec와는 다르게 클라이언트와 서버 간에 상호인증, 암호 방식에 대해 협상을 거치는 특징, 대칭, 공개키, 일방향 해시, 메시지 인증코드 등 특정 암호 기술에 의존하지 않고 다양한 암호 기술 적용, Https://~ 표시형식과 443 포트 이용
 ㄴ S-HTTP(Secure Hypertext Transfer Protocol): 웹상에서 네트워크 트래픽을 암호화하는 주요 방법 중 하나로서 클라이언트와 서버 간에 전송되는 모든 메시지를 각각 암호화하여 전송

131. 인터페이스 구현 검증 도구 개념
 ㄴ 구현된 인터페이스의 동작을 검증하기 위해 인터페이스 구현 및 감시 도구를 통해서 인터페이스 동작 상태를 검증하고 모니터링 할 수 있다.
 ㄴ 기능 단위로 테스트 하는 단위 테스트와 전체 인터페이스 흐름을 확인할 수 있는 시나리오를 통한 통합 테스트가 있다. 
 ㄴ 인터페이스 구현 검증 도구들을 통해서 테스트의 효율성을 높일 수 있다.

132. 인터페이스 구현 도구 종류: 엑스피 엔셀웨
 ㄴ xUnit: 자바, C++, .Net 등 다양한 언어를 지원하는 단위테스트 프레임워크, 소프트웨어의 함수나 클래스 같은 서로 다른 구성 원소를 테스트할 수 있게 해주는 도구
 ㄴ STAF: 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크. 각 테스트 대상 분산 환경에 데몬을 사용하여 테스트 대상 프로그램을 통해 테스트를 수행하고, 통합하며 자동화하는 검증 도구
 ㄴ FitNesse: 웹 기반 테스트 케이스 설계/실행/결과 확인 등을 지원하는 테스트 프레임워크, 사용자가 테스트 케이스 테이블을 작성하면 빠르고 편하게 자동으로 원하는 값에 대해 테스트를 할 수 있는 장점이 있음.
 ㄴ NTAF: FitNesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN의 테스트 자동화 프레임워크
 ㄴ Selenium: 다양한 브라우저 지원 및 개발언어를 지원하는 웹 애플리케이션 테스트 프레임워크, 테스트 스크립트 언어를 학습할 필요 없이 기능 테스트를 마들기 위한 도구를 제공
 ㄴ water: 루비 기반 웹 애플리케이션 테스트 프레임워크, 모든 언어 기반의 웹 애플리케이션 테스트와 브라우저 호환성 테스팅 가능

133. 인터페이스 감시 도구: 애플리케이션 모니터링 툴(APM: Application Performance Management)을 사용하여 동작 상태 감시
 ㄴ 데이터베이스, 웹 애플리케이션의 트랜잭션과 벼숫값, 호출 함수, 로그 및 시스템 부하 등 종합적인 정보를 조회하고, 커넥션 풀(Connection Pools) 등 지속적인 모니터링이 필요한 자원을 효과적으로 관리할 수 있다.

134. 감시 도구 종류
 ㄴ 스카우터: 애플리케이션에 대한 모니터링 및 DB Agent를 통해 오픈 소스 DB 모니터링 기능, 인터페이스 감시 기능을 제공
 ㄴ 제니퍼: 애플리케이션의 개발부터 테스트, 오픈, 운영, 안정화까지 전 생애주기 단계 동안 성능을 모니터링 하고 분석해주는 APM 소프트웨어

135. 데이터타입: 프로그래밍 언어에서 실수치, 정수 자료형과 같은 여러 종류의 데이터를 식별하는 형태이다. 메모리 공간을 효율적으로 사용하고 2진수 데이터를 다양한 형태로 사용하기 위해 존재한다.
 ㄴ 불린, 문자, 문자열, 정수, 부동 소수점

136. 변수: 저장하고자 하는 어떤 값이 있을 때, 그 값을 주시억장치에 기억하기 위한 공간이다. 자료형과 변수명을 작성하여 변수를 생성하는 과정이다. C, C++, 자바에서는 변수 선언을 하고, 파이썬에서는 별도로 변수 선언을 하지 않는다.

137. 배열: 같은 타입의 변수들로 이루어진 집합
 
138. 포인터: 변수의 주솟값을 저장하는 공간이다.
 ㄴ 포인터 선언: 데이터타입*포인터변수명 =&변수명
 ㄴ 데이터 타입 뒤에 *을 붙이면 주소를 저장하는 포인터 변수라는 의미이고, 일반 변수명에 &를 붙이면 해당 변수명의 주솟값이다.
 ㄴ int형 변수를 가리키는 포인터 변수 선언 시 int*을, char형은 char*, float는 float*을 사용한다.
 ㄴ 주소에 해당하는 값을 가리킬 때에는 *을 사용한다.

139. 자바 자료형
 ㄴ HashSet: 중복된 원소를 허용하지 않는 집합의 성질을 가진 자료형이며, 클래스이다. 순서는 중요하지 않음.
 ㄴ ArrayList: List의 하위 클래스로 크기가 가변적으로 변하는 선형리스트의 성질을 가지고 있는 자료형이며 클래스이다., 순서는 중요함, 중복도 허용
 ㄴ HashMap: 키와 값으로 구성된 객체를 저장하는 구조로 되어 있는 자료구조를 구현한 자료형이며 클래스이다.
 ㄴ LinkedList: 데이터를 저장하는 노드가 이전 노드와 다음 노드의 상태를 알고 있는 링크드 리스트 자료구조를 구현한 클래스

140. 파이썬 자료형
 ㄴ 세트형: 중복된 원소를 허용하지 않는 집합의 성질을 가지고 있는 자료구조 {1,  2, 3}...
 ㄴ 리스트형: 크기가 가변적으로 변하는 선형리스트의 성질을 가지고 있는 자료구조 [1, 2, 3]
 ㄴ 튜플형: 초기에 선언된 값에서 값을 생성, 삭제, 수정이 불가능한 형태의 자료구조( 1, 2, 3)
 ㄴ 딕셔너리형: 키와 값으로 구성된 객체를 저장하는 구조로 되어 있는 자료구조{ 'A':1, 'B':2}

141. 식별자(Identifier) 개념: 식별자는 변수, 상수, 함수 등 서로 구분하기 위해서 사용되는 이름.
 ㄴ 식별자 명명규칙: 영어 대/소문자, 숫자, 밑줄, 달러의 사용 가능, 첫자리에는 숫자 불가, 변수 이름 중간 공백 불가, 예약어의 경우 변수 사용 불가
 
142. 식별자 표기법
 ㄴ 카멜 표기법: 식별자 표기 시에 여러 단어가 이어지면 첫 단어 시작만 소문자로 표시하고, 각 단어의 첫 글자는 대문자로 지정하는 표기법 ex) inputFunction
 ㄴ 파스칼 표기법: 식별자 표기 시에 여러 단어가 이어지면 각 단어의 첫 글자는 대문자로 지정하는 표기법 ex) InputFunction
 ㄴ 스네이크 표기법: 식별자 표기 시에 여러 단어가 ㅣㅇ어지면 단어 사이에 언더바를 넣는 표기법 ex) input_function
 ㄴ 헝가리안 표기법: 식별자 표기 시 두어에 자료형을 붙이는 표기법, int형일 경우 n, char형일 경우 c, 문자열일 경우 sz를 붙임 ex) nScore -> int형을 말함

143. 클래스(Class)
 ㄴ 클래스는 객체지향 프로그래밍(OOP: Object-Oriented Programming)에서 특정 객체를 생성하기 위해 변수와 메서드를 정의하는 틀이다.
 ㄴ 접근제어자: 지정된 클래스, 변수, 메서드를 외부(같은 패키지이거나 다른 패키지)에서 접근할 수 있도록 권한을 설정하는 기능이다.
 
144. 접근 제어자 종류
 ㄴ public: 외부의 모든 클래스에서 접근이 가능한 접근 제어자
 ㄴ protected: 같은 패키지 내부에 있는 클래스, 하위 클래스(상속 받은 경우)에서 접근이 가능한 접근 제어자, 자기 자신과 상속받은 하위 클래스 둘 다 접근이 가능한 접근 제어자
 ㄴ default: 접근 제어자를 명시하지 않은 경우로 같은 패키지 내부에 있는 클래스에서 접근이 가능한 접근 제어자, 자바에서만 존재
 ㄴ private: 같은 클래스 내에서만 접근이 가능한 접근 제어자

145. 클래스 사용
 ㄴ 클래스는 변수와 메서드(함수) 형태로 구성되어 있다.
 ㄴ 클래스에서 변수는 변수 선언과 동일하고, 메서드는 사용자 정의함수와 문법이 동일하다.
 ㄴ 파이썬은 별도로 변수 선언을 하지 않기 때문에 메서드 형태로 구성되어 있다.
 
C++ 
class 클래스명{
private:
    변수_타입 변수명;
public:
    반환_데이터 타입 메서드명(){
        명령어;
        Return 반환값;
    }
}

146. 자신 클래스 참조
 this 포인터: this 포인터는 현재 객체를 가리키는 포인터이다. C++ JAVA에서 사용하는 것으로 클래스 내부의 변수와 함수를 가리킬 수 있다.
 self: 현재 객체를 가리키는 포인터이다. 파이썬에서 사용하는 것으로 클래스 내부의 변수와 함수를 가리킬 수 있다.

147. 클래스 선언
 ㄴ 클래스를 일반변수로 선언한 경우 선언함과 동시에 생성자가 호출되고, 일반 변수로 선언한 곳에서 함수가 종료되면 소멸자가 호출된다.
 ㄴ.클래스를 포인터 변수로 선언한 경우 new 키워드를 이용해 선언함과 동시에 생성자가 호출되고, delete 키워드를 이용해 해당 변수의 저장 공간을 삭제하면 소멸자가 호출된다.

148. 생성자
 ㄴ 생성자는 해당 클래스의 객체가 생성될 때 자동으로 호출되는 특수한 종류이 메서드이다. 생성자는 일반적으로 클래스의 멤버 변수를 초기화하거나 클래스를 사용하는데 필요한 설정이 필요한 경우 사용한다.
 ㄴ C++, 자바에서는 클래스명과 동일한 메서드명을 가지고, 반환 값이 없다.
 ㄴ 파이썬에서는 __init__이라는 메서드명을 사용하고, 첫 번재 매개변수로 self를 적어주며, 반환 값이 없다.

149. 소멸자
 ㄴ 소멸자는 객체의 수명이 끝났을 때 객체를 제거하기 위한 목적으로 사용되는 메서드이다. 
 ㄴ C++에서는 클래스명과 동일한 메서드명을 가지고 ~기호를 사용하며, 입력값과 반환값이 없다.
 ㄴ 자바에서는ㄴ finalize라는 메서드를 사용하며, 반환 값이 없다.
 ㄴ 파이썬에서는 __del__이라는 메서드명을 사용하고, 첫 번째 매개변수에 self를 적어주며, 반환 값이 없다.

150. 상속
 ㄴ 상속은 어떤 객체가 있을 때 그 객체의 변수와 메서드를 다른 객체가 물려받는 기능이다.

151. 오버로딩(Overloading): 동일 이름의 메서드를 매개변수만 다르게 하여 여러개 정의할 수 있는 기능이다. 파이썬에서는 오버로딩 기능 지원하지 않음

152. 오버라이딩: 하위 클래스에서 상위 클래스 메서드를 재정의할 수 있는 기능이다. C++에서는 virtual 키워드가 있어야 오버라이딩이 가능하다.

153. 추상 클래스: 추상 클래스는 미구현 추상 메서드를 한 개 이상 가지며, 자식 클래스에서 해당 추상 메서드를 반드시 구현하도록 강제하는 기능이다.

154. 인터페이스
 ㄴ 자바의 다형성을 극대화하여 개발코드 수정을 줄이고 프로그램 유지 보수성을 높이기 위한 문법이다.(일종의 추상 클래스)
 ㄴ 오직 추상 메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 다른 어떠한 요소도 허용하지 않는다. 
 ㄴ 구현된 것은 아무것도 없고, 밑 그림만 그려져 있는 '기본 설계도' 라고 할 수 있다.

155. 트랜잭션(Transaction)의 개념
  ㄴ 인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야하는 특성이자, 데이터베이스 시스템에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위

156. 트랜잭션 특성: ACID(Atomicity/Consistency/Isolation/Durability)
 ㄴ 원자성: 분해가 불가능한 작업의 최소 단위, 연산 전체가 성공 또는 실패(All or Nothing), 하나라도 실패할 경우 전체가 취소되어야하는 특성
   ㄴ 주요기법: Commit/Rollback, 회복성 보장
 ㄴ 일관성: 트랜잭션이 실행 성공 후 항상 일관된 데이터베이스 상태를 보존해야하는 특성
   ㄴ 주요기법: 무결성 제약조건, 동시성 제어
 ㄴ 격리성: 트랜잭션 실행 중 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근 불가한 특성
   ㄴ 주요기법: Read Uncommited, Read Committed, Repeatable Read, Serializable
 ㄴ 영속성: 성공이 완료된 트랜잭션의 결과는 영속적으로 데이터베이스에 저장하는 특성
   ㄴ 주요기법: 회복기법

157. 트랜잭션의 상태 변화: 활부완실철(활동, 부분완료, 완료, 실패, 철회)
 ㄴ 활동 상태(Active): 초기상태, 트랜잭션이 실행 중일 때 가지는 상태
 ㄴ 부분 완료 상태(Partially Committed): 마지막 명령문이 실행 된 후에 가지는 상태
 ㄴ 완료 상태(Committed): 트랜잭션이 성공적으로 완료된 후 가지는 상태
 ㄴ 실패 상태(Failed): 정상적인 실행이 더 이상 진행될 수 없을 때 가지는 상태
 ㄴ 철회 상태(Aborted): 트랜잭션이 취소되고 데이터베이스가 트랜잭션 시작 전 상태로 환원된 상태

158. 트랜잭션 제어: 커롤체(커밋/롤백/체크포인트)
 ㄴ 트랜잭션 제어 언어는 TCL(Transaction Control Language)라고 하며, 트랜잭션의 결과를 허용하거나 취소하는 목적으로 사용되는 언어를 지칭한다.
 ㄴ 커밋: 트랜잭션 확정/트랜잭션을 메모리에 영구적으로 저장하는 명령어
 ㄴ 롤백: 트랜잭션 취소/트랜잭션 내역을 저장 무효화시키는 명령어
 ㄴ 체크포인트: 저장 시기 설정/롤백을 위한 시점을 지정하는 명령어

159. 병행제어(일관성 주요 기법)
 ㄴ 개념: 병행 제어는 다수 사용자 환경에서 여러 트랜잭션을 수행할 때, 데이터베이스 일관성 유지를 위해 상호작용을 제어하는 기법이다.
 ㄴ 목적: 데이터베이스의 공유를 최대화 한다. 시스템의 활용도를 최대화 한다. 데이터베이스 일관성을 유지. 사용자에 대한 응답시간을 최소화

160. 병행제어 미보장 시 문제점: 갱현모연
 ㄴ 갱신 손실(Lost Update): 먼저 실행된 트랜잭션의 결과를 나중에 실행된 트랜잭션이 덮어 쓸 때 발생하는 오류
 ㄴ 현황 파악오류(Dirty Read): 트랜잭션의 중간 수행 결과를 다른 트랜잭션이 참조하여 발생하는 오류
 ㄴ 모순성(Inconsistency): 두 트랜잭션이 동시에 실행되어 데이터베이스의 일관성이 결여되는 오류
 ㄴ 연쇄복귀(Cascading Rollback): 복수의 트랜잭션이 데이터 공유 시 특정 트랜잭션이 처리를 취소할 경우 트랜잭션이 처리한 곳의 부분을 취소하지 못하는 오류

161. 병행 제어 기법의 종류: 로낙타다
 ㄴ 로킹(Locking): 같은 자원을 액세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보장하는 직렬화 기법
 ㄴ 낙관적 검증: 트랜잭션이 어떠한 검증도 수행하지 않고 일단 트랜잭션을 수행하고, 트랜잭션 종료 시 검증을 수행하여 데이터베이스에 반영하는 기법
 ㄴ 타임 스탬프 순서(Time Stamp Ordering): 트랜잭션과 트랜잭셩이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 타임 스탬프(Time Stamp)를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법
 ㄴ 다중버전 동시성 제어(MVCC; Multi Version Concurrency Control): 트랜잭션의 타임스탬프와 접근하려는 데이터의 타임스탬프를 비교하여 직렬가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법

162. 로킹의 특징
 ㄴ 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있음
 ㄴ 로킹 단위가 작아지면 데이터베이스 공유도가 증가
 ㄴ 로킹 단위가 작아지면 로킹 오버헤드 증가
 ㄴ 한꺼번에 로킹할 수 있는 객체의 크기를 로킹 단위라고 함

163. 데이터베이스 고립화 수준(격리성 주요 기법)
 ㄴ 개념: 고립화 수준은 다른 트랜잭션이 현재의 데이터에 대한 무결성을 해치지 않기 위해 잠금을 설정하는 정도이다.
 ㄴ 종류
   가. Read Uncommitted: 한 트랜잭션에서 연산(갱신) 중인 데이터를 다른 트랜잭션이 읽는 것을 허용하는 수준, 연산 중인 데이터에 대한 연산을 불허
   나. Read Committed: 한 트랜잭션에서 연산(갱신)을 수행할 때, 연산 완료 시 까지 연산 대상 데이터에 대한 읽기를 제한하는 수준, 연산이 완료되어 커밋된 데이터는 다른 트랜잭션이 읽는 것을 허용
   다. Repeatable Read: 선행 트랜잭션이 특정 데이터를 읽을 때, 트랜잭션 종료 시 까지 해당 데이터에 대한 갱신, 삭제를 제한하는 수준
   라. Serializable Read: 선행 트랜잭션이 특정 데이터 영역을 순차적으로 읽을 때, 해당 데이터 영역 전체에 대한 접근 제한하는 수준 

164. 회복 기법(영속성 주요 기법)
 ㄴ 개념: 회복 기법은 트랜잭션을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업이다.
 ㄴ 종류: 회로체크: 회복 기법(로그 기반 / 체크 포인트 / 그림자 페이징 회복기법)
   가. 로그 기반 회복 기법
     ㄴ 지연 갱신 회복 기법(Deferred Update): 트랜잭션이 완료되기 전 까지 데이터베이스에 기록하지 않는 기법
     ㄴ 즉각 갱신 회복 기법(Immediate Update): 트랜잭션 수행 중 갱신 결과를 바로 DB에 반영하는 기법
  나. 체크 포인트 회복 기법: 장애 발생 시 검사점 이후에 처리된 트랜잭션에 대해서만 장애 발생 이전의 상태로 복원시키는 회복 기법
  다. 그림자 페이징 회복 기법: 데이터베이스 트랜잭션 수행 시 복제본을 생성하여 데이터베이스 장애 시 이를 이용해 복구하는 기법

165. DDL(Data Definition Language) 데이터 정의어
  ㄴ 개념: 데이터 정의어는 데이터를 정의하는 언어, 데이블과 같은 데이터 구조를 정의하는 데 사용되는 명령어들로 특정 구조를 생성, 변경, 삭제, 이름을 바꾸는 데이터 구조와 관련된 명령어들
 
166. DDL의 대상: 도스뷰테인
  ㄴ 도메인: 하나의 속성이 가질 수 있는 원자값들의 집합, 속성의 데이터 타입과 크기, 제약조건 등의 정보
  ㄴ 스키마: 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조, 스키마는 외부/개념/내부 3계층으로 구성되어 있음
     ㄴ 외부: 사용자나 개발자의 관점에서 필요로 하는 데이터베이스의 논리적 구조, 사용자 뷰를 나타냄, 서브 스키마로 불림
     ㄴ 개념: 데이터베이스의 전체적인 논리적 구조, 전체적인 뷰를 나타냄, 개체 간의 관계, 제약조건, 접근 권한, 무결성, 보안에 대해 정의
     ㄴ 내부: 물리적 저장장치의 관점에서 보는 데이터베이스의 구조, 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 표현
  ㄴ 뷰: 하나 이상의 물리 테이블에서 유도되는 가상의 테이블
  ㄴ 테이블: 데이터 저장 공간
  ㄴ 인덱스: 검색을 빠르게 하기 위한 데이터 구조

 167. 테이블: 테이블은 데이터를 저장하는 항목인 필드들로 구상된 데이터의 집합체이다. 하나의 DB 내에 여러 개의 테이블로 구성될 수 있고, 릴레이션 혹은 엔터티라고도 불린다.
 168. 테이블 관련 용어 
   ㄴ 튜플/행: 테이블 내의 행을 의미하며 레코드라고도 함, 튜플은 릴레이션에서 같은 값을 가질 수 없음
   ㄴ 애트리뷰트/열: 테이블 내의 열을 의미
   ㄴ 식별자: 여러 개의 집합체를 담고 있는 관계형 데이터베이스에서 각각을 구분할 수 있는 논리적인 개념
   ㄴ 카디널리티: 튜블의 개수
   ㄴ 차수: 애트리뷰트의 개수
   ㄴ 도메인: 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값 들의 집합

169. 뷰
  ㄴ 뷰는 논리 테이블로서 사용자에게(생성관점 아닌 사용관점) 테이블과 동일하다. 
  ㄴ 뷰는 물리 테이블로부터 생성 가능하며, 다수의 테이블 또는 다른 뷰를 이용해 만들 수 있다.
  ㄴ 뷰와 같은 결과를 만들기 위해 조인 기능을 활용할 수 있으나, 뷰가 만들어져 있다면 사용자는 조인 없이 하나의 테이블을 대상으로 하는 단순한 질의어를 사용할 수 있다.\
 
170. 뷰의 특징
  ㄴ 논리적 데이터 독립성 제공
  ㄴ 데이터 조작 연산 간소화
  ㄴ 보안 기능(접근제어) 제공
  ㄴ 뷰 변경 불가(AlTER 문을 이용하여 변경할 수 없음)

171. 뷰의 목적: 뷰를 사용하는 주된 이유는 단순 질의어를 사용할 수 있기 때문이다, FROM절에 있는 하나의 뷰를 통해 뷰를 구성하는 복수의 테이블을 대체하는 단순성에 그 의의가 있다. 중요 데이터 일부만을 제공할 수 있는 장단점이 있다.

172. 뷰의 장단점
  ㄴ 논리적 독립성 제공: 논리 테이블 구조가 변경되어도 뷰를 사용하는 응용프로그램은 변경하지 않아도 됨
  ㄴ 복수 테이블에 존재하는 여러 종류의 데이터에 대해 단순한 질의어 사용 가능
  ㄴ 데이터 보안 용이: 중요 보안 데이터를 저장 중인 테이블에는 접근 불허, 일부만 볼 수 있는 뷰에는 허용 
  ㄴ 뷰 자체 인덱스 불가: 인덱스는 물리적으로 저장된 데이터를 대상으로 하기에 논리적 구성인 뷰 자체는 인덱스를 가지지 못함
  ㄴ 뷰 정의 변경 불가: 정의를 변경하려면 제거하고 재생성
  ㄴ 데이터 변경 제약 존재: 뷰의 내용에 대한 삽입, 삭제, 변경 제약 있음

173. 인덱스
  ㄴ 인덱스는 데이터를 빠르게 찾을 수 있는 수단으로서, 테이블에 대한 조회속도를 높여 주는 자료구조이다.
  ㄴ 인덱스는 테이블의 특정 레코드 위치를 알려 주는 용도로 사용한다.

174. 인덱스 특징
  ㄴ 기본키(PK; Primary Key) 컬럼은 자동으로 인덱스가 생성된다.
  ㄴ 연월일이나 이름을 기준으로 하는 인덱스는 자동으로 생성되지 않는다.
  ㄴ 테이블의 컬럼에 인덱스가 없는 경우, 테이블의 전체 내용을 검색한다.
  ㄴ인덱스가 생성되어 있을 때 데이터를 빠르게 찾을 수 있다.

175. 인덱스의 종류: 순해비함 단결클(순서, 해시, 비트맵, 함수기반, 단일, 결합, 클러스터드)
176. 인덱스 스캔 방식
  ㄴ 인덱스 범위 스캔, 인덱스 전체 스캔, 인덱스 단일 스캔, 인덱스 생략 스캔

177. DDL 명령어: CREATE, ALTER, DROP, TRUNCATE

178. DML(Data Manipulation Language)
  ㄴ 개념: 데이터베이스에 저장된 자료들은 입력, 수정, 삭제, 조회하는 언어
 
179. DML 명령어: SELECT, INSERT, UPDATE, DELETE

180. SELECT 절: 데이터를 조회할 때 사용됨
  ㄴ SELECT: 검색하고자 하는 속성명, 계산식을 기술, 속성명 별칭은 AS를 사용하며 생략 가능함
  ㄴ SELECT 뒤에 아무것도 없으면 ALL이 기본값,
  ㄴ DISTINCT 중복된 속성이 조회될 경우 그 중 한개만 검색
  ㄴ FROM: 테이블 명 기술
  ㄴ WHERE: 조건 기술
  ㄴ GROUP BY: 그룹으로 분류할 떄 사용
  ㄴ HAVING: GROUP BY에 의해 분류한 후에 그룹에 대한 조건 지정
  ㄴ ORDER BY: 속성값을 정렬할 때 사용(ASC 오름차순, DESC 내림차순)

181. 조인 개념: 조인은 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법이다. 두 릴레이션으로부터 관련된 튜플들을 결합하여 하나의 튜플로 만드는 가장 대표적인 데이터 연결 방법이다. 
  ㄴ 내부조인: 공통 존재 컬럼의 값이 같은 경우를 추출하는 기법
  ㄴ 외부조인 왼쪽: 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 동일 데이터 추출, 오른쪽은 오른쪽의 모든 데이터, 완전 외부 조인은 양쪽의 모든 데이터 추출
  ㄴ 교차조인: 조인 조건이 없는 모든 데이터 조합을 추출
  ㄴ 셀프조인: 자기 자신에게 별칭을 지정한 후 다시 조인

182. 서브쿼리
  ㄴ 서브쿼리는 SQL 문 안에 포함된 또 다른 SQL 문이다.
  ㄴ 서브쿼리의 용도는 알려지지 않은 기준을 위한 검색을 위해 사용한다.
  ㄴ 메인쿼리와 서브쿼리 관계는 주종 관계로서, 서브쿼리에 사용되는 컬럼 정보는 메인쿼리의 컬럼 정보를 사용할 수 있으나, 역으로는 성립하지 않는다.

183. 서브쿼리 유형
  ㄴ SELECT 서브쿼리: 스칼라 서브쿼리 라고도 불림, 반드시 단일 행을 리턴해야함, SUM, COUNT, MIN, MAX 등과 같은 집계함수가 많이 쓰임
  ㄴ FROM 서브쿼리: 인라인 뷰 라고 불림, 뷰 처럼 결과가 동적으로 생성된 테이블 형태로 사용할 수 있음
  ㄴ WHERE 서브쿼리: 중첩 서브쿼리 라고도 불림

184. 집합 연산자
  ㄴ 집합 연산자는 테이블을 집합 개념으로 보고, 두 테이블 연산에 집합 연산자를 사용하는 방식이다.
  ㄴ 집합 연산자는 여러 질의 결과를 연겨라여 하나로 결합하는 방식을 사용한다.(2개 이상의 질의 결과를 하나의 결과로 만들어준다.)

185. 집합 연산자 유형
  ㄴ UNION: 중복 행이 제거된 쿼리 결과를 반환하는 집합 연산자.
  ㄴ UNION ALL: 중복 행이 제거되지 않은 쿼리 결과를 반환하는 집합 연산자.
  ㄴ INTERSECT: 두 쿼리 결과에 공통적으로 존재하는 결과를 반환하는 집합 연산자.
  ㄴ MINUS: 첫 쿼리에 있고 두번째 쿼리에는 없는 결과를 반환하는 집합 연산자.

186. DCL(Data Control Language)
  ㄴ 데이터 제어어는 데이터베이스 관리자가 데이터 보안, 무결성 유지, 병행 제어, 회복을 위해 관리자가 사용하는 제어용 언어.
  ㄴ GRANT와 REVOKE가 있다.

187. 데이터 분석 함수의 개념: 총합, 평균 등 데이터 분석을 위해서는 복수 행 기준의 데이터를 모아서 처리하는 것을 목적으로 하는 다중 행 함수이다. 

188. 데이터 분석 함수의 종류
  ㄴ 집계함수: 여러 행 또는 테이블 전체 행으로부터 하나의 결괏값을 반환하는 함수
  ㄴ 그룹함수: 소그룹 간의 소계 및 중계 등의 중간 합계 분석 데이터를 산출하는 함수
  ㄴ 윈도함수: 데이터베이스를 사용한 온라인 분석 처리 용도로 사용하기 위해서 표준 SQL에 추가된 기능

189. 집계함수의 개념과 종류: 여러 행 또는 테이블 전체 해응로부터 하나의 결괏값을 반환하는 함수이다. COUNT, SUM, AVG, MAX, MIN, STDDEV, VARIAN

190. 그룹함수 개념: 테이블의 전체 행을 하나 이상의 컬럼을 기준으로 컬럼 값에 따라 그룹화하여 그룹별로 결과를 출력하는 함수이다.

191. ROLLUP 함수
  ㄴ ROLLUP에 의해 지정된 컬럼은 소계 등 중간 집계 값을 산출하기 위한 그룹함수이다, 지정 컬럼의 수보다 하나 더 큰 레벨 만큼의 중간 집계 값이 생성된다.
  ㄴ ROLLUP 지정 컬럼은 계층별로 구성되기 때문에 순서가 바뀌면 수행 결과가 바뀜을 유의한다.
 
192. CUBE 함수: 결합가능한 모든 값에 대해 다차원 집계를 생성하는 그룹 함수. 연산이 많아 시스템에 부담을 준다.

193. GROUPING SETS 함수: 집계 대상 컬럼들에 대한 개별 집계를 구할 수 있으며, ROLLUP이나 CUBE와는 달리 컬럼 간 순서와 무관한 결과를 얻을 수 있는 그룹 함수이다.

194. 윈도 함수: 윈도 함수는 데이터베이스를 사용한 온라인 분석 처리 용도로 사용하기 위해서 표준 SQL에 추가된 함수이다. 윈도 함수를 OLAP 함수 라고도 한다.
  ㄴ OLAP: OnLine Analytical Processing, 의사결정 지원 시스템으로, 사용자가 동일한 데이터를 여러 기준을 이용하는 다양한 방식으로 바라보면서 다차원 데이터 분석을 할 수 있도록 도와주는 기술이다.

195. 윈도 함수의 분류: 순위함수, 행순서 함수, 그룹 내 비율 함수(순행비)

196. 순위함수 종류
  ㄴ RANK: 특정 항목(컬럼)에 대한 순위를 구하는 함수, 동일 순위의 레코드 존재 시 후순위는 넘어감(2위가 3개인 레코드의 경우 2위 2위 2위 5위 6위)
  ㄴ DENSE_RANK: 레코드의 순위를 계산, 동일 순위의 레코드 존재 시에도 후순위를 넘어가지 않음(2위가 3개인 레코드의 경우 2위 2위 2위 3위 4위)
  ㄴ ROW_NUMBER: 레코드의 순위를 계산, 동일 순위의 값이 존재해도 이와 무관하게 연속 번호를 부여(2위가 3개인 레코드의 경우 2위 3위 4위 5위 6위)

197. 행 순서 함수 종류
  ㄴ FIRST_VALUE: 파티션별 윈도에서 가장 먼저 나오는 값을 찾음, 집계 함수의 MIN과 동일한 결과를 출력
  ㄴ LAST_VALUE: 파티션별 윈도에서 가장 늦게 나오는 값을 찾음, 집계 함수의 MAX와 동일한 결과를 출력
  ㄴ LAG: 파티션별 윈도에서 이전 로우의 값 반환
  ㄴ LEAD: 파티션별 윈도에서 이후 로우의 값 반환

198. 그룹 내 비율 함수
  ㄴ RATIO_TO_REPORT: 주어진 그룹에 대해 합을 기준으로 각 로우의 상대적 비율을 반환하는 함수, 결과값은 0~1 범위를 가짐, OVER 괄호 안에 컬럼 생략 시 그룹은 테이블 전체가 대상
  ㄴ PERCENT_RANK: 주어진 그룹에 대해 제일 먼저 나오는 것을 0으로, 제일 늦게 나오는 것을 1로 하여 값이 아닌 행의 순서별 백분율을 구하는 함수, 결과값은 0~1 범위를 가짐

200. 절차형 SQL 개념: 절차형 SQL은 일반적인 개발 언어처럼 SQL 언어에서도 절차 지향적인 프로그램이 가능하도록 하는 트랜잭션 언어이다.

201. 절차형 SQL 종류
  ㄴ 프로시저: 일련의 쿼리들을 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합
  ㄴ 사용자 정의 함수: 일련의 SQL 처리를 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 절차형 SQL
  ㄴ 트리거: 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL

202. 프로시저 구성: 디비컨SET
  ㄴ Declare: 프로시저의 명칭, 변수와 인수 그리고 그에 대한 데이터 타입을 정의하는 부분
  ㄴ Begin/End: 프로시저의 시작과 종료를 표현하며, Begin/End가 쌍을 이룸, 다수 실행을 제어하는 기본적 단위가 되며 논리적 프로세스를 구성
  ㄴ Control: 기본적으로는 순차적으로 처리, 조건문과 반복문을 이용하여 처리
  ㄴ SQL: DML주로 사용, DDL 중 TRUNCATE 사용
  ㄴ Exception: 예외 발생 시 예외 처리 방법 정의하는 처리부
  ㄴ Transaction: 프로시저에서 수행된 DML 수행 내역의 DBMS의 적용 또는 취소 여부를 결정하는 처리부

203. 사용자 정의함수(User-Defined Function) 개념
  ㄴ 사용자 정의함수는 일련의 SQL 처리를 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 절차형 SQL 이다.

204. 사용자 정의함수 구성: 디비컨SER
  ㄴ 기본적인 사항은 프로시저와 동일하고 반환에서의 부분만 프로시저와 다르다.
  ㄴ 사용자 정의 함수의 호출을 통해 실행되며, 반환되는 단일 값을 조회 또는 삽입, 수정 작업에 이용하는 것이 일반적이다.
  ㄴ Declare: 명칭, 변수와 인수 그리고 그에 대한 데이터 타입을 정의하는 부분
  ㄴ Begin/End: 시작과 종료를 표현하며, Begin/End가 쌍을 이룸, 다수 실행을 제어하는 기본적 단위가 되며 논리적 프로세스를 구성
  ㄴ Control: 기본적으로는 순차적으로 처리, 조건문과 반복문을 이용하여 처리
  ㄴ SQL: DML주로 사용, DDL 중 TRUNCATE 사용
  ㄴ Exception: 예외 발생 시 예외 처리 방법 정의하는 처리부
  ㄴ Return: 호출문에 대한 함숫값을 반환

205. 트리거 개념
  ㄴ 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL이다.
  ㄴ 이벤트는 전체 트랜잭션 대상과 각 행에 의해 발생하는 경우 모두를 포함할 수 있으며 테이블과 뷰, DB작업을 대상으로 정의할 수 있다.

206. 트리거의 목적
  ㄴ 특정 테이블에 대한 데이터 변경을 시작점으로 설정하고, 그와 관련된 작업을 자동적으로 수행하기 위해 사용
  ㄴ 이벤트와 관련된 테이블의 데이터 삽입, 추가 삭제 작업을 DBMS가 자동적으로 실행시키는 데 활용

207. 트리거의 종류: 행 트리거: 데이터 변화가 생길 때 마다 실행, 문장 트리거: 트리거에 의해 단 한 번 실행

208. 트리거 구성: 디이비컨SE
  ㄴ 프로시저나 사용자 정의함수와 기본적 문법은 같다, 반환 값이 없고 DML을 주된 목적으로 한다는 점에서 프로시저와 유사, EVENT 명령어를 통해 트리거 실행을 위한 이벤트를 인지한다는 점, 외부 변수 IN/OUT이 없다는 점은 프로시저나 사용자 정의 함수와 다르다.
  ㄴ Declare: 명칭, 변수와 인수 그리고 그에 대한 데이터 타입을 정의하는 부분
  ㄴ Event: 트리거가 실행되는 타이밍, 이벤트를 명시하는 부분
  ㄴ Begin/End: 시작과 종료를 표현하며, Begin/End가 쌍을 이룸, 다수 실행을 제어하는 기본적 단위가 되며 논리적 프로세스를 구성
  ㄴ Control: 기본적으로는 순차적으로 처리, 조건문과 반복문을 이용하여 처리
  ㄴ SQL: DML주로 사용, DDL 중 TRUNCATE 사용
  ㄴ Exception: 예외 발생 시 예외 처리 방법 정의하는 처리부

209. 쿼리 성능 개선(튜닝) 개념
  ㄴ 쿼리 성능 개선은 데이터베이스에서 프로시저에 있는 SQL 실행 계획을 분석, 수정을 통해 최소의 시간으로 원하는 결과를 얻도록 프로시저를 수정하는 작업.
  ㄴ SQL 성능 개선을 통해 데이터 조작 프로시저의 성능 개선이 가능하다.

210. 쿼리 성능 개선 절차: 문제 있는 SQL식별 -> 옵티마이저 통계 확인 -> SQL문 재구성 -> 인덱스 재구성 -> 실행계획 유지관리

211. 옵티마이저 개념
  ㄴ 옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리경로를 생성해주는 DBMS 내부의 핵심 엔진이다.
  ㄴ 옵티마이저가 생성한 SQL 처리경로를 실행계획 이라고 부른다.

212. 옵티마이저 유형
  ㄴ RBO(Rule Based Optimizer) 규칙기반 옵티마이저: 통계 정보가 없는 상태에서 사전 등록된 규칙에 따라 질의 실행 계획을 선택하는 옵티마이저, 규칙(우선 순위)기반, 인덱스 구조, 연산자, 조건절 형태 등, 사용자가 원하는 처리경로로 유도하기 쉬움
  ㄴ CBO(Cost Based Optimizer) 비용기반 옵티마이저: 통꼐 정보로부터 모든 접근 경로를 고려한 질의 실행 계획을 선택하는 옵티마이저, 비용(수행 시간)기반, 레코드 개수, 블록 개수, 평균 행길이, 컬럼값의 수, 분포, 인ㄷ게스 높이, 클러스터링 팩터 등, 옵티마이저의 이해도가 낮아도 성능보장 가능(기본설정)

213. 옵티마이저 역할: 쿼리 변환, 비용 산정, 계획 생성

214. 힌트사용: SQL 성능 개선의 핵심 부분으로 옵티마이저의 실행 계획을 원하는 대로 변경할 수 있게 한다. 옵티마이저가 항상 최선의 실행 계획을 수립할 수 없어 명시적인 힌트를 통해 실행계획 변경
  ㄴ 개념: 실행하려 하는 SQL문에 사전에 정보를 주어서 SQL문 실행에 빠른 결과를 가져오는 효과를 만드는 문법

215. 개발환경 구축
  ㄴ 개발환경 구성 시 구현될 시스템 요구사항의 명확한 이해가 필요하다. 
  ㄴ 개발 도구와 서버의 선정이 이루어져야 하고, 개발에 사용되는 도구들의 사용 편의성과 성능, 라이선스를 확인한다.

216. 개발 도구의 분류: 빌구테형
  ㄴ 빌드도구: 작성한 코드의 빌드 및 배포를 수행, 각각의 구성요소와 모듈에 대한 의존성 관리를 지원
  ㄴ 구현도구: 개발자의 코드 작성과 디버깅, 수정 등과 같은 작업 지원, 프로그램을 개발할 때 가장 많이 사용되는 도구
  ㄴ 테스트도구: 코드의 기능 검증과 전체의 품질을 높이기 위해 사용하는 도구, 코드의 테스트, 테스트에 대한 계획 수행 및 부석 등의 작업 가능
  ㄴ 형상관리도구: 개발자들이 작성한 코드와 리소스 등 산출물에 대한 버전 관리를 위한 도구, 프로젝트 진행시 필수로 포함되는 도구

217. 서버 하드웨어 개발환경: 프로젝트 구성에 따라 웹 서버, 웹 애플리케이션 서버, 데이터베이스 서버, 파일 서버로 구분한다.
  ㄴ 웹서버: HTTP를 이용한 요청/응답을 처리, 웹 상의 정적 콘텐츠(CSS, Javascript, Image)를 처리, WEB-WAS-DB 3계층 구조를 실무에서 활용, 주요 제품으로 Apache 웹 서버, IIS 웹 서버, Google Web Server, Nginx 등 존재
  ㄴ 웹 애플리케이션 서버: 동적 콘텐츠(Servlet, JSP)를 처리하기 위해 사용, 사용자 요청 스레드를 처리하고, 데이터베이스에 접속하여 SQL 쿼리 문에 대한 결괏 값을 반환하는 역할을 수행하는 서버이다. 주요 제품으로 Tomcat, Weblogic, Jeus, Resin 등 존재
  ㄴ 데이터베이스 서버: 데이터의 수집, 저장을 위한 용도로 사용, 연계되는 주요 DBMS로 Mysql, Oracle, MS-SQL, DB2 등 존재
  ㄴ 파일 서버: 파일 저장 하드웨어로 물리 저장장치를 활용한 서버, 대용량 HDD, SSD 등의 장치가 존재

218. 클라이언트 하드웨어 개발환경: 서버 개발환경에서 제공된 서비스를 사용하기 위해 UI를 제공한다. 클라이언트 프로그램, 웹 브라우저, 모바일 앱, 모바일 웹으로 구분한다.

219. 소프트웨어 개발환경: 개발을 위한 기본적인 소프트웨어 개발환경을 선택 및 구성한다. 큰 틀에서 프로젝트 요구사항에 부합한 운영체제, 미들웨어, 데이터베이스 시스템을 선정한다.
  ㄴ 운영체제: 서버의 하드웨어를 사용자 관점에서 편리하고 유용하게 사용하기 위한 소프트웨어, 프로젝트의 성격에 따른 운영체제 사용
  ㄴ 미들웨어: 컴퓨터와 컴퓨터 간의 연결을 쉽고 안전하게 할 수 있도록 해주고 이에 대한 관리를 도와주는 소프트웨어, 자바 기반 환경에서 JVM을 설치하여 컨테이너로의 기능을 주로 이용
  ㄴ JVM: 시스템 메모리를 관리하면서 자바 기반 애플리케이션을 위해 이식 가능한 실행 환경을 제공하는 소프트웨어이다.
  ㄴ 컨테이너: JSP와 서블릿을 실행시킬 수 있는 소프트웨어이다.
  ㄴ DBMS: 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어, 데이터의 저장 및 활용을 위해 설치.

220. 형상 관리
  ㄴ 개념: 소프트웨어 개발을 위한 전체 과정에서 발생하는 모든 항목의 변경 사항을 관리하기 위한 활동이다, SW 생명주기 동안 형상 관리를 통해 산출물을 체계적으로 관리하여 SW의 가시성, 추적성, 무결성 등의 품질 보증을 보장할 수 있다.
  ㄴ 목적: 프로젝트 생명주기 동안 제품의 무결성과 변경에 대한 추적성을 확보할 수 있다, 변경이 발생 되었을 때 처리하는 메커니즘을 제공한다, 대표적인 메커니즘으로 형상 관리대상 파악, 베이스라인 지정, 형상 관리, 접근제어 등이 있다.
  * 베이스라인: 개발 과정의 각 단계의 산출물을 검토, 평가, 조정, 처리 등 변화를 통제하는 시점의 기준이다.

221. 형상관리 절차: 식통감기
  ㄴ 형상 식별: 형상 관리 대상을 정의 및 식별하는 활동, 추적성 부여를 위해 ID와 관리번호를 부여, 변경 관련 이슈 발생 시 ID와 관리번호를 이용하여 추적
  ㄴ 형상 통제: 형상 항목의 버전 관리를 위한 형상통제위원회 운영, 변경요구 관리, 변경제어, 형상 관리 등 통제 지원, 베이스라인에 대한 관리 및 형상 통제 수행 가능
  ㄴ 형상 감사: 소프트웨어 베이스라인의 무결성 평가, 베이스라인 변경 시 요구사항과  일치 여부 검토
  ㄴ 형상 기록: 소프트웨어 형상 및 변경관리에 대한 각종 수행결과를 기록, 형상결과 보고서 작성

222. 소프트웨어 형상 관리 도구 유형: 공클분
  ㄴ 공유폴더 방식(RCS, SCCS): 매일 개발이 완료된 파일은 약속된 위치의 공유 폴더에 복사하는 방식, 담당자 한 명이 매일 공유 폴더의 파일을 자기 PC로 복사하고 컴파일하여 에러 확인과 정상 동작 여부 확인
  ㄴ 클라이언트/서버 방식(CVS, SVN): 중앙에 버전 관리 시스템을 항시 동작시키는 방식, 개발자들의 현재 작업 내용과 이전 작업 내용 추적에 용이, 서로 다른 개발자가 같은 파일을 작업했을 때 경고 메시지 출력
  ㄴ 분산 저장소 방식(Git): 로컬 저장소와 원격 저장소로 분리되어 분산 저장하는 방식, 중앙의 저장소에서 로컬 파일을 클론한 순간 개발자 자신 만의 로컬 저장소 생성, 개발 완료한 파일을 수정한 다음에 로컬 저장소에 우선적으로 커밋한 이후, 다시 원격 저장소에 반영(Push)하는 방식

223. 소프트웨어 형상 관리 도구별 특징
  ㄴ CVS(Concurrent Versions System): 서버와 클라이언트로 구성되어있고, 다수의 인원이 동시에 범용적인 운영체제로 접근 가능한 형상 관리 도구
  ㄴ SVN(Subversion): 하나의 서버에서 소스를 쉽고 유용하게 관리할 수 있게 도와주는 도구, 저장소를 만들어 그곳에 소스를 저장해 소스 중복이나 여러 문제를 해결하기 위한 도구
  ㄴ RCS(Revision Control System): CVS와 달리 소스 파일의 수정을 한 사람만으로 제한하여 다수의 사람이 파일의 수정을 동시에 할 수 없도록 파일 잠금 방식으로 형상을 관리 하는 도구
  ㄴ Bitkeeper: SVN과 비슷한 중앙 통제 방식으로 대규모 프로젝트에서 빠른 속도를 내도록 개발된 형상 관리 도구
  ㄴ Git: Git의 속도에 중점을 둔 분산형 버전 관리 시스템이며, 대형 프로젝트에서 효과적이고 유용, Git의 Commit은 로컬 저장소, Push라는 동작으로 원격 저장소에 반영, 로컬 저장소에서 작업이 이루어져 매우 빠른 응답을 받을 수 있음, 전체 기록과 각 기록을 추적할 수 있는 정보를 포함하는 완전한 형태의 저장소
  ㄴ Clear Case: 복수 서버, 복수 클라이언트 구조이며 서버가 부족할 때 필요한 서버를 하나씩 추가하여 확장성을 기할 수 있음

224. JDK: Java Development Kit, 자바 애플리케이션을 구축하기 위한 핵심 플랫폼이다.

225. Maven: Java 기반 프로젝트 관리를 목적으로 하는 빌드 도구로 컴파일, 빌드, 패키지, 테스트, 라이브러리 관리 기능이 있다.

226. Gradle: Groovy를 기반으로 한 빌드 도구로 Ant와 Maven 등 이전 세대 빌드 도구의 단점을 보완하고 개선했다.

227. 모듈 개념
  ㄴ 모듈은 그 자체로 하나의 완전한 기능을 수행 할 수 있는 독립된 실체이다. 
  ㄴ 모듈화를 통해 분리된 시스템의 각 기능들로 서브프로그램, 서브 루틴, 소프트웨어 내의 단위 프로그램, 작업 단위 등과 같은 의미로 사용된다.

228. 모듈 특징
  ㄴ 각각의 모듈은 상대적으로 독립성을 가지고 있다.
  ㄴ 모듈 내부에는 그 모듈을 하나로 통합하는 수 많은 조합이 존재할 수 있다.
  ㄴ 모듈은 단독으로 컴파일할 수 있으며, 재사용 할 수 있다.
  ㄴ 독립성이 높은 모듈일수록 모듈 수정 시에도 다른 모듈들에는 영향을 거의 미치치 않고, 오류 발생 시에도 쉽게 해결할 수 있다.
  ㄴ 독립성은 결합도와 응집도에 의해 측정되며, 독립성을 높이려면 모듈의 결합도는 약하게, 응집도는 강하게, 크기는 작게 만들어야한다.

229. 모듈화(Modularity)의 개념 및 기법
  ㄴ 모듈화는 소프트웨어의 성능을 향상시키거나 복잡한 시스템의 수정, 재사용, 유지 관리 등이 용이하도록 기능 단위의 모듈로 분해나는 설계 및 구현 기법
  ㄴ기법: 루틴, 메인 루틴, 서브 루틴

230. 공통 모듈: 전체 프로그램의 기능 중 특정 기능을 처리할 수 있는 실행 코드이다. 자체적으로 컴파일이 가능하고, 다른 프로그램에서 재사용이 가능하다.
  ㄴ 소프트웨어 개발에 있어 기능을 분할하고 추상화하여 성능을 향상시키고 유지보수를 효과적으로 하기 위한 공통 컴포넌트 구현 기법이다, 인터페이스 모듈, 데이터베이스 접근 모듈 등 필요한 공통 모듈을 구현한다.

231. 응집도(Cohesion)의 개념
  ㄴ 응집도는 모듈의 독립성을 나타내는 정도로, 모듈 내부 구성요소 간 연관 정도이다. 하나의 모듈은 하나의 기능을 수행할 수록 응집도가 높다.
  ㄴ 하나의 모듈은 하나의 기능을 수행할 수록 응집도가 높다.

232. 응집도 순서: 우논시절 통 순기
  ㄴ 우연적(Coincidental cohesion): 모듈 내부의 각 구성요소가 연관이 없을 경우의 응집도
  ㄴ 논리적(Logical): 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우의 응집도
  ㄴ 시간적(Temporal): 연관된 기능이라기보다 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우의 응집도
  ㄴ 절차적(Procedural): 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소 들이 그 기능을 순차적으로 수행할 경우의 응집도
  ㄴ 통신적(Communication): 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우의 응집도
  ㄴ 순차적(Sequential): 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용할 경우의 응집도
  ㄴ 기능적(Functional): 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우의 응집도

233. 결합도(Coupling)의 개념
  ㄴ 모듈 내부가 아닌 외부의 모듈과의 연관도 또는 모듈 간의 상호의존성이다.
  ㄴ 소프트웨어 구조에서 모듈 간의 관련성을 측정하는 척도이다.

234. 결합도 순서: 내공 외제 스자
  ㄴ 내용(Content): 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도
  ㄴ 공통(Common): 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도
  ㄴ 외부(External): 두 개의 모듈이 외부에서 도입된 데이터 포맷, 통신 프로토콜, 또는 디바이스 인터페이스를 공유할 경우의 결합도
  ㄴ 제어(Control): 단순 처리할 대상인 값만 전달 되는 게 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달되는 경우의 결합도
  ㄴ 스탬프(Stamp): 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우의 결합도
  ㄴ 자료(Data): 모듈 간의 인터페이스로 전다로디는 파라미터를 통해서만 모듈 간의 상호 작용이 일어나는 경우의 결합도

235. MVC(Model View Controller Pattern)패턴
  ㄴ 모델: 애플리케이션이 무엇을 할 것인지 정의, 내부 비즈니스 로직을 처리하기 위한 역할
  ㄴ 뷰: 화면에 무엇인가를 보여주기 위한 역할, 모델, 컨트롤러가 보여주려고 하는 것들을 화면에 처리
  ㄴ 컨트롤러: 모델이 어떻게 처리할지를 알려주는 역할, 뷰에 명령을 보내어 화면 요청 결과를 전달

236. 팬인(Fan-In) 및 팬아웃(Fan-Out)
  ㄴ팬인과 팬아웃 분석을 통하여 시스테의 복잡도를 측정할 수 있다.
  ㄴ 소프트웨어의 구성요소인 모듈을 계층적으로 분석하기 위해서 팬인 팬아웃을 활용

237. 팬인
  ㄴ 개념: 어떤 모듈을 제어(호출)하는 모듈의 수
  ㄴ 모듈 숫자 계산: 모듈 자신을 기준으로 모듈에 들어오면 팬인
  ㄴ 고려사항: 팬인이 높으면 재사용 측면에서 설계가 잘되었지만, 단일 장애점 발생 가능, 팬인이 높으면 관리 비용 및 테스트 비용 증가

238. 팬아웃
  ㄴ 개념: 어떤 모듈에 의해 제어(호출)되는 모듈의 수
  ㄴ 모듈 자신을 기준으로 모듈에서 나가면 팬아웃
  ㄴ 팬아웃이 높을 경우는 불필요한 모듈 호출 여부 검토 필요, 팬아웃이 높을 경우는 단순화 여부 검토 필요

239. 서버 프로그램 구현: 업무 푸로세스를 기반으로 개발언어와 도구를 이용해 서버에서 서비스 제공에 필요한 기능을 구현하는 활동이다.

240. 서버 프로그램 세부 구현 프로세스: 디스 다써클
 DTO/VO -> SQL -> DAO -> Service -> Controller

DTO(Data Transfer Object): 프로세스 사이에서 데이터를 전송하는 객체로 데이터 저장, 회수 외에 다른 기능이 없는 객체이다.
VO(Value Object): 간단한 엔티티를 의미하는 작은 객체 가변 클래스인 DTO와 달리 고정 클래스를 가지는 객체이다
DAO(DataAccess Object): 특정 타입의 데이터베이스에 추상 인터페이스를 제공하는 객체로 세부내용 노출 없이 데이터를 조작하는 객체이다.
Service: 사용자의 요청을 처리하는 기능을 제공하기 위한 로직을 구현하고 DAO 클래스를 통해 DB연동을 처리하는 기능을 수행하는 클래스이다.

241. 배치 프로그램(Batch Program) 개념
  ㄴ 배치 프로그램은 사용자와의 상호작용 없이 일련의 작업들을 작업 단위로 묶어 정기적으로 반복 수행하거나 정해진 규칙에 따라 일괄 처리하는 방법이다.

242. 배치 프로그램 유형: 이온정
  ㄴ 이벤트 배치: 사전에 정의해 둔 조건 충족 시 자동으로 실행
  ㄴ 온디맨드 배치: 사용자의 명시적 요구가 있을 때 마다 실행
  ㄴ 정기 배치: 정해진 시점(주로 야간)에 정기적으로 실행

243. 배치 스케쥴러(Scheduler)의 개념
  ㄴ 배치 스케쥴러는 일괄 처리(Batch Processing)를 위해 주기적으로 발생하거나 반복적으로 발생하는 작업을 지원하는 도구이다.

244. 배치 스케줄러 종류
  ㄴ 스프링 배치: 스프링 프레임워크의 DI, AOP, 서비스 추상화 등 스프링 프레임워크의 3대 요소를 모두 사용할 수 있는 대용량 처리를 제공하는 스케줄러 배치 애플리케이션
  ㄴ 쿼츠 스케줄러: 스프링 프레임워크에 플러그인되어 수행하는 작업과 실행 스케줄을 정의하는 트리거를 분리하여 유연성을 제공하는 오픈 소스 기반 스케줄러

245. 크론(Cron) 표현식: 스케줄러를 실행시키기 위해 작업이 실행되는 시간 및 주기 등을 설정하게 되는데 크론 표현식을 통해 배치 수행시간 설정
  ㄴ 크게 리눅스/유닉스와 쿼츠로 구분(세부사항 책 참고)
  ㄴ 리눅스/유닉스 표현식: 분시일월요연
  ㄴ 쿼츠 크론 표현식: 초분시일 월요연

246. Cron 표현식 특수 문자 의미
  *: 모든 수
  ?: 해당 항목을 미사용
  -: 기간설정
  ,: 특정기간 설정
  /: 시작시간과 반복간격 설정
  L: 마지막 기간에 동작
  W: 가장 가까운 평일에 동작
  #: 몇 번째 주, 요일 설정

247. SW 개발 보안의 개념
  ㄴ 소스 코드 등에 존재하는 보안 취약점을 제거하고, 보안을 고려하여 기능을 설계 및 구현하는 등 소프트웨어 개발 과정에서 지켜야할 일련의 보안 활동을 말한다.

248. SW 보안의 3대 요소: 기무가
  ㄴ 기밀성(Confidentiality): 인가되지 않은 개인 혹은 시스템 접근에 따른 정보 공개 및 노출을 차단하는 특성
  ㄴ 무결성(Integrity): 정당한 방법을 따르지 않고서는 데이터가 변경될 수 없으며, 데이터의 정확성 및 완전성과 고의/악의로 변경되거나 훼손 또는 파괴되지 않음을 보장하는 특성
  ㄴ 가용성(Availability): 권한을 가진 사용자나 애플리케이션이 원하는 서비스를 지속해서 사용할 수 있도록 보장하는 특성

249. SW 개발 보안 용어: 자위취위
  ㄴ 자산(Assets), 위협(Threat), 취약점(Vulnerability), 위험(Risk)

250. DoS(Denial of Service) 공격 개념
  ㄴ 시스템을 악의적으로 공격해서 해당 시스템의 자원을 부족하게 하여 원래 의도된 용도로 사용하지 못하게 하는 공격
  ㄴ 특정 서버에게 수많은 접속 시도를 만들어 다른 이용자가 정상적으로 서비스 이용을 하지 못하게 하거나, 서버의 TCP 연결을 소진 시키는 등의 공격이다.

251. DoS 공격의 종류
  ㄴ SYN Flooding: TCP 프로토콜의 구조적 문제를 이용한 공격, 서버의 동시 가용 사용자 수를 SYN 패킷만 보내 점유하여 다른 사용자가 서버를 사용 불가능하게 하는 공격
		        공격자는 ACK를 발송하지 않고 계속 새로운 연결 요청을 하게 되어 서버는 자원할당을 해지하지 않고 자원만 소비하여 고갈됨
  ㄴ UDP Flooding: 대량의 UDP 패킷을 만들어 임의의 포트 번호로 전송하여 응답 메시지(ICMP Destination Unreachable)를 생성하게 하여 지속해서 자원을 고갈시키는 공격
		         ICMP 변조되어 공격자에게 전달되지 않아 대기함
  ㄴ Smurf/Smurfing: 출발지 주소를 공격 대상의 IP로 설정하여 네트워크 전체에게 ICMP Echo 패킷을 직접 브로드캐스팅 하여 마비시키는 공격
			 바운스 사이트라고 불리는 제3의 사이트를 이용해 공격
  ㄴ 죽음의 핑(PoD; Ping of Death): ICMP 패킷(Ping)을 정상적인 크기보다 아주 크게 만들어 전송하면 다수의 IP 단편화가 발생하고, 수신 측에서는 단편화된 패킷을 처리(재조합)하는 과정에서 많은 부하가 발생하거나, 재조합 버퍼의 오버플로우가 발생하여 정상적인 서비스를 하지 못하도록 공격하는 기법
  ㄴ Land Attack: 출발지(Source) IP와 목적지(Destination) IP를 같은 패킷 주소로 만들어 보냄으로써 수신자가 자기 자신에게 응답을 보내게 하여 시스템의 가용성을 침해하는 공격기법
  ㄴ Tear Drop: IP 패킷의 재조합 과정에서 잘못된 Fragment Offset 정보로 인해 수신 시스템이 문제를 발생하도록 만드는 공격
		  공격자는 IP Fragment Offset 값을 서로 중첩되도록 조작하여 전송하고, 이를 수신한 시스템이 재조합하는 과정에서 오류가 발생, 시스템의 기능을 마비시키는 공격방식
  ㄴ Bonk/Boink: 프로토콜의 오류 제어를 이용한 공격기법으로서 시스템의 패킷 재전송과 재조립이 과부하를 유발

252. DDoS(Distributed Dos) 공격 개념
  ㄴ DoS의 또 다른 형태로 여러 대의 공격자를 분산 배치하여 동시에 동작하게 함으로써 특정 사이트를 공격하는 기법
  ㄴ 해커들이 취약한 인터넷 시스템에 대한 액세스가 이뤄지면, 침입한 시스템에 소프트웨어를 설치하고 이를 실행시켜 원격에서 공격을 개시한다.

253. DDoS 공격 구성요소: HAMAD
  ㄴ Handler: 마스터 시스템의 역할을 수행하는 프로그램
  ㄴ Agent: 공격 대상에 직접 공격을 가하는 시스템
  ㄴ Master: 공격자에게서 직접 명령을 받는 시스템, 여러 대의 에이전트를 관리하는 역할
  ㄴ Attacker: 공격을 주도하는 해커의 컴퓨터
  ㄴ Daemon: 에이전트 시스템의 역할을 수행하는 프로그램

254. DDoS 공격도구
  ㄴ Trinoo: 많은 소스로부터 통합된 UDP flood 서비스 거부 공격을 유발하는 데 사용되는 도구, Trinoo 공격은 몇 개의 서버들과 많은 수의 클라이언트들로 이루어짐
  ㄴ Tribe Flood Network: TFN은 Trinoo와 거의 유사한 분산 도구로 많은 소스에서 하나 혹은 여러개의 목표 시스템에 대해 서비스 거부 공격을 할 수 있는 도구, TFN 서비스 거부 공격은 공격자가 클라이언트 프로그램을 통해 공격 명령을 일련의 TFN 서버들에게 보냄으로써 이루어짐
  ㄴ Stacheldrant: 분산 서비스 거부 에이전트 역할을 하는 Linux 및 Solaris 시스템용 멀웨어 도구

255. DRDoS(Distributed Reflection DoS) 공격의 개념
  ㄴ 공격자는 출발지 IP를 공격대상 IP로 위조하여 다수의 반사 서버로 요청 정보를 전송, 공격 대상자는 반사 서버로부터 다량의 응답을 받아서 서비스 거부가 되는 공격

256. DDoS와 DRDoS의 차이점: DRDoS는 DDoS에 비해 공격 근원지 파악이 어렵고, 공격 트래픽 생성 효율이 훨씬 크다.

257. 애플리케이션 공격(DDoS 서비스 마비 공격)
  ㄴ HTTP GET Flooding: Cache Control Attack 공격, 과도한 Get 메시지를 이용하여 웹 서버의 과부하를 유발시키는 공격, HTTP 캐시 옵션을 조작하여 캐싱 서버가 아닌 웹 서버가 직접 처리하도록 유도, 웹 서버 자원을 소진시키는 서비스 거부 공격
  ㄴ Slowloris: HTTP GET 메서드를 사용하여 헤더의 최종 끝을 알리는 개행 문자열인 \r\n\r\n 을 전송하지 않고 \r\n만 전송하여 대상 웹 서버와 연결상태를 장시간 지속시키고 연결 자원을 모두 소진시키는 서비스 거부 공격
  ㄴ RUDY: 요청 헤더의 Content-Length를 비정상적으로 크게 설정하여 메시지 바디 부분을 매우 소량으로 보내 계속 연결상태를 유지시키는 공격
  ㄴ Slow HTTP Read DoS: TCP 윈도 크기가 데이터 처리율을 감소시킨 상태에서 다수 HTTP 패킷을 지속적으로 전송하여 대상 웹 서버의 연결상태가 장시간 지속, 연결자원을 소진시키는 서비스 거부 공격
  ㄴ Hulk Dos: 공격자가 공격대상 웹 사이트 주소를 지속적으로 변경하면서 다량으로 GET요청을 발생시키는 서비스 거부 공격, 주소를 지속적으로 변경시키는 이유는 임계치 기반의 디도스 대응 장비를 우회하기 위한 방법
  ㄴ Hash Dos: 웹 서버는 클라이언트 HTTP 요청을 통해 전달되는 파라미터를 효율적으로 저장하고 검색하기 위한 자료 구조로 해시테이블을 주로 사용, 공격자는 이러한 특성을 악용하여 조작된 수 많은 파라미터를 POST방식으로 웹 서버로 전달하여 다수의 해시 충돌(Collision)을 발생시켜서 자원을 소모시키는 서비스 거부 공격

258. 네트워크 공격
  ㄴ Sniffing: 공격대상에게 직접 공격하지 않고 데이터만 몰래 들여다보는 수동적 공격
  ㄴ Network Scanner, Sniffer: 네트워크 하드웨어 및 소프트웨어 구성의 취약점 파악을 위해 공격자가 취약점을 탐색하는 공격도구
  ㄴ Passwork Cracking: Dictionary Cracking(패스워드가 될 가능성 있는 단어를 파일로 만들어서 대입해서 공격), Brute Force Cracking(무작위로 패스워드 대입), Password Hybrid Attack(딕셔너리 + 브루트 포스), Rainbow Table Attack(해시 값을 미리 생성해서 테이블에 모아놓고 공격하고자 하는 해시 값을 테이블에서 검색해서 역으로 패스워드 찾는 기법)
  ㄴ IP Spoofing: 침입자가 인증된 컴퓨터 시스템인 것처럼 속여서 타깃 시스템의 정보를 빼내기 위해서 본인의 패킷 해더를 인증된 호스트의 IP 어드레스로 위조하여 타깃에 전송하는 공격기법
  ㄴ ARP Spoofing: ARP Spoofing은 공격자가 특정 호스트의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Reply를 만들어 희생자에게 지속적으로 전송하여 희생자의 ARP Cache Table에 특정 호스트의 MAC 정보를 공격자의 MAC 정보로 변경, 희생자로부터 특정 호스트로 나가는 패킷을 공격자가 스니핑하는 공격
  ㄴ ICMP Redirect: 3계층에서 스니핑 시스템을 네트워크에 존재하는 또 다른 라우터라고 알림으로써 패킷의 흐름을 바꾸는 공격기법, ICMP Redirect 메시지를 공격자가 원하는 형태로 만들어서 특정 목적지로 가는 패킷을 공격자가 스니핑
  ㄴ Trojan horses(트로이 목마): 악성 루틴이 숨어 있는 프로그램으로 겉보기에는 정상적인 프로그램으로 보이지만 실행하면 악성 코드를 실행하는 프로그램

259. Buffer Overflow
  ㄴ 메모리에 할당된 버퍼 크기를 초과하는 양의 데이터를 입력하여 이로 인해 프로세스 흐름을 변경시켜 악성 코드 실행
  ㄴ 스택 버퍼 오버플로우: 메모리 영역 중 Local Value나 함수의 Return Address가 저장되는 스택 영역에서 발생, 스택 영역에 할당 된 버퍼 크기를 초과하는 양의 데이터를 입력하여 복귀 주소를 변경하고 임의의 코드를 실행
  ㄴ 힙 버퍼 오버플로우: 프로그램 실행 시 동적으로 할당되는 힙 영역에 할당된 버퍼 크기를 초과하는 데이터를 입력하여 메모리의 데이터와 함수 주소 등을 변경, 공격자가 원하는 임의의 코드 실행, 인접한 메모리의 데이터가 삭제될 수 있고 해당 위치에 특정 함수에 대한 포인터 주소가 있으면 이를 악용하여 관리자 권한 파일에 접근하거나 특정 코드를 실행함

260. 버퍼 오버플로우 대응방안
  ㄴ 스택가드 활용: 카나리라고 불리는 무결성 체크용 값을 복귀 주소와 변수 사이에 삽입해두고, 버퍼 오버플로우 발생 시 카나리 값을 체크, 변할경우 복귀 주소 호출 하지 않음
  ㄴ 스택쉴드: 함수 시작시 복귀 주소를 Global RET이라는 특수 스택에 저장하고, 함수 종료시 저장값과 RET비교하여 다를경우 오버플로우로 간주ㅡ
  ㄴ ASLR(Address Space Layout Randomization): 메모리 공격을 방어하기 위해 주소 공간 배치를 난수화하고, 실행 시 마다 메모리 주소를 변경시켜 오버플로우 공격 차단
  ㄴ 안전한 함수 활용
  ㄴ 실행 제한

261. 백도어(Backdoor)
  ㄴ 어떤 제품이나 컴퓨터 시스템, 암호시스템 혹은 알고리즘에서 정상적인 인증 절차를 우회하는 기법이다.
  ㄴ 우리말 뒷문이라는 단어의 어감에서 알 수 있듯이 허가 받지 않고 시스템에 접속하는 권리를 얻기 때문에 대부분 은밀하게 작동한다. 
  ㄴ 백도어는 어떤 고정적인 형태가 있는 것은 아니라 프로그램 일부로 감춰져 있을 수도 있고 독자적인 프로그램이나 하드웨어 모습을 갖기도 한다. 
  ㄴ 해커는 백도어를 통해서 이용자 몰래 컴퓨터에 접속하여 악의적인 행위를 하기도 한다.

262. 주요 시스템 보안 공격기법
  ㄴ 포맷 스트링 공격(Format String Attack): 포맷 스트링을 인자로 하는 함수의 취약점을 이용한 공격으로 외부로부터 입력된 값을 검증하지 않고 입출력 함수의 포맷 스트링을 그대로 사용하는 경우 발생하는 취약점 공격기법, printf(argv[1]) 등 포맷 스트링을 인자로 사용 시 포맷 스트링을 지정하지 않고 사용자 입력값을 통해 스트링이 지정된다면 공격자는 이를 조작하여 메모리 내용을 참조하거나 특정 영역 값 변경 가능
  ㄴ 레이스 컨디션 공격(Race Condition Attack): 둘 이상의 프로세스나 스레드가 공유자원을 동시에 접근할 때 접근 순서에 따라 비정상저긴 결과가 발생하는 조건/상황, 실행되는 프로세스가 임시파일을 만드는 경우 악의적인 프로그램을 통해 그 프로세스의 실행 중에 끼어들어 임시파일을 심볼릭 링크하여 악의적인 행위를 수행하게 하는 공격기법
  ㄴ 키로거 공격(Key Logger Attack): 사용자 키보드 움직임을 탐지해서 저장하고, ID나 패스워드, 계좌번호, 카드번호와 같은 개인 정보를 빼가는 해킹 공격, 
  ㄴ 루트킷(Rootkit): 시스템 침입 후 침입 사실을 숨긴 채 차후의 침입을 위한 백도어, 트로이 목마 설치, 원격 접근, 내부 사용 흔적 삭제, 관리자 권환 획득 등 주로 불법적인 해킹에 사용되는 기능을 제공하는 프로그램의 모음










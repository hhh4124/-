정보처리기사 중요부분 요약


1. 소프트웨어 생명주기 모델(SDLC: Software Development Life Cycle)
  ㄴ 소프트웨어 생명주기는 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차.
  
 가. 소프트웨어 생명주기 모델 프로세스
  ㅇ 요설구테유
    - 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 

 나. 소프트웨어 생명주기 모델 종류
   ㅇ 폭프나반: 폭포수 모델, 프로토타이핑 모델, 나선형 모델, 반복적 모델
     1) 폭포수 모델
      - 폭포수 모델은 가장 오래된 모델이자 순차적 모형, 성공 사례가 많고 산출물이 명확하지만 요구사항 변경이 어려움 
      - 절차: 타당성 검토 -> 계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수
  
     2) 나선형 모델
      - 시스템 개발 시 위험을 최소화 하기 위해 점진적으로 완벽한 시스템으로 개발해나가는 모델
      - 절차: 계획 및 정의 -> 위험 분석 -> 개발 -> 고객 평가
  
     3) 프로토 타이핑 모델 
      - 고객이 요구한 주요 기능을 프로토타입으로 구현하여, 고객의 피드백을 반영하여 소프트웨어를 만들어가는 모델
      - 프로토 타입은 발주자나 개발자 모두에게 공동의 참조모델 제공
   
     4) 반복적 모델
      - 구축 대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적을 개발하여 점증 완성시키는 모델

 다. 소프트웨어 개발 방법론
  ㄴ 소프트웨어 개발 방법론은 소프트웨어 개발 전 과정에 지속적으로 적용할 수 있는 방법, 절차, 기법이다.
    SW를 하나의 생명체로 간주하고 개발의 시작부터 시스템을 사용하지 않는 과정까지의 전 과정 형상화
  
   ㅇ 소프트웨어 개발 방법론 종류
     - 구정객컴애제: 구조적, 정보공학, 객체지향, 컴포넌트 기반, 애자일, 제품 계열 방법론
   가. 구조적 방법론
     - 전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 분할과 정복  접근 방식의 방법론
     - 프로세스 중심의 하향식 방법론
     - 나씨-슈나이더만 차트 사용(논리의 기술에 중점을 둔 도형식 표현 방법, 연속, 선택 및 다중선택, 반복 등의 제어 논리 구조로 표현, 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합)
   나. 정보공학 방법론
     - 정보시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
     - 개발 주기를 이용해 대형 프로젝트를 수행하는 체계적인 방법론
   다. 객체지향 방법론
     - 객체라는 기본 단위로 시스템을 분석 및 설계하는 방법론
     - 복잡한 현실 세계를 사람이 이해하는 방식으로 시스템에 적용, 객체, 클래스, 메시지 사용ㅓㅓ
   라. 컴포넌트 기반 방법론
     - 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
     - 개발 기간 단축으로 생산성 향상, 새로운 기능 추가 쉬움, 소프트웨어 재사용 가능
   마. 애자일 방법론
     - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론
     - 애자일은 개발 과정의 어려움을 극복하기 위해 적극적으로 모색한 방법론
   바. 제품 계열 방법론
     - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
     - 임베디드 소프트웨어를 작성하는 데 유용한 방법론
     
  ㅁ 애자일 방법론의 개념
   ㅇ 애자일 방법론은 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발 방법론이다.
   ㅇ 개발기간이 짧고 신속하며, 폭포수 모형에 대비되는 방법론으로 개발과 함께 즉시 피드백을 받아서 유동적으로 개발할 수 있다. 
   
   ㅇ 애자일 방법론은 대표적으로 XP, 린(Learn), 스크럼(SCRUM) 등이 있다.
   ㅇ XP(extrema Programming)
    - XP의 5가지 가치: 용단의피존(용기, 단순성, 의사소통, 피드백, 존중)
    - XP 12가지 기본원리: 짝 프로그래밍, 공동 코드 소유, 지속적인 통합, 계획 세우기, 작은 릴리즈, 메타포어, 간단한 디자인, 테스트 기반 개발, 리팩토링, 40시간 작업, 고객 상주, 코드 표준
   ㅇ 스크럼
    - 백로그, 스프린트, 스크럼 미팅, 스크럼 마스터, 스프린트 회고, 번 다운 차트
   ㅇ 린
    - 도요타의 린 시스템 품질 기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론
    - JIT, 칸반 보드 사용
    - 7가지 원칙: 낭품지늦빠사전 - 낭비제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화

2. 비용산정 모형
  ㄴ 비용산정 모형은 소프트웨어 규모파악을 통한 투입자원, 소요시간을 파악하여 실행 가능한 계획을 수립하기 위해 비용을 산정하는 방식이다.
  ㄴ 하향식 산정방법, 상향식 산정방법이 있다.
  ㄴ 하향식 산정 방법에는 델파이 기법, 전문가 판단이 있다.
  
  ㄴ 상향식 산정방법에는 코드라인 수(Loc), Man Month COCOMO 푸트남 기능점수(FP)모형이 있따.

  가. Loc(Lines of Code) 모형: 소프트웨어 각 기능의 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구하여 비용을 산정하는 방식, 측정이 쉽고 이해하기 쉬워 많이 사용된다.
  낙관치 + 4중간치 + 비관치 / 6

  나. Moan Month 모형은 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 프로젝트 비용을 산정하는 방식
     MM = Loc/월간 생산성, 프로젝트 기간 = MM/프로젝트 인력
  다. COCOMO 모형: 보헴이 제안한 ㅁ형으로 프로그램 규모에 따라 비용을 산정하는 방식. 비용산정 결과는 Man Month로 산정
     규모에 따라 조직형, 반분리형, 임베디드형으로 나뉜다.(Organic, Semi-Detached, Embedded)
  라. 푸트남 모형: 소프트웨어 개발주기의 단계별로 요구할 인력의 분포를 가정하는 방식, 푸트남이 제안한 것으로 생명주기 예측 모형이라고 한다. Rayleigh-Norden 곡선의 노력 분포도를 기준으로 한다.
  마. 기능점수(Function Point) 모형: 요구 기능을 증가시키는 인자별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능점수 계산하여 비용을 산정하는 방식 경험을 바탕으로 단순, 보통, 복잡에 따라 가중치 부여
  
3. 일정관리 모델
주 공정법, PERT, 중요 연쇄 프로젝트 관리가 있다.
CPM 일정계산 - 가장 긴 경로 계싼
PERT - 비관치, 중간치, 낙관치의 3점 추정방식을 통해 일정을 관리하는 기법
CCPM - CPM으로 자원제약사항을 고려하여 일정을 작성

4. 소프트웨어 아키텍쳐
 ㄴ 소프트웨어 아키텍처는 여러가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체이다.
 ㄴ 소프트웨어 아키텍쳐 프레임워크: 소프트웨어 집약적인 시스템에서 아키텍처가 표현해야하는 내용 및 이들 간의 관계를 제공하는 아키텍처 기술 표준이다.
 ㄴ 소프트웨어 아키텍처 구성요소: 아키텍처 명세서, 이해관계자, 관심사, 관점, 뷰, 근거, 목표, 환경, 시스템

5. 소프트웨어 아키텍처 4+1뷰
 ㄴ 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법
 ㄴ 4개의 분리된 구조로 구성되는 아키텍처 개념을 제시하고, 서로 충돌되거나 요구사항 충족을 증명하기 위해 유스케이스를 사용
 ㄴ 구성요소: 유논프구배(유스케이스뷰, 논리뷰, 프로세스뷰, 구현뷰, 배포뷰)

6. 소프트웨어 아키텍처 패턴
 ㄴ 소프트웨어를 설계할 때 참조할 수 있는 전형적인 해결 방식.
 ㄴ 일반화되고 재사용 가능한 솔루션
 ㄴ 패턴유형: 계층화 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 브로커 패턴, 모델-뷰-컨트롤러 패턴(MVC)

7. 소프트웨어 아키텍처 비용 평가 모델
 ㄴ SAAM, ATAM, CBAM, ADR, ARID

8. 디자인 패턴
 ㄴ 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴
 ㄴ 개발 효율성, 유지보수성, 운용성, 프로그램 최적화
 ㄴ 구성요소: 패문솔 사결샘(패턴의 이름, 문제 및 배경, 솔루션, 사례, 결과, 샘플코드)

9. 디자인 패턴 유형
 목적 - 생성, 구조, 행위 / 범위 - 클래스, 객체

10. 디자인 패턴 종류
 생성 - Builder, Prototype, Factory Method, Abstract Factory, Singleton
 구조 - Bridge, Decorator, Facade, Flyweight, Proxy, Composite, Adapter
 행위 - Mediator, Interpreter, Iterator, Template Method, Observer, State, Visitor, Command, Strategy, Memento, Chain of Responsibility

11. 현행 시스템 분석서 작성 및 검토
 ㄴ 분석 산출물의 종류: 현기인 아소하네(정보시스템 구성 현황, 정보 시스템 기능 구성도, 인터페이스 현황, 현행 시스템 아키텍처 구성도, 소프트웨어 구성도, 하드웨어 구성도, 네트워크 구성도)
 ㄴ 각 구성도의 사례 확인

12. 운영체제 개념: 컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있도록 해주고, 사용자와 하드웨어간 인터페이스 담당
 ㄴ 현행 시스템 분석
   품질측면 - 신뢰도, 성능
   지원측면 - 기술지원, 주변기기, 구축비용

13. 운영체제 종류 및 특징
 ㄴ PC - 윈도우, 유닉스, 리눅스 / 모바일 - 안드로이드, iOS

14. 네트워크 현행 시스템 분석
 ㄴ 네트워크 개념: 컴퓨터 장치들의 노드 간 연결(데이터 링크)을 사용하여 서로에게 데이터를 교환할 수 있도록 하는 기술
 OSI 7계층: 네트워크 통신에서 생긴 여러가지 충돌 문제를 완화하기 위해 국제 표준화 기구(ISO)에서 제시한 네트워크 기본 모델

 OSI 7계층 구성요소: Application, Presentation, Session, Transport, Network, Data Link, Physical
 
 네트워크 현행 시스템 분석: 네트워크 구조를 구성도를 통해 분석
 백본망, 라우터, 스위치, 게이트웨이, 방화벽 등을 대상으로 분석

15 DBMS 형행 시스템 분석
 - 가성호기구(성능 측면 - 가용성, 성능, 상호 호환성 / 지원 측면 - 기술 지원, 구축 비용)

16. 미들웨어 현행 시스템 분석: 가성기구(성능 측면: 가용성, 성능 / 지원 측면 - 기술 지원, 구축 비용)


17. 요구사항 확인
 - 요구공학: 사용자의 요구가 반영된 시스템을 개발하기 위하여 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동
 - 요구공학의 목적: 이해관계자 사이 효과적인 의사소통 수단 제공, 공통된 이해 설정, 요구사항 누락 방지 및 이해 오류로 인한 불필요한 비용 절감, 요구사항 변경 추적, 개발 비용 시간 절약
 - 요구사항의 분류: 기능적 요구사항(특성: 기완일 - 기능성, 완전성, 일관성) / 비기능적 요구사항(신사효유이보품제 - 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성, 품질 관련 요구사항, 제약사항)
 
18. 요구공학 프로세스: 도분명확(도출, 분석, 명세, 확인)

19. 요구사항 도출단계: 소프트웨어가 해결해야할 문제를 이해하고, 고갱르ㅗ 부터 제시되는 추상적 요구에 대해 관련 정보를 식별하고 수집방법 결정, 요구사항 구체적으로 표현하는 단계
 주요기법: 인터뷰, 브레인스토밍, 델파이, 롤 플레잉, 워크숍, 설문조사

20 요구사항 분석 단계: 요구사항 분석 단계는 추출된 요구사항에 대해 충돌, 중복, 누락 등의 분석을 통해 완전성과 일관성을 확보하는 단계
 분석 단계 절차: 요구사항 분류 -> 개념 모델링 생성 및 분석 -> 요구사항 할당 -> 요구사항 협상 -> 정형분석
 분석 단계 기법: 자료 흐름 지향 분석, 객체 지향 분석
 분석기술: 청취, 인터뷰와 질문, 분석, 중재, 관찰, 작성, 조직, 모델 작성

21. 요구사항 명세 단계: 체계적으로 검토, 평가, 승인될 수 있는 문서를 작성
 주요기법: 비정형 명세 기법, 정형 명세 기법
 산출물: 요구사항 명세서
 명세 원리 및 검증 항목: 명완검일수추개(명확성, 완전성, 검증 가능성, 일관성, 수정 용이성, 추적 가능성, 개발 후 이용성)

22. 요구사항 확인 및 검증 단계: 사용자의 요구가 올바르게 기술 되었는지에 대한 검토 / 요구사항을 이해했는지 확인(Validation)하고 욕사항 문서가 회사 표준에 적합한지, 일관성을 만족하는지, 완전한지 검증(Verification) 해야한다.

 ㄴ 요구사항 확인 및 검증 절차: 요구사항 목록 확인, 정의서 작성 여부 확인, 비기능적 요구사항 확인, 타 시스템 연계 및 인터페이스 요구사항 확인
 ㄴ 요구사항 확인 및 검증 단계의 주요기법 및 산출물: 
   - 요구사항 검토, 정형 기술 검토 활용(동료 검토, 워크스루, 인스펙션), 프로토 타이핑 활용, 모델 검증, 테스트 케이스 및 테스트를 통한 확인, CASE 도구 활용 검증, 베이스라인을 통한 검증, 요구사항 추적표

 - 상세 정형 기술 검토 기법: 관리 리뷰, 기술 리뷰, 인스펙션, 워크 스루, 감사

23. 요구사항 관리 단계: 프로젝트 진행 과정에서 발생하는 요구사항의 변경에 대해 일치성과 무결성을 제공하기 위해 변경제어와 추적 등 일련의 관리를 수행하는 활동
 주요산출물: 요구사항 변경요청서, 변경 승인서, 추적표

 - 요구사항 관리 단계 절차: 협기변확(요구사항 협상 -> 요구사항 기준선 설정 -> 요구사항 변경관리 -> 요구사항 확인 및 검증)

24. 분석모델 검증: 요구사항 도출 기법을 활용하여 업무 분석가가 제시한 분석 모델에 대해서 확인하는 활동
 ㄴ 분석모델 검증 방법: 유스케이스 모델 검증, 개념 수준의 분석 클래스 검증, 분석 클래스 검증


25. UI 요구사항 확인
 UI(User Interface) - 사용자와 시스템 사이에서 의사소통할 수 있도록 고안된 물리적, 가상의 매개체이다. 정보기기나 소프트웨어의 화면 등에서 사람이 접하게 되는 화면
 UX(User eXperience) - 제품과 시스템, 서비스 드응ㄹ 사용자가 직/간접적으로 경험하면서 느끼고 생각하는 총체적 경험

26. UI 유형: CLI, GUI, NUI, OUI
 CLI - 정적인 텍스트 기반, GUI - 그래픽 반응 기반, NUI - 직관적 사용자 반응 기반, OUI - 유기적 상호작용 기반
27. UI 설계원칙: 직유학유(직관성, 유효성, 학습성, 유연성)

28. UI 설계지침: 사일단결 가표접명오(사용자 중심, 일관성, 단순성, 결과 예측 가능, 가시성, 표준화, 접근성, 명확성, 오류 발생 해결)

29. UI 품질 요구사항: 기신사효유이(기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성)
 
30. UI 표준: 디자인 철학과 원칙 기반 하에 전체 시스템에 공통으로 적용되는 화면 간 이동, 화면구성 등에 관한 규약
 ㄴ UI 표준 구성: 액정스패조(전체적인 UX원칙, 정책 및 철학, UI 스타일 가이드, uI 패턴 모델 정의, UI표준 수립을 위한 조직 구성
 ㄴ CRUD 방식: 대부분의 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create, Read, Update, Delete를 묶어서 이르는 말

31. UI 개발을 위한 주요 기법: 3C 분석, SWOT 분석, 시나리오 플래닝, 사용성 테스트, 워크숍

32. 사용자 요구사항 도출: 페르소나 정의, 콘셉트 모델 정의, 사용자 요구사항 정의, UI컨셉션

33. 스토리보드 개념: UI 화면 설계를 위해서 정책이나 프로세스 및 콘텐츠의 구성, 와이어 프레임(UI, UX), 기능에 대한 정의, 데이터 베이스의 연동 등 구축하는 서비스를 위한 대부분 정보가 수록된 문서, 디자이너와 개발자가 최종적으로 참고하는 산출 문서

34. UI 화면설계 구분: 와스프(와이어 프레임, 스토리보드, 프로토타입)
 ㄴ 와이어 프레임: 이해 관계자들과의 화면구성을 협의하거나 서비스의 간략한 흐름을 공유하기 위해 화면 단위의 레이아웃을 설계하는 작업
 ㄴ 스토리보드: 정책, 프로세스, 콘텐츠 구성, 와이어 프레임, 기능 정의, 데이터베이스 연동 등 서비스 구축을 위한 모든 정보가 담겨 있는 설계 산출물
 ㄴ 프로토타입: 정적인 화면으로 설계된 와이어 프레임 또는 스토리보드에 동적 효과를 적용하여 실제 구현된 것처럼 시뮬레이션 할 수 있는 모형

35. UI 설계를 위한 UML
 ㄴ UML 개념: 객체지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화 할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어
 ㄴ UML 특징: 가구명문(가시화 언어, 구축 언어, 명세화 언어, 문서화 언어)
 ㄴ 가시화 언어: 개념 모델 작성 시 오류가 적고 의사소통 용이
 ㄴ 구축 언어: 다양한 프로그래밍 언어로 실행 시스템의 예측 가능, UML을 소스 코드로 변환하여 구축 가능, 역 변환하여 역공학 가능
 ㄴ 명세화 언어: 정확한 모델 제시, 완전한 모델 작성 가능
 ㄴ 문서화 언어: 시스템에 대한 평가 및 의사소통의 문서

36. UML 구성요소: 사관다(사물 관계 다이어그램)
 ㄴ 사물: 추상적인 개념으로, 주제를 나타내는 요소, 단어 관점에서 '명사'또는 '동사'를 의미
 ㄴ 관계: 사물의 의미를 확장하고 명확히 하는 요소, 사물과 사물을 연결하여 관계를 표현하는 요소, 단어 관점에서 '형용사'또는 '부사'를 의미
 ㄴ 다이어그램: 사물과 관계를 모아 그림으로 표현한 형태, 형식과 목적에 따라 9가지로 정의

37. UML 다이어그램: 구분에 따라 구조적(정적) 다이어그램과 행위적(동적) 다이어그램으로 구분된다.
 ㄴ 구조적(정적) 다이어그램: 클객 컴배 복패(클래스, 객체, 컴포넌트, 배치, 복합체 구조, 패키지)
 ㄴ 행위적(동적) 다이어그램: 유시커 상활타(유스케이스, 시퀀스, 커뮤니케이션, 상태, 활동, 타이밍)

38. UML 확장 모델의 스테레오 타입: UML 기본 요소 이외의 새로운 요소를 만들어내기 위한 확장 메커니즘, 형태는 기존 UML 요소를 그대로 사용하지만 내부 의미는 다른목적으로 사용, <<>>길러멧 기호를 사용하여 표현한다.

39. 클래스 다이어그램: 객체지향 모델링 시 클래스의 속성 및 연산과 클래스 간 정적인 관계를 표현한 다이어그램
 ㄴ 구성요소: 클래스, 속성, 연산, 접근제어자(-, +, #, ~)
 ㄴ 클래스 간의 관계: 연집복 일의실(연관 집합 복합 일반화 의존 실체화)


40. 유스케이스 다이어그램: 시스템이 제공하고 있는 기능 및 그와 관련된 외부 요소를 사용자의 관점에서 표현하는 다이어그램
 ㄴ 구성요소: 유스케이스, 액터, 시스템, 시나리오, 이벤트의 흐름
 ㄴ 유스케이스 다이어그램의 관계: 포함관계, 확장관계, 일반화관계

41. 시퀀스 다이어그램: 객체 간 상호작용을 메시지 흐름으로 표현한 다이어그램, 객체 간의 동적 상호작용을 시간적 개념을 중심으로 모델링하는 과정이다.
      		 객체의 오퍼레이션과 속성을 상세히 정의해야 한다. 유스케이스를 실현한다.
 ㄴ 구성요소: 객생실메(객체, 생명선, 실행, 메시지)

42. 패키지 다이어그램: 시스템의 서로 다른 패키지들 사이의 의존 관계를 표현하기 위한 다이어그램
 ㄴ 구성요소: 패키지, 의존관계

43. 활동 다이어그램: 시스템이 어떤 기능을 수행하는지를 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서대로 표현하는 다이어그램, 오퍼레이션이나 처리과정이 수행되는 동안 일어나는 일들을 단계적으로 표현한다. 활동 다이어그램은 하나의 유스케이스 안이나, 유스케이스 사이에서 발생하는 복잡한 처리의 흐름을 명확하게 표현할 수 있다.
 ㄴ 구성요소: 시작점, 전이, 액션/액티비티, 종료점, 조건(판단)노드, 병합노드, 포크노드, 조인노드, 구획면

44. 상태다이어그램: 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호작용에 따라 상태가 어떻게 변화하는지 표현하는 다이어그램. 어떤 이벤트에 의해 객체 자신이 속한 클래스의 상태 변화나 객체 간 상호작용을 하는 과정에서의 상태 변화를 표현한다. 객체는 파악된 상태들 이외의 상태는 가질 수 없고, 특정 순간에는 오직 한 상태로만 존재할 수 있다. 객체의 상태란 객체가 갖는 속성값의 변화이다. 
 ㄴ 구성요소: 상태, 시작상태, 종료상태, 전이, 이벤트, 전이조건

45. 커뮤니케이션 다이어그램: 시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하고, 메시지 뿐만 아니라 객체 간의 연관까지 표현하는 다이어그램이다. 커뮤니케이션 다이어그램은 시스템이나 객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호작용하는 과정을 표현한 다이어그램
 ㄴ 구성요소: 액터, 객체, 링크, 메시지

46. 컴포넌트 다이어그램: 시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존 관계를 나타내는 다이어그램이다. 코드 컴포넌트 기반의 물리적 구조료 표현된다. 실질적 프로그래밍 작업에 사용된다.
 ㄴ 구성요소: 컴포넌트, 인터페이스, 의존관계

47. UI 시나리오 문서의 작성 요건: 완일이가 추수(완전성 일관성 이해성 가독성 추적용이성 수정용이성)

48. 데이터 모델: 현실 세계의 정보를 인간과 컴퓨터가 이애할 수 있도록 추상화하여 표현한 모델
 ㄴ 표시해야할 요쇠: 논리적 데이터 구조, 연산, 제약조건

49. 데이터 모델 절차: 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델
 ㄴ 개념적: 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 데이터 모델, 트랜잭션 모델링, View 통합방법 및 Attribute 합성 고려, DB 종류 관계 X, 주요산출물로는 개체관계 다이어그램이 있다.
 ㄴ 논리적: 업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현한 데이터 모델, 논리적 데이터 몰델을 통해 관계 데이터 모델, 계층 데이터 모델, 네트워크 데이터 모델, 객체지향 데이터 모델, 객체-관계 데이터 모델 중 하나의 모델에 맞게 설계, 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계, 정규화 수행, 매핑, 스키마의 평가 및 정제
 ㄴ 물리적: 논리 데이터 모델을 특정 DBMS의 특성 및 성능을 고려하여 물리적인 스키마를 만드는 일련의 데이터 모델. 각 DBMS의 특성을 고려하여 데이터베이스 저장 구조로 변환, 테이블 인덱스, 뷰, 파티션 등 객체를 생성, 응답시간, 저장 공간의 효율화, 트랜잭션 처리를 고려하여 설계, 성능 측면에서 반 정규화를 수행, 레코드 집중의 분석 및 설꼐, 저장 레코드 양식 설계, 접근 경로 설계

50. 논리 데이터 모델 검증: 업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현하는 프로세스, 개념 모델로부터 업무 영역의 업무 데이터 및 규칙을 구체적으로 표현한 모델

51. 논리적 데이터 모델링 종류
 ㄴ 관계 데이터 모델: 논리적 구조가 2차원 테이블 형태로 구성된 모델, 기본 키와 이를 참조하는 외래 키로 관계 표현 1:1, 1:N, N:M	 관계를 자유롭게 표현
 ㄴ 계층 데이터 모델: 논리적 구조가 트리 형태로 구성된 모델, 상하 관계 존재(부모-자식), 1:N 관계만 허용
 ㄴ 네트워크 데이터 모델: 논리적 구조가 그래프 형태로 구성된 모델, CODASYL DBTG 모델이라고 불림, 상위와 하위 레코드 사이에 다대다(N:M) 관계를 만족하는 구조

52. 관계 데이터 모델의 구성
 ㄴ 릴레이션: 행과 열로 구성된 테이블
 ㄴ 튜플: 릴레이션의 행(Row)에 해당되는 요소
 ㄴ 속성: 릴레이션의 열(Column)에 해당되는 요소
 ㄴ 카디널리티: 튜플의 수
 ㄴ 차수: 애트리뷰트의 수
 ㄴ 스키마: 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조  

53. 관계 대수: 데이터베이스에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 정형 언어이다.
 ㄴ 관계대수 연산자의 종류는 일반 집합 연산자와 순수 관계 연산자로 나뉘어짐
 ㄴ 일반집합연산자의 종류: 합교차카(합집합, 교집합, 차집합, 카디션 프로덕트)
 ㄴ 순수관계연산자의 종류: 셀프조디(셀렉트, 프로젝트, 조인, 디비전)

54. 관계해석: 관계 해석은 튜플 관계 해석과 도메인 관계 해석을 하는 비절차적 언어
 ㄴ 특징: 프레디킷 해석(Predicate Calculus)에 기반한 언어이며 비절차적 언어(원하는 정보가 무엇이라는 것만 선언)이다.

55. 논리 데이터 모델링 속성: 개속관(개체, 속성, 관계)
 ㄴ 개체: 개체는 사물 또는 사건이라고 정의. 피터 챈 모델에서는 개체를 사각형으로 표시, 까마귀발 모델에서는 개체를 표 형식으로 표시
 ㄴ 속성: 개체가 가지고 있는 요소 또는 성질이다. 피터 챈 모델에서는 속성을 타원형으로, 까마귀발 모델에서는 속성을 표 내부에 표시.
 ㄴ 관계: 두 개체 간의 관계를 정의, 피터 챈 모델에서는 관계를 마름모로, 까마귀발 모델에서는 관계를 그림과 같이 표시(그림 참조)

56. 개체-관계(E-R) 모델: 현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 표현하기 위해 가장 널리 사용되고 있는 모델, 논리 데이터 모델링에서는 모든 이해당사자와 의사소통의 보조 자료로 E-R 모델 활용. 
 ㄴ 기호: 개체-사각형, 관계-마름모, 속성-타원, 다중 값 속성-이중 타원, 관계와 속성을 연결-선

57. 정규화: 정규화는 관계형 데이터 모델에서 데이터의 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성과 정확성을 유지하기 위해 무손실 분해하는 과정이다.

58. 이상현상: 데이터 중복성으로 인해 릴레이션을 조작할 때 발생하는 비합리적 현상, 삽삭갱(삽입, 삭제, 갱신)이 있다.
 ㄴ 삽입 이상: 정보 저장 시 해당 정보의 불필요한 세부정보를 입력해야 하는 경우
 ㄴ 삭제 이상: 정보 삭제 시 원치 않는 다른 정보가 같이 삭제되는 경우
 ㄴ 갱신 이상: 중복 데이터 중에서 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우

59. 데이터베이스 정규화 단계: 원부이결다조(원자화, 부분함수 종속 제거, 이행함수 종속 제거, 결정자 함수 종속 제거, 다치 종속 제거, 조인 종속 제거)

60. 반 정규화: 정규화된 엔터티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법이다
 ㄴ 장점: 반 정규화된 데이터 구조는 성능 향상과 관리의 효율성이 증가
 ㄴ 단점: 데이터의 일관성 및 정합성 저하, 유지를 위한 비용이 별도로 발생하여 성능에 나쁜 영향을 미칠 수 있음

61. 반 정규화 기법: 테병분중 컬중 관중( 테이블- 병합/분할/중복, 컬럼- 중복, 관계- 중복)

62. 물리 데이터 모델링: 논리모델을 적용하고자 하는 기술에 맞도록 상세화해가는 과정이다.

63. 논리 데이터 저장소에서 물리 데이터 저장소로 모델링 변환 절차: 계속U관컬반(개체를 테이블로 변환, 속성을 컬럼으로 변환, UID를 기본키로 변환, 관계를 외래키로 변환, 컬럼 유형과 길이 정의, 반 정규화 수행)

64. 참조 무결성 제약조건: 릴레이션과 릴레이션 사이에 대해 참조의 일관성을 보장하기 위한 조건, 두 개의 릴레이션이 기본키, 외래키를 통해 참조관계를 형성할 경우, 참조 하는 외래키의 값은 항상 참조되는 릴레이션에 기본키로 존재해야 한다.
 ㄴ 제한: 참조 무결성 원칙을 위배하는 연산을 거절하는 옵션
 ㄴ 연쇄: Cascade 참조되는 릴레이션에서 튜플을 삭제하고, 참조되는 릴레이션에서 이 튜플을 참조하는 튜플들도 함께 삭제하는 옵션
 ㄴ 널값: Nullify 참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 릴레이션에서 해당 튜플을 참조하는 튜플들의 외래 키에 NULL값을 넣는 옵션.

65. 인덱스: 검색 연산의 최적화를 위해 데이터베이스 내 열에 대한 정보를 구성한 데이터구조, 전체 데이터의 검색 없이 필요한 정보에 대해 신속한 조회가 가능하다.
 ㄴ 적용기준: 인덱스 분포도가 10~15% 이내인 경우 아래 수식 참고((분포도 = 1 / 컬럼 값의 종류) x 100), 분포도 = (컬럼 값의 평균 Row 수 / 테이블의 총 Row 수) x 100
           분포도가 범위 이상이더라도 부분처리를 목적으로 하는 경우 적용, 조회 및 출력 조건으로 사용되는 컬럼일 경우 적용

66. 분포도: 특정 컬럼의 데이터가 테이블에 평균적으로 분포되어 있는 정도,=

67. 인덱스 컬럼 선정: 분포도가 좋은 컬럼은 단독적으로 생성한다. 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성, 가능한 수정이 빈번하지 않은 컬럼을 선정 등

68. 설계 시 고려 사항: 지나치게 많은 인덱스는 오버헤드로 작용한다. 인덱스는 추가적인 저장 공간이 필요함을 고려해야 한다, 넓은 범위 인덱스 처리시 오히려 전체 처리보다 더 많은 오버해드 발생시킬 수 있음, 인덱스와 테이블의 저장 공간을 적절히 분리 될 수 있도록 설계해야한다.

69. 뷰속성
 ㄴ REPLACE: 뷰가 이미 존재하는 경우 재생성
 ㄴ FORCE: 본 테이블의 존재 여부에 관계없이 뷰 생성
 ㄴ NOFORCE: 기본 테이블이 존재할 떄 뷰 생성
 ㄴ WITH CHECK OPTION: 서브쿼리 내의 조건을 만족하는 행만 변경
 ㄴ WITH READ ONLY: 데이터 조작어 작업 불가

70. 

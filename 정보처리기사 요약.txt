정보처리기사 중요부분 요약


1. 소프트웨어 생명주기 모델(SDLC: Software Development Life Cycle)
  ㄴ 소프트웨어 생명주기는 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차.
  
 가. 소프트웨어 생명주기 모델 프로세스
  ㅇ 요설구테유
    - 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 

 나. 소프트웨어 생명주기 모델 종류
   ㅇ 폭프나반: 폭포수 모델, 프로토타이핑 모델, 나선형 모델, 반복적 모델
     1) 폭포수 모델
      - 폭포수 모델은 가장 오래된 모델이자 순차적 모형, 성공 사례가 많고 산출물이 명확하지만 요구사항 변경이 어려움 
      - 절차: 타당성 검토 -> 계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수
  
     2) 나선형 모델
      - 시스템 개발 시 위험을 최소화 하기 위해 점진적으로 완벽한 시스템으로 개발해나가는 모델
      - 절차: 계획 및 정의 -> 위험 분석 -> 개발 -> 고객 평가
  
     3) 프로토 타이핑 모델 
      - 고객이 요구한 주요 기능을 프로토타입으로 구현하여, 고객의 피드백을 반영하여 소프트웨어를 만들어가는 모델
      - 프로토 타입은 발주자나 개발자 모두에게 공동의 참조모델 제공
   
     4) 반복적 모델
      - 구축 대상을 나누어 병렬적으로 개발 후 통합하거나, 반복적을 개발하여 점증 완성시키는 모델

 다. 소프트웨어 개발 방법론
  ㄴ 소프트웨어 개발 방법론은 소프트웨어 개발 전 과정에 지속적으로 적용할 수 있는 방법, 절차, 기법이다.
    SW를 하나의 생명체로 간주하고 개발의 시작부터 시스템을 사용하지 않는 과정까지의 전 과정 형상화
  
   ㅇ 소프트웨어 개발 방법론 종류
     - 구정객컴애제: 구조적, 정보공학, 객체지향, 컴포넌트 기반, 애자일, 제품 계열 방법론
   가. 구조적 방법론
     - 전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 분할과 정복  접근 방식의 방법론
     - 프로세스 중심의 하향식 방법론
     - 나씨-슈나이더만 차트 사용(논리의 기술에 중점을 둔 도형식 표현 방법, 연속, 선택 및 다중선택, 반복 등의 제어 논리 구조로 표현, 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합)
   나. 정보공학 방법론
     - 정보시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
     - 개발 주기를 이용해 대형 프로젝트를 수행하는 체계적인 방법론
   다. 객체지향 방법론
     - 객체라는 기본 단위로 시스템을 분석 및 설계하는 방법론
     - 복잡한 현실 세계를 사람이 이해하는 방식으로 시스템에 적용, 객체, 클래스, 메시지 사용ㅓㅓ
   라. 컴포넌트 기반 방법론
     - 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
     - 개발 기간 단축으로 생산성 향상, 새로운 기능 추가 쉬움, 소프트웨어 재사용 가능
   마. 애자일 방법론
     - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론
     - 애자일은 개발 과정의 어려움을 극복하기 위해 적극적으로 모색한 방법론
   바. 제품 계열 방법론
     - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
     - 임베디드 소프트웨어를 작성하는 데 유용한 방법론
     
  ㅁ 애자일 방법론의 개념
   ㅇ 애자일 방법론은 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발 방법론이다.
   ㅇ 개발기간이 짧고 신속하며, 폭포수 모형에 대비되는 방법론으로 개발과 함께 즉시 피드백을 받아서 유동적으로 개발할 수 있다. 
   
   ㅇ 애자일 방법론은 대표적으로 XP, 린(Learn), 스크럼(SCRUM) 등이 있다.
   ㅇ XP(extrema Programming)
    - XP의 5가지 가치: 용단의피존(용기, 단순성, 의사소통, 피드백, 존중)
    - XP 12가지 기본원리: 짝 프로그래밍, 공동 코드 소유, 지속적인 통합, 계획 세우기, 작은 릴리즈, 메타포어, 간단한 디자인, 테스트 기반 개발, 리팩토링, 40시간 작업, 고객 상주, 코드 표준
   ㅇ 스크럼
    - 백로그, 스프린트, 스크럼 미팅, 스크럼 마스터, 스프린트 회고, 번 다운 차트
   ㅇ 린
    - 도요타의 린 시스템 품질 기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론
    - JIT, 칸반 보드 사용
    - 7가지 원칙: 낭품지늦빠사전 - 낭비제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화

2. 비용산정 모형
  ㄴ 비용산정 모형은 소프트웨어 규모파악을 통한 투입자원, 소요시간을 파악하여 실행 가능한 계획을 수립하기 위해 비용을 산정하는 방식이다.
  ㄴ 하향식 산정방법, 상향식 산정방법이 있다.
  ㄴ 하향식 산정 방법에는 델파이 기법, 전문가 판단이 있다.
  
  ㄴ 상향식 산정방법에는 코드라인 수(Loc), Man Month COCOMO 푸트남 기능점수(FP)모형이 있따.

  가. Loc(Lines of Code) 모형: 소프트웨어 각 기능의 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구하여 비용을 산정하는 방식, 측정이 쉽고 이해하기 쉬워 많이 사용된다.
  낙관치 + 4중간치 + 비관치 / 6

  나. Moan Month 모형은 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 프로젝트 비용을 산정하는 방식
     MM = Loc/월간 생산성, 프로젝트 기간 = MM/프로젝트 인력
  다. COCOMO 모형: 보헴이 제안한 ㅁ형으로 프로그램 규모에 따라 비용을 산정하는 방식. 비용산정 결과는 Man Month로 산정
     규모에 따라 조직형, 반분리형, 임베디드형으로 나뉜다.(Organic, Semi-Detached, Embedded)
  라. 푸트남 모형: 소프트웨어 개발주기의 단계별로 요구할 인력의 분포를 가정하는 방식, 푸트남이 제안한 것으로 생명주기 예측 모형이라고 한다. Rayleigh-Norden 곡선의 노력 분포도를 기준으로 한다.
  마. 기능점수(Function Point) 모형: 요구 기능을 증가시키는 인자별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능점수 계산하여 비용을 산정하는 방식 경험을 바탕으로 단순, 보통, 복잡에 따라 가중치 부여
  
3. 일정관리 모델
주 공정법, PERT, 중요 연쇄 프로젝트 관리가 있다.
CPM 일정계산 - 가장 긴 경로 계싼
PERT - 비관치, 중간치, 낙관치의 3점 추정방식을 통해 일정을 관리하는 기법
CCPM - CPM으로 자원제약사항을 고려하여 일정을 작성

4. 소프트웨어 아키텍쳐
 ㄴ 소프트웨어 아키텍처는 여러가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체이다.
 ㄴ 소프트웨어 아키텍쳐 프레임워크: 소프트웨어 집약적인 시스템에서 아키텍처가 표현해야하는 내용 및 이들 간의 관계를 제공하는 아키텍처 기술 표준이다.
 ㄴ 소프트웨어 아키텍처 구성요소: 아키텍처 명세서, 이해관계자, 관심사, 관점, 뷰, 근거, 목표, 환경, 시스템

5. 소프트웨어 아키텍처 4+1뷰
 ㄴ 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법
 ㄴ 4개의 분리된 구조로 구성되는 아키텍처 개념을 제시하고, 서로 충돌되거나 요구사항 충족을 증명하기 위해 유스케이스를 사용
 ㄴ 구성요소: 유논프구배(유스케이스뷰, 논리뷰, 프로세스뷰, 구현뷰, 배포뷰)

6. 소프트웨어 아키텍처 패턴
 ㄴ 소프트웨어를 설계할 때 참조할 수 있는 전형적인 해결 방식.
 ㄴ 일반화되고 재사용 가능한 솔루션
 ㄴ 패턴유형: 계층화 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 브로커 패턴, 모델-뷰-컨트롤러 패턴(MVC)

7. 소프트웨어 아키텍처 비용 평가 모델
 ㄴ SAAM, ATAM, CBAM, ADR, ARID

8. 디자인 패턴
 ㄴ 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴
 ㄴ 개발 효율성, 유지보수성, 운용성, 프로그램 최적화
 ㄴ 구성요소: 패문솔 사결샘(패턴의 이름, 문제 및 배경, 솔루션, 사례, 결과, 샘플코드)

9. 디자인 패턴 유형
 목적 - 생성, 구조, 행위 / 범위 - 클래스, 객체

10. 디자인 패턴 종류
 생성 - Builder, Prototype, Factory Method, Abstract Factory, Singleton
 구조 - Bridge, Decorator, Facade, Flyweight, Proxy, Composite, Adapter
 행위 - Mediator, Interpreter, Iterator, Template Method, Observer, State, Visitor, Command, Strategy, Memento, Chain of Responsibility

11. 현행 시스템 분석서 작성 및 검토
 ㄴ 분석 산출물의 종류: 현기인 아소하네(정보시스템 구성 현황, 정보 시스템 기능 구성도, 인터페이스 현황, 현행 시스템 아키텍처 구성도, 소프트웨어 구성도, 하드웨어 구성도, 네트워크 구성도)
 ㄴ 각 구성도의 사례 확인

12. 운영체제 개념: 컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있도록 해주고, 사용자와 하드웨어간 인터페이스 담당
 ㄴ 현행 시스템 분석
   품질측면 - 신뢰도, 성능
   지원측면 - 기술지원, 주변기기, 구축비용

13. 운영체제 종류 및 특징
 ㄴ PC - 윈도우, 유닉스, 리눅스 / 모바일 - 안드로이드, iOS

14. 네트워크 현행 시스템 분석
 ㄴ 네트워크 개념: 컴퓨터 장치들의 노드 간 연결(데이터 링크)을 사용하여 서로에게 데이터를 교환할 수 있도록 하는 기술
 OSI 7계층: 네트워크 통신에서 생긴 여러가지 충돌 문제를 완화하기 위해 국제 표준화 기구(ISO)에서 제시한 네트워크 기본 모델

 OSI 7계층 구성요소: Application, Presentation, Session, Transport, Network, Data Link, Physical
 
 네트워크 현행 시스템 분석: 네트워크 구조를 구성도를 통해 분석
 백본망, 라우터, 스위치, 게이트웨이, 방화벽 등을 대상으로 분석

15 DBMS 형행 시스템 분석
 - 가성호기구(성능 측면 - 가용성, 성능, 상호 호환성 / 지원 측면 - 기술 지원, 구축 비용)

16. 미들웨어 현행 시스템 분석: 가성기구(성능 측면: 가용성, 성능 / 지원 측면 - 기술 지원, 구축 비용)


17. 요구사항 확인
 - 요구공학: 사용자의 요구가 반영된 시스템을 개발하기 위하여 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동
 - 요구공학의 목적: 이해관계자 사이 효과적인 의사소통 수단 제공, 공통된 이해 설정, 요구사항 누락 방지 및 이해 오류로 인한 불필요한 비용 절감, 요구사항 변경 추적, 개발 비용 시간 절약
 - 요구사항의 분류: 기능적 요구사항(특성: 기완일 - 기능성, 완전성, 일관성) / 비기능적 요구사항(신사효유이보품제 - 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성, 품질 관련 요구사항, 제약사항)
 
18. 요구공학 프로세스: 도분명확(도출, 분석, 명세, 확인)

19. 요구사항 도출단계: 소프트웨어가 해결해야할 문제를 이해하고, 고갱르ㅗ 부터 제시되는 추상적 요구에 대해 관련 정보를 식별하고 수집방법 결정, 요구사항 구체적으로 표현하는 단계
 주요기법: 인터뷰, 브레인스토밍, 델파이, 롤 플레잉, 워크숍, 설문조사

20 요구사항 분석 단계: 요구사항 분석 단계는 추출된 요구사항에 대해 충돌, 중복, 누락 등의 분석을 통해 완전성과 일관성을 확보하는 단계
 분석 단계 절차: 요구사항 분류 -> 개념 모델링 생성 및 분석 -> 요구사항 할당 -> 요구사항 협상 -> 정형분석
 분석 단계 기법: 자료 흐름 지향 분석, 객체 지향 분석
 분석기술: 청취, 인터뷰와 질문, 분석, 중재, 관찰, 작성, 조직, 모델 작성

21. 요구사항 명세 단계: 체계적으로 검토, 평가, 승인될 수 있는 문서를 작성
 주요기법: 비정형 명세 기법, 정형 명세 기법
 산출물: 요구사항 명세서
 명세 원리 및 검증 항목: 명완검일수추개(명확성, 완전성, 검증 가능성, 일관성, 수정 용이성, 추적 가능성, 개발 후 이용성)

22. 요구사항 확인 및 검증 단계: 사용자의 요구가 올바르게 기술 되었는지에 대한 검토 / 요구사항을 이해했는지 확인(Validation)하고 욕사항 문서가 회사 표준에 적합한지, 일관성을 만족하는지, 완전한지 검증(Verification) 해야한다.

 ㄴ 요구사항 확인 및 검증 절차: 요구사항 목록 확인, 정의서 작성 여부 확인, 비기능적 요구사항 확인, 타 시스템 연계 및 인터페이스 요구사항 확인
 ㄴ 요구사항 확인 및 검증 단계의 주요기법 및 산출물: 
   - 요구사항 검토, 정형 기술 검토 활용(동료 검토, 워크스루, 인스펙션), 프로토 타이핑 활용, 모델 검증, 테스트 케이스 및 테스트를 통한 확인, CASE 도구 활용 검증, 베이스라인을 통한 검증, 요구사항 추적표

 - 상세 정형 기술 검토 기법: 관리 리뷰, 기술 리뷰, 인스펙션, 워크 스루, 감사

23. 요구사항 관리 단계: 프로젝트 진행 과정에서 발생하는 요구사항의 변경에 대해 일치성과 무결성을 제공하기 위해 변경제어와 추적 등 일련의 관리를 수행하는 활동
 주요산출물: 요구사항 변경요청서, 변경 승인서, 추적표

 - 요구사항 관리 단계 절차: 협기변확(요구사항 협상 -> 요구사항 기준선 설정 -> 요구사항 변경관리 -> 요구사항 확인 및 검증)

24. 분석모델 검증: 요구사항 도출 기법을 활용하여 업무 분석가가 제시한 분석 모델에 대해서 확인하는 활동
 ㄴ 분석모델 검증 방법: 유스케이스 모델 검증, 개념 수준의 분석 클래스 검증, 분석 클래스 검증


25. UI 요구사항 확인
 UI(User Interface) - 사용자와 시스템 사이에서 의사소통할 수 있도록 고안된 물리적, 가상의 매개체이다. 정보기기나 소프트웨어의 화면 등에서 사람이 접하게 되는 화면
 UX(User eXperience) - 제품과 시스템, 서비스 드응ㄹ 사용자가 직/간접적으로 경험하면서 느끼고 생각하는 총체적 경험

26. UI 유형: CLI, GUI, NUI, OUI
 CLI - 정적인 텍스트 기반, GUI - 그래픽 반응 기반, NUI - 직관적 사용자 반응 기반, OUI - 유기적 상호작용 기반
27. UI 설계원칙: 직유학유(직관성, 유효성, 학습성, 유연성)

28. UI 설계지침: 사일단결 가표접명오(사용자 중심, 일관성, 단순성, 결과 예측 가능, 가시성, 표준화, 접근성, 명확성, 오류 발생 해결)

29. UI 품질 요구사항: 기신사효유이(기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성)
 
30. UI 표준: 디자인 철학과 원칙 기반 하에 전체 시스템에 공통으로 적용되는 화면 간 이동, 화면구성 등에 관한 규약
 ㄴ UI 표준 구성: 액정스패조(전체적인 UX원칙, 정책 및 철학, UI 스타일 가이드, uI 패턴 모델 정의, UI표준 수립을 위한 조직 구성
 ㄴ CRUD 방식: 대부분의 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create, Read, Update, Delete를 묶어서 이르는 말

31. UI 개발을 위한 주요 기법: 3C 분석, SWOT 분석, 시나리오 플래닝, 사용성 테스트, 워크숍

32. 사용자 요구사항 도출: 페르소나 정의, 콘셉트 모델 정의, 사용자 요구사항 정의, UI컨셉션

33. 스토리보드 개념: UI 화면 설계를 위해서 정책이나 프로세스 및 콘텐츠의 구성, 와이어 프레임(UI, UX), 기능에 대한 정의, 데이터 베이스의 연동 등 구축하는 서비스를 위한 대부분 정보가 수록된 문서, 디자이너와 개발자가 최종적으로 참고하는 산출 문서

34. UI 화면설계 구분: 와스프(와이어 프레임, 스토리보드, 프로토타입)
 ㄴ 와이어 프레임: 이해 관계자들과의 화면구성을 협의하거나 서비스의 간략한 흐름을 공유하기 위해 화면 단위의 레이아웃을 설계하는 작업
 ㄴ 스토리보드: 정책, 프로세스, 콘텐츠 구성, 와이어 프레임, 기능 정의, 데이터베이스 연동 등 서비스 구축을 위한 모든 정보가 담겨 있는 설계 산출물
 ㄴ 프로토타입: 정적인 화면으로 설계된 와이어 프레임 또는 스토리보드에 동적 효과를 적용하여 실제 구현된 것처럼 시뮬레이션 할 수 있는 모형

35. UI 설계를 위한 UML
 ㄴ UML 개념: 객체지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화 할 때 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어
 ㄴ UML 특징: 가구명문(가시화 언어, 구축 언어, 명세화 언어, 문서화 언어)
 ㄴ 가시화 언어: 개념 모델 작성 시 오류가 적고 의사소통 용이
 ㄴ 구축 언어: 다양한 프로그래밍 언어로 실행 시스템의 예측 가능, UML을 소스 코드로 변환하여 구축 가능, 역 변환하여 역공학 가능
 ㄴ 명세화 언어: 정확한 모델 제시, 완전한 모델 작성 가능
 ㄴ 문서화 언어: 시스템에 대한 평가 및 의사소통의 문서

36. UML 구성요소: 사관다(사물 관계 다이어그램)
 ㄴ 사물: 추상적인 개념으로, 주제를 나타내는 요소, 단어 관점에서 '명사'또는 '동사'를 의미
 ㄴ 관계: 사물의 의미를 확장하고 명확히 하는 요소, 사물과 사물을 연결하여 관계를 표현하는 요소, 단어 관점에서 '형용사'또는 '부사'를 의미
 ㄴ 다이어그램: 사물과 관계를 모아 그림으로 표현한 형태, 형식과 목적에 따라 9가지로 정의

37. UML 다이어그램: 구분에 따라 구조적(정적) 다이어그램과 행위적(동적) 다이어그램으로 구분된다.
 ㄴ 구조적(정적) 다이어그램: 클객 컴배 복패(클래스, 객체, 컴포넌트, 배치, 복합체 구조, 패키지)
 ㄴ 행위적(동적) 다이어그램: 유시커 상활타(유스케이스, 시퀀스, 커뮤니케이션, 상태, 활동, 타이밍)

38. UML 확장 모델의 스테레오 타입: UML 기본 요소 이외의 새로운 요소를 만들어내기 위한 확장 메커니즘, 형태는 기존 UML 요소를 그대로 사용하지만 내부 의미는 다른목적으로 사용, <<>>길러멧 기호를 사용하여 표현한다.

39. 클래스 다이어그램: 객체지향 모델링 시 클래스의 속성 및 연산과 클래스 간 정적인 관계를 표현한 다이어그램
 ㄴ 구성요소: 클래스, 속성, 연산, 접근제어자(-, +, #, ~)
 ㄴ 클래스 간의 관계: 연집복 일의실(연관 집합 복합 일반화 의존 실체화)


40. 유스케이스 다이어그램: 시스템이 제공하고 있는 기능 및 그와 관련된 외부 요소를 사용자의 관점에서 표현하는 다이어그램
 ㄴ 구성요소: 유스케이스, 액터, 시스템, 시나리오, 이벤트의 흐름
 ㄴ 유스케이스 다이어그램의 관계: 포함관계, 확장관계, 일반화관계

41. 시퀀스 다이어그램: 객체 간 상호작용을 메시지 흐름으로 표현한 다이어그램, 객체 간의 동적 상호작용을 시간적 개념을 중심으로 모델링하는 과정이다.
      		 객체의 오퍼레이션과 속성을 상세히 정의해야 한다. 유스케이스를 실현한다.
 ㄴ 구성요소: 객생실메(객체, 생명선, 실행, 메시지)

42. 패키지 다이어그램: 시스템의 서로 다른 패키지들 사이의 의존 관계를 표현하기 위한 다이어그램
 ㄴ 구성요소: 패키지, 의존관계

43. 활동 다이어그램: 시스템이 어떤 기능을 수행하는지를 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서대로 표현하는 다이어그램, 오퍼레이션이나 처리과정이 수행되는 동안 일어나는 일들을 단계적으로 표현한다. 활동 다이어그램은 하나의 유스케이스 안이나, 유스케이스 사이에서 발생하는 복잡한 처리의 흐름을 명확하게 표현할 수 있다.
 ㄴ 구성요소: 시작점, 전이, 액션/액티비티, 종료점, 조건(판단)노드, 병합노드, 포크노드, 조인노드, 구획면

44. 상태다이어그램: 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호작용에 따라 상태가 어떻게 변화하는지 표현하는 다이어그램. 어떤 이벤트에 의해 객체 자신이 속한 클래스의 상태 변화나 객체 간 상호작용을 하는 과정에서의 상태 변화를 표현한다. 객체는 파악된 상태들 이외의 상태는 가질 수 없고, 특정 순간에는 오직 한 상태로만 존재할 수 있다. 객체의 상태란 객체가 갖는 속성값의 변화이다. 
 ㄴ 구성요소: 상태, 시작상태, 종료상태, 전이, 이벤트, 전이조건

45. 커뮤니케이션 다이어그램: 시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하고, 메시지 뿐만 아니라 객체 간의 연관까지 표현하는 다이어그램이다. 커뮤니케이션 다이어그램은 시스템이나 객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호작용하는 과정을 표현한 다이어그램
 ㄴ 구성요소: 액터, 객체, 링크, 메시지

46. 컴포넌트 다이어그램: 시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존 관계를 나타내는 다이어그램이다. 코드 컴포넌트 기반의 물리적 구조료 표현된다. 실질적 프로그래밍 작업에 사용된다.
 ㄴ 구성요소: 컴포넌트, 인터페이스, 의존관계

47. UI 시나리오 문서의 작성 요건: 완일이가 추수(완전성 일관성 이해성 가독성 추적용이성 수정용이성)

48. 데이터 모델: 현실 세계의 정보를 인간과 컴퓨터가 이애할 수 있도록 추상화하여 표현한 모델
 ㄴ 표시해야할 요쇠: 논리적 데이터 구조, 연산, 제약조건

49. 데이터 모델 절차: 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델
 ㄴ 개념적: 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 데이터 모델, 트랜잭션 모델링, View 통합방법 및 Attribute 합성 고려, DB 종류 관계 X, 주요산출물로는 개체관계 다이어그램이 있다.
 ㄴ 논리적: 업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현한 데이터 모델, 논리적 데이터 몰델을 통해 관계 데이터 모델, 계층 데이터 모델, 네트워크 데이터 모델, 객체지향 데이터 모델, 객체-관계 데이터 모델 중 하나의 모델에 맞게 설계, 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스를 설계, 정규화 수행, 매핑, 스키마의 평가 및 정제
 ㄴ 물리적: 논리 데이터 모델을 특정 DBMS의 특성 및 성능을 고려하여 물리적인 스키마를 만드는 일련의 데이터 모델. 각 DBMS의 특성을 고려하여 데이터베이스 저장 구조로 변환, 테이블 인덱스, 뷰, 파티션 등 객체를 생성, 응답시간, 저장 공간의 효율화, 트랜잭션 처리를 고려하여 설계, 성능 측면에서 반 정규화를 수행, 레코드 집중의 분석 및 설꼐, 저장 레코드 양식 설계, 접근 경로 설계

50. 논리 데이터 모델 검증: 업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현하는 프로세스, 개념 모델로부터 업무 영역의 업무 데이터 및 규칙을 구체적으로 표현한 모델

51. 논리적 데이터 모델링 종류
 ㄴ 관계 데이터 모델: 논리적 구조가 2차원 테이블 형태로 구성된 모델, 기본 키와 이를 참조하는 외래 키로 관계 표현 1:1, 1:N, N:M	 관계를 자유롭게 표현
 ㄴ 계층 데이터 모델: 논리적 구조가 트리 형태로 구성된 모델, 상하 관계 존재(부모-자식), 1:N 관계만 허용
 ㄴ 네트워크 데이터 모델: 논리적 구조가 그래프 형태로 구성된 모델, CODASYL DBTG 모델이라고 불림, 상위와 하위 레코드 사이에 다대다(N:M) 관계를 만족하는 구조

52. 관계 데이터 모델의 구성
 ㄴ 릴레이션: 행과 열로 구성된 테이블
 ㄴ 튜플: 릴레이션의 행(Row)에 해당되는 요소
 ㄴ 속성: 릴레이션의 열(Column)에 해당되는 요소
 ㄴ 카디널리티: 튜플의 수
 ㄴ 차수: 애트리뷰트의 수
 ㄴ 스키마: 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조  

53. 관계 대수: 데이터베이스에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적 정형 언어이다.
 ㄴ 관계대수 연산자의 종류는 일반 집합 연산자와 순수 관계 연산자로 나뉘어짐
 ㄴ 일반집합연산자의 종류: 합교차카(합집합, 교집합, 차집합, 카디션 프로덕트)
 ㄴ 순수관계연산자의 종류: 셀프조디(셀렉트, 프로젝트, 조인, 디비전)

54. 관계해석: 관계 해석은 튜플 관계 해석과 도메인 관계 해석을 하는 비절차적 언어
 ㄴ 특징: 프레디킷 해석(Predicate Calculus)에 기반한 언어이며 비절차적 언어(원하는 정보가 무엇이라는 것만 선언)이다.

55. 논리 데이터 모델링 속성: 개속관(개체, 속성, 관계)
 ㄴ 개체: 개체는 사물 또는 사건이라고 정의. 피터 챈 모델에서는 개체를 사각형으로 표시, 까마귀발 모델에서는 개체를 표 형식으로 표시
 ㄴ 속성: 개체가 가지고 있는 요소 또는 성질이다. 피터 챈 모델에서는 속성을 타원형으로, 까마귀발 모델에서는 속성을 표 내부에 표시.
 ㄴ 관계: 두 개체 간의 관계를 정의, 피터 챈 모델에서는 관계를 마름모로, 까마귀발 모델에서는 관계를 그림과 같이 표시(그림 참조)

56. 개체-관계(E-R) 모델: 현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 표현하기 위해 가장 널리 사용되고 있는 모델, 논리 데이터 모델링에서는 모든 이해당사자와 의사소통의 보조 자료로 E-R 모델 활용. 
 ㄴ 기호: 개체-사각형, 관계-마름모, 속성-타원, 다중 값 속성-이중 타원, 관계와 속성을 연결-선

57. 정규화: 정규화는 관계형 데이터 모델에서 데이터의 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성과 정확성을 유지하기 위해 무손실 분해하는 과정이다.

58. 이상현상: 데이터 중복성으로 인해 릴레이션을 조작할 때 발생하는 비합리적 현상, 삽삭갱(삽입, 삭제, 갱신)이 있다.
 ㄴ 삽입 이상: 정보 저장 시 해당 정보의 불필요한 세부정보를 입력해야 하는 경우
 ㄴ 삭제 이상: 정보 삭제 시 원치 않는 다른 정보가 같이 삭제되는 경우
 ㄴ 갱신 이상: 중복 데이터 중에서 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우

59. 데이터베이스 정규화 단계: 원부이결다조(원자화, 부분함수 종속 제거, 이행함수 종속 제거, 결정자 함수 종속 제거, 다치 종속 제거, 조인 종속 제거)

60. 반 정규화: 정규화된 엔터티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법이다
 ㄴ 장점: 반 정규화된 데이터 구조는 성능 향상과 관리의 효율성이 증가
 ㄴ 단점: 데이터의 일관성 및 정합성 저하, 유지를 위한 비용이 별도로 발생하여 성능에 나쁜 영향을 미칠 수 있음

61. 반 정규화 기법: 테병분중 컬중 관중( 테이블- 병합/분할/중복, 컬럼- 중복, 관계- 중복)

62. 물리 데이터 모델링: 논리모델을 적용하고자 하는 기술에 맞도록 상세화해가는 과정이다.

63. 논리 데이터 저장소에서 물리 데이터 저장소로 모델링 변환 절차: 계속U관컬반(개체를 테이블로 변환, 속성을 컬럼으로 변환, UID를 기본키로 변환, 관계를 외래키로 변환, 컬럼 유형과 길이 정의, 반 정규화 수행)

64. 참조 무결성 제약조건: 릴레이션과 릴레이션 사이에 대해 참조의 일관성을 보장하기 위한 조건, 두 개의 릴레이션이 기본키, 외래키를 통해 참조관계를 형성할 경우, 참조 하는 외래키의 값은 항상 참조되는 릴레이션에 기본키로 존재해야 한다.
 ㄴ 제한: 참조 무결성 원칙을 위배하는 연산을 거절하는 옵션
 ㄴ 연쇄: Cascade 참조되는 릴레이션에서 튜플을 삭제하고, 참조되는 릴레이션에서 이 튜플을 참조하는 튜플들도 함께 삭제하는 옵션
 ㄴ 널값: Nullify 참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 릴레이션에서 해당 튜플을 참조하는 튜플들의 외래 키에 NULL값을 넣는 옵션.

65. 인덱스: 검색 연산의 최적화를 위해 데이터베이스 내 열에 대한 정보를 구성한 데이터구조, 전체 데이터의 검색 없이 필요한 정보에 대해 신속한 조회가 가능하다.
 ㄴ 적용기준: 인덱스 분포도가 10~15% 이내인 경우 아래 수식 참고((분포도 = 1 / 컬럼 값의 종류) x 100), 분포도 = (컬럼 값의 평균 Row 수 / 테이블의 총 Row 수) x 100
           분포도가 범위 이상이더라도 부분처리를 목적으로 하는 경우 적용, 조회 및 출력 조건으로 사용되는 컬럼일 경우 적용

66. 분포도: 특정 컬럼의 데이터가 테이블에 평균적으로 분포되어 있는 정도,=

67. 인덱스 컬럼 선정: 분포도가 좋은 컬럼은 단독적으로 생성한다. 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성, 가능한 수정이 빈번하지 않은 컬럼을 선정 등

68. 설계 시 고려 사항: 지나치게 많은 인덱스는 오버헤드로 작용한다. 인덱스는 추가적인 저장 공간이 필요함을 고려해야 한다, 넓은 범위 인덱스 처리시 오히려 전체 처리보다 더 많은 오버해드 발생시킬 수 있음, 인덱스와 테이블의 저장 공간을 적절히 분리 될 수 있도록 설계해야한다.

69. 뷰속성
 ㄴ REPLACE: 뷰가 이미 존재하는 경우 재생성
 ㄴ FORCE: 본 테이블의 존재 여부에 관계없이 뷰 생성
 ㄴ NOFORCE: 기본 테이블이 존재할 떄 뷰 생성
 ㄴ WITH CHECK OPTION: 서브쿼리 내의 조건을 만족하는 행만 변경
 ㄴ WITH READ ONLY: 데이터 조작어 작업 불가

70. 클러스터 적용기준
 ㄴ 인덱스의 단점을 해결한 기법으로, 분포도가 넓을 수록 오히려 유리하다.
 ㄴ 엑세스 기법이 아니라 엑세스 효율 향상을 위한 물리적 저장 방법이다.
 ㄴ 분포도가 넓은 테이블의 클러스터링은 저장 공간의 절약이 가능하다.
 ㄴ 대량의 범위를 자주 엑세스 하는 경우 적용한다.
 ㄴ 인덱스를 사용한 처리 부담이 되는 넓은 분포도에 활용한다.
 ㄴ 여러개의 테이블이 빈번하게 조인을 일으킬 때 활용한다.

71. 파티션 종류: 레해리컴
 ㄴ 레인지 파티셔닝: 연속적인 숫자나 날짜를 기준으로 하는 파티셔닝 기법, 손쉬운 관리 기법을 제공하여 관리 시간의 단축이 가능하다.
 ㄴ 해시 파티셔닝: 파티션 키의 해시 함수 값에 의한 파티셔닝 기법이다, 균등한 데이터 분할이 가능하고 질의 성능이 향상 가능하다.
 ㄴ 리스트 파티셔닝: 특정 파티션에 저장 될 데이터에 대한 명시적 제어가 가능한 파티셔닝 기법이다, 분포도가 비슷하고 데이터가 많은 SQL에서 컬러므이 조건이 많이 들어오는 경우 유용하다.
 ㄴ 컴포지트 파티셔닝: 레인지, 해시, 리스트 중 2개 이상의 파티셔닝을 결합하는 파티셔닝 기법이다. 큰 파티션에 대한 I/O 요청을 여러 파티션으로 분산할 수 있다.

72. 파티션의 장점: 성가백합(성능 향상, 가용성 향상, 백업 가능, 경합 감소)

73. 데이터베이스 개념
 ㄴ 다수의 인원, 시스템, 또는 프로그램이 사용할 목적으로 통합하여 관리되는 데이터의 집합이다.
 ㄴ 데이터에 대한 효과적인 관리를 위해 자료 중복성 제거, 무결성 확보, 일관성 유지, 유용성 보장이 중요하다.
 ㄴ 데이터베이스는 통합된 데이터, 저장된 데이터, 운영 데이터, 공용 데이터이다.

74. 데이터베이스 특성: 실시간 접근성, 계속적인 변화, 동시 공용, 내용 참조

75. RDBMS: Relational Database Management System: 관계형 모델을 기반으로 하는 가장 보편화된 데이터베이스 관리 시스템
 
76. DBMS(DataBase Management System) 개념
 ㄴ 데이터 관리의 복잡성을 해결하는 동시에, 데이터 추가, 변경, 검색, 삭제 및 백업, 복구, 보안 등의 기능을 지원하는 소프트웨어
 ㄴ 저장되는 정보는 텍스트, 이미지, 음악 파일, 지도 데이터 등 매우 다양하며, SNS의 발달과 빅 데이터의 폭 넓은 활용으로 인해 데이터의 종류와 양은 급격히 증가 중이다.

77. DBMS 유형: 키컬도그
 ㄴ 키-값(Key-Value) DBMS: 키 기반 Get/Put/Delete 제공, 메모리 기반에서 성능 우선 시스템 및 빅데이터 처리 가능. Unique한 키에 하나의 값을 가지고 있는 형태 ex) Redis, DynamoDB
 ㄴ 컬럼 기반 데이터 저장: Key 안에(Column, Value) 조합으로 된 여러 개의 필드를 가짐. 테이블 기반, 조인 미지원, 컬럼 기반으로 구글의 Bigtable 기반으로 구현 ex)HBase, Cassandra
 ㄴ 문서 저장: 값의 데이터 타입이 문서라는 타입을 사용. 문서 타입은 XML, JSON과 같이 구조화된 데이터 타입으로, 복잡한 계층 구조 표현 가능
 ㄴ 그래프: 시맨틱 웹과 온톨로지 분야에서 활용되는 그래프로 데이터를 표현하는 DBMS, 노드와 엣지로 특징되는 요소 특화, 노드 간 관계를 구조화하여 저장 ex) Neo4j, AllegroGraph

78. DBMS 특징: 데이터 무결성, 일관성, 회복성, 보안성, 효율성

79. 빅데이터: 시스템, 서비스, 조직(회사) 등에서 주어진 비용, 시간 내에 처리 가능한 데이터 범위를 넘어서는 수십 페타바이트 크기의 비정형 데이터이다.

80. 빅데이터 특성
 ㄴ 데이터의 양(Volume): 페타바이트 수준의 대규모 데이터, 빅데이터 분석 규모에 관련된 특성, 디지털 정보량이 기하급수적으로 폭증하는 것을 의미 
 ㄴ 데이터의 다양성(Variety): 정형, 비정형, 반정형의 다양한 데이터, 빅데이터 자원 유형에 관련된 특성, 로그, 소셜, 위치 등 데이터 유형이 다양해지는 것을 의미
 ㄴ 데이터의 속도(Velocity): 빠르게 증가하고 수집되며, 처리되는 데이터, 빅데이터 수집, 분석, 활용 속도와 관련된 특성, 가치있는 정보 활용을 위해 실시간 분석이 중요해지는 것을 의미

81. 빅데이터 수집, 저장, 처리 기술
 ㄴ 비정형/반정형 데이터 수집: 내외부 정제되지 않은 데이터를 확보, 이를 통해 필요 정보를 추출하여 활용하기 위해서 효과적으로 수집 및 전송하는 기술 ex) 척와, 플럼, 스크라이브
 ㄴ 정형 데이터 수집: 내외부 정제된 대용량 데이터의 수집 및 전송 기술 ex) ETL, FTP, 스쿱, 하이호
 ㄴ 분산데이터 저장/처리: 대용량 파일의 효과적인 분산 저장 및 분산 처리 기술 ex) HDFS, 맵 리듀스
 ㄴ 분산데이터 베이스: HDFS의 칼럼 기반 데이터베이스로 실시간 랜덤 조회 및 업데이트가 가능한 기술 ex) HBase

82. 빅데이터 분석, 실시간 처리 및 시각화를 위한 주요기술
 ㄴ 빅데이터 분석: 데이터 가공과 분류, 클러스터링, 패턴 분석을 처리하는 기술, 데이터 가공을 위한 대표적인 솔루션에는 피그, 하이브가 있고, 데이터 마이닝을 위한 대표적인 솔루션에는 머하웃가 있음
 ㄴ 실시간처리: 하둡 기반의 실시간 SQL질의 처리와 요청된 작업을 최적화하기 위한 워크플로우 관리 기술, 실시간 SQL 질의를 위한 대표적인 솔루션에는 임팔라가 있고, 워크플로우 관리를 위한 대표적인 솔루션은 우지가 있음
 ㄴ 분산 코디네이션: 분산 환경에서 서버들 간에 상호조정이 필요한 다양한 서비스를 분산 및 동시처리 제공 기술, 대표적인 솔루션은 주키퍼가 있음
 ㄴ 분석 및 시각화: 빅데이터 분석 기술을 통해 분석된 데이터의 의미와 가치를 시각적으로 표현하기 위한 기술, 대표적인 솔루션은 R이 있음

83. NoSQL(Not Only SQL) 개념: 전통적인 RDBMS와 다른 DBMS를 지칭하기 위한 용어로 데이터 저장에 고정된 테이블 스키마가 필요하지 않고 조인(Join) 연산을 사용할 수 없으며, 수평적으로 확장이 가능한 DBMS이다.

84. NoSQL 특성
 ㄴ Basically Available: 언제든지 데이터는 접근할 수 있어야 하는 속성, 분산 시스템이기 때문에 항상 가용성 중시
 ㄴ Soft-State: 노드의 상태는 내부에 포함된 정보에 의해 경정되는 것이 아니라 외부에서 전송된 정보를 통해 결정되는 속성, 특정 시점에서는 데이터의 일관성이 보장되지 않음
 ㄴ Eventually Consistency: 일정 시간이 지나면 데이터의 일관성이 유지되는 속성, 일관성을 중시하고 지향

85. 데이터 마이닝: 대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 기술, 대규모 데이터에서 의미 있는 패턴을 파악하거나 예측해서 의사결정에 활용하는 기법이다, 데이터의 숨겨진 정보를 찾아내어 이를 기반으로 서비스와 제품에 도입하는 과정, 통계분석은 가설이나 가정에 따른 분석, 검증을 하지만 데이터 마이닝은 수리 알고리즘을 활용하여 대규모 데이터에서 의미 있는 정보를 찾아낸다.

86. 데이터 마이닝 절차
 ㄴ 1단계: 목적 설정, 2단계: 데이터 준비, 3단계: 가공, 4단계: 마이닝 기법 적용, 5단계: 정보 검증

87. 데이터마이닝 주요 기법: 분연연데
 ㄴ 분류 규칙: 과거 데이터로부터 특성을 찾아내어 분류모형을 만들어 이를 토대로 새로운 레코드의 결과 값을 예측하는 기
 ㄴ 연관 규칙: 데이터 안에 존재하는 항목들 간의 종속 관계를 찾아내는 기법
 ㄴ 연속 규칙: 연관 규칙에 시간 관련 정보가 포함된 형태의 기법
 ㄴ 데이터 군집화: 대상 레코드들을 유사한 특성을 지닌 몇 개의 소그룹으로 분할하는 작업으로 작업의 특성이 분류규칙과 유사, 정보가 없는 상태에서 데이터를 분류하는 기법.

88. 연계 요구사항 분석의 개념: 서로 다른 두 시스템, 장치, 소프트웨어를 이어주는 중계 역할을 하는 연계 시스템과 관련된 요구사항을 분석하는 과정이다. 사용자 인터뷰 및 면담을 통해 식별되고 시스템 구성도, 테이블 정의서, 코드 정의서 등을 참고한다.

89. 요구사항 분석 기법: 인체설델브(인터뷰, 체크리스트, 설문지, 델파이 기법, 브레인스토밍)

90. 요구사항 분석 참고문서: 코테응시(코드 정의서, 테이블 정의서, 응용 프로그램 구성도, 시스템 구성도)

91. 인터페이스 명세서 구성요소: 인최크시데(인터페이스 ID, 최대 처리 횟수, 데이터 크기(평균/최대), 시스템 정보, 데이터 정보)

92. 연계 요구사항 분석 절차: 시스템 현황 확인, 정의서 확인, 체크리스트 작성, 인터뷰 및 면담, 연계 요구사항 분석서 작성

93. 연계 시스템의 구성: 송신 시스템, 수신 시스템, 중계 서버

94. 연계 데이터 표준화: 인터페이스 시스템 사이에서 교환되는 데이터는 규격화된 표준 형식을 정의하여 사용하여야 한다, 인터페이스 설계 단계에서 송수신 시스템 사이에 전송되는 표준항목과 업무처리 데이터, 공통 코드 정보 등을 누락 없이 식별하고 인터페이스 명세서를 작성해야 한다. 
 ㄴ 인터페이스 데이터 공통부, 개별부, 종료부로 구성된다.

95. 연계 메커니즘: 응용 소프트웨어와 연계 대상 모듈 간의 데이터 연계 시 요구사항을 고려한 연계방법과 주기를 설계하기 위한 메커니즘이다.

96. 연계 매커니즘 기능
 ㄴ 데이터를 생성하여 전송하는 송신 시스템과 송신 데이터를 수신하여 DB에 반영하는 수신 시스템으로 구성된다.
 ㄴ 송신 시스템은 운영 데이터베이스, 애플리케이션으로부터 연꼐 데이터를 연계 테이블 또는 파일로 생성하여 송신한다.
 ㄴ 수신 시스템은 송신 시스템으로부터 전송된 데이터를 변환 처리 후 데이터베이스에 반영한다.

97. 연계 방식
 ㄴ 직접연계 장점: 연계 및 통합 구현이 단순하며 용이, 개발 소요 비용 및 기간이 짧음, 중간 매개체가 없으므로 데이터 연계 처리 성능이 대체로 좋음
 ㄴ 직접연계 단점: 시스템 간 결합도가 높아 변경에 민감, 암복호화 처리 불가, 연계 및 통합 가능한 시스템 환경이 제한적
 ㄴ 간접연계 장점: 서로 상이한 네트워크, 프로토콜 연계 및 통합 가능, 인터페이스 변경시에도 장애나 오류 없이 서비스 가능, 보안이나 업무 처리 로직을 자유롭게 반영 가능
 ㄴ 간접연계 단점: 연계 아키텍처 및 메커니즘이 복잡해 성능 저하 요소 존재, 개발 및 적용을 위한 테스트 기간이 상대적 장기간 소요

98. 주요 연계 기술
 ㄴ 직접 - DB링크, DB연결, API/Open API, JDBC, 하이퍼링크
 ㄴ 간접 - 연계솔루션(EAI), Web Service/ESB, 소켓

 ㄴ DB 링크(Link): 데이터베이스에서 제공하는 DB 링크 객체를 이용, 수신 시스템에서 DB 링크를 생성하고 송신 시스템에서 해당 DB 링크를 직접 참조하는 방식
 ㄴ DB 연결(connection): 수신 시스템의 WAS(Web Application Server)에서 송신 시스템 DB로 연결하는 DB 커넥션 풀을 생성하고 연계 프로그램에서 해당 DB 커넥션 풀 명을 이용하여 연결
 ㄴ API/Open API: 송신 시스템의 DB에서 데이터를 읽어서 제공하는 애플리케이션 프로그래밍 인터페이스 프로그램
 ㄴ JDBC: 수신 시스템의 프로그램에서 JDBC 드라이버를 이용하여 송신 시스템 DB와 연결
 ㄴ 하이퍼링크: 현재 페이지에서 다른 부분으로 가거나, 전혀 다른 페이지로 이동하게 해주는 속성

 ㄴ 연계 솔루션: 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간의 정보 전달, 연계, 통합을 가능하게 해주는 솔루션 
 ㄴ Web Service/ ESB:  웹서비스가 설명된 WSDL과 SOAP 프로토콜을 이용한 시스템 간 연계
 ㄴ 소켓: 소켓을 생성하여 포트를 할당하고, 클라이언트의 요청을 연결하여 통신

99. EAI(Enterprise Application Integration)
 ㄴ EAI는 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계, 통합이 가능하도록 해주는 솔루션이다.
 ㄴ EAI를 사용함으로써 각 비즈니스 간 통합 및 연계성을 증대시켜 효율성을 높여 줄 수 있으며 각 시스템 간의 확장성을 높여줄 수 있다. 

100. EAI 구성요소: EAI 플랫폼, 어댑터, 브로커, 메시지 큐, 비즈니스 워크플로우

101. EAI 구축 유형: 포허메하(포인트 투 포인트, 허브 앤 스포크, 메세지 버스, 하이브리드)
 ㄴ 포인트 투 포인트: 기초적인 애플리케이션 통합방법, 1:1 단순 통합방법, 솔루션을 구매하지 않고 개발자 간 커뮤니케이션을 통해서도 통합가능
 ㄴ 허브 앤 스포크: 단일한 접점의 허브 시스템을 통하여 데이터를 전송하는 중앙 집중식 방식, 허브 장애 시 전체 장애 발생
 ㄴ 메시지 버스: 애플리케이션 사이 미들웨어를 두어 연계하는 미들웨어 통합 방식, 뛰어난 확장성과 대용량 데이터 처리 가능
 ㄴ 하이브리드: 그룹 내는 허브 앤 스포크 방식을 사용하고, 그룹 간에는 메시지 버스 방식을 사용한 통합 방식, 그룹 내 환경에 맞는 작업 가능

102. ESB(Enterprise Service Bus) 
 ㄴ 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간을 하나의 시스템으로 관리 운영할 수 있도록 서비스 중심의 통합을 지향하는 아키텍처, ESB는 미들웨어를 중심으로 각각 프로토콜이 호환할 수 있도록 애플리케이션의 통합을 느슨한 결합 방식으로 지원하는 방식
 ㄴ 느슨한 결합: 특정 서비스를 변경하더라도 연결된 다른 서비스에는 영향을 주지 않는 유연한 구조라는 의미
 
103. ESB 특징: 서비스들을 컴포넌트화된 논리적 집합으로 묶는 핵심 미들웨어이며, 비즈니스 프로세스 환경에 맞게 설계 및 전개할 수 있는 아키텍처 패턴이다. 버스방식으로 확장성, 유연한 아키텍처 구성이 가능하다.

104. 웹 서비스 개념: 네트워크에 분산된 정보를 서비스 형태로 개방하여 표준화된 방식으로 공유하는 기술로써 서비스 지향 아키텍처 개념을 실현하는 대표적인 기술이다.

105. 웹 서비스 유형: SOAP(Simple Object Access Protocol), WSDL(Web Service Description Language), UDDI(Universal Description Discovery and Integration)
 ㄴ SOAP: HTTP, HTTPS, SMTP 등을 사용하여 XML 기반의 메시지를 네트워크 상태에서 교환하는 프로토콜, HTTP 프로토콜 상에 SOAP Envelope, Header, Body 등이 추가된 XML 문서로 기본적인 송수신은 HTTP로 수행한다, SOAP는 보통의 경우 원격 프로시저 호출(RPC)을 하는 메시지 패턴을 사용한다, 네트워크 노드(클라이언트)에서 다른 쪽 노드(서버)로 메시지를 요청하고, 서버는 메시지를 즉시 응답하게 된다.
 
 ㄴ WSDL:  웹 서비스명, 제공 위치, 메시지 포맷, 프로토콜 정보 등 웹 서비스에 대한 상세 정보가 기술된 XML 형식으로 구현되어 있는 언어다. SOAP와 XML 스키마와 결합하여 인터넷 상에 웹 서비스를 제공하기 위해 사용되기도 한다.

 ㄴ UDDI: 웹 서비스에 대한 정보인 WSDL을 등록하고 검색하기 위한 저장소로 공개적으로 접근, 검색이 가능한 레지스트리이자 표준이다. 서비스 제공자는 UDDI라는 서비스 소비자에게 이미 알려진 온라인 저장소에 그들이 제공하는 서비스 목록들을 저장하게 되고, 서비스 소비자들은 그 저장소에 접근함으로써 원하는 서비스들의 목록을 찾을 수 있게 된다. 알려진 송수신 시스템의 통합 구현에서는 서비스의 공개 및 검색과정이 필요 없으므로 UDDI를 구축하지 않는다.

106. 시스템 인터페이스 설계서: 시스템 인터페이스 설계서는 이 기종 시스템 및 컴포넌트 간 데이터 교환 및 처리를 위해 각 시스템의 교환되는 데이터, 업무, 송수신 주체 등이 정의된 문서이다.

107. 상세 기능별 인터페이스 명세서: 데이터 송수신 시스템 간의 데이터 저장과 속성 등의 상세 내역을 포함한다.
 ㄴ 주요항목: 아명오개 전후파반(인터페이스 ID, 인터페이스 명, 오퍼레이션 명, 오퍼레이션 개요, 사전조건, 사후조건, 파라미터, 반환 값)

108. 외부, 내무 모듈 연계 방법(EAI, ESB): 기업 시스템이나 공공 서비스를 위한 시스템에서 인터페이스를 위해 외부 및 내부 모듈을 연계하는 대표적인 방법은 EAI와 ESB가 있다.

109. 인터페이스 데이터 표준 확인: 데이터 표준 확인은 상호 연계하고자 하는 시스템 간 인터페이스가 되어야 할 범위의 데이터 형식과 표준을 정의하는 활동이다. 데이터 전송 시 데이터 형태가 동일하면 그대로 전송, 동일하지 않으면 변환하여 전송

110. 인터페이스 기능 구현 정의: 개발하고자 하는 응용 소프트웨어와 연계 대상 모듈 간의 세부 설계서를 확인하여 일관되고 정형화된 인터페이스 기능을 구현할 수 있다.

111. 컴포넌트 명세서: 컴포넌트의 개요, 내부 클래스의 동작, 인터페이스를 통해 외부와 통신하는 명세를 정의
 ㄴ 컴포넌트란? 특정한 기능을 수행하기 위해 독립적으로 개발되어 보급되는, 잘 정의된 인터페이스를 가지며 다른 부품과 조립되어 응용 시스템을 구축하기 위해 사용되는 소프트웨어 프로그램.

112. 인터페이스 명세서: 인터페이스 명세서는 컴포넌트 명세서에 명시된 인터페이스 클래스의 세부적인 조건 및 기능을 명시한 명세서이다. 인터페이스 명칭, 사전/사후 조건, 인터페이스 데이터 및 인터페이스 완료 후 성공 여부를 반환바는 반환 값 등이 정의되어 있다.

113. 제이슨(JSON): 비동기 브라우저/서버 통신(AJAX)을 위해 "속성-값 쌍", "키-값 쌍"으로 이루어진 데이터 오브젝트를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷이다.

114. JSON 특징
 ㄴ AJAX(Asynchronous JavaScript and XML)에서 많이 사용되고 XML(eXtensible Markup Language)을 대체하는 주요 데이터 포맷이다.
 ㄴ 언어 독립형 데이터 포맷으로 다양한 데이터 프로그래밍 언어에서 사용된다.
 ㄴ 사람이 읽고 쓰기에 용이하며, 기계가 분석하고 생성하기에 용이하다.

115. JSON 표현 자료형
 ㄴ 숫자: 기본 자료형의 수는 정수, 실수(고정 소수점), 실수(부동 소수점)로 표현
 ㄴ 문자열: 항상 큰 따옴표로 묶어야 하며, 그 안에는 유니코드 문자들이 나열
 ㄴ 배열: 배열은 대괄호로 표시. 배열의 각 요소는 기본 자료형이거나 배열, 객체임. 각 요소들은 쉼표로 구별되고 각 요소가 나타나는 순서에 의미가 있음.
 ㄴ 객체: 객체는 이름/값 쌍의 집합으로, 중괄호를 사용, 이름은 문자열이기 떄문에 반드시 따옴표를 하며, 값은 기본 자료형, 각 쌍들은 쉼표로 구별되고, 각 쌍이 나오는 순서는 의미 없음.

116. JSON 문법
 ㄴ 구조: name/value 쌍으로 구성. {로 시작하고 }로 끝남, 배열은 []로 나타냄, 각각의 이름은 '와', '로' 구분된 name/value 쌍의 형식을 다룸

117. JSON 장점/단점
 ㄴ 장점: XML보다 가볍고 빠름, 자료 종류에 큰 제한이 없음, XML은 모두 string이고, JSON은 string, number, array, boolean 등 다양, Javascript 코드 안에서 JSON 객체에 접근 쉬움.
 ㄴ 단점: 태그가 없어서 가독성이 떨어짐, DTD 같은 것이 없기 때문에 데이터 형식이 틀렸을 경우 체크가 쉽지 않음

118. XML(Extensible Markup Language)
 ㄴ HTML의 단점을 보완한 인터넷 언어로, SGML의 복잡한 단점을 개선한 특수한 목적을 갖는 마크업 언어

119. XML 특징
 ㄴ XML은 송수신 시스템 간 데이터 연계의 편의성을 위해서 전소오디는 데이터 구조를 동일한 형태로 정의한다. 
 ㄴ 인간과 기계가 모두 이해할 수 있는 텍스트 형태로 마크업 포맷을 정의하기 위한 메타언어이다.
 ㄴ 사용자가 직접 문서의 태그를 정의할 수 있으며, 다른 사용자가 정의한 태그를 사용할 수 있다.

120. AJAX(Asynchronous Javascript And XML)
 ㄴ AJAX는 자바스크립트를 사용하여 웹 서버와 클라이언트 간 비동기적으로 XML 데이터를 교환하고 조작하기 위한 웹 기술이다.
 ㄴ 브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 로드하지 않고 필요한 일부 페이지의 데이터만을 로드하는 기법이다. 
 ㄴ 하이퍼텍스트 표기 언어(HTML)만으로는 어려운 다양한 작업을 웹 페이지에서 구현해서 이용자가 웹 페이지와 자유롭게 상호 작용할 수 있도록 구현하는 기법이다.

121. AJAX 주요기술
 ㄴ XMLHttpRequest: 웹 브라우저와 웹 서버 간에 메서드가 데이터를 전송하는 객체 폼의 API, 비동기 통신을 담당하는 자바스크립트 객체
 ㄴ Javascript: 객체기반 스크립트 프로그래밍 언어, 웹 브라우저 내에서 주로 사용하며, 다른 응용 프로그램의 내장 객체에도 접근할 수 있는 기능 소유
 ㄴ XML: HTML의 단점을 보완한 인터넷 언어로서 SGML의 복잡한 단점을 개선한 특수한 목적을 갖는 마크업 언어
 ㄴ DOM(Document Object Model): XML문서를 트리 구조의 형태로 접근할 수 있게 해주는 API, 플랫폼/언어 중립적으로 구조화된 문서를 표현하는 객체지향 모델
 ㄴ XSLT(Extensible Stylesheet Language Transformations): XML문서를 다른 XML 문서로 변환하는데 사용하는 XML 기반 언어
 ㄴ HTML(HyperTextMarkupLanguage): 인터넷 웹 문서를 표현하는 표준화된 마크업 언어
 ㄴ CSS(Cascading Style Sheets): 마크업 언어가 실제 표시되는 방법을 기술하는 언어, 운영체제나 사용 프로그램과 관계없이 글자 크기, 글자체, 줄 간격, 색상 등을 자유롭게 선택할 수 있는 스타일 시트

122. REST(Representational State Transfer) 
 ㄴ REST는 웹과 같은 분산 하이퍼미디어 환경에서 자원의 존재/상태 정보를 표준화된 HTTP 메서드로 주고받는 웹 아키텍처이다.
 ㄴ 기본형태: 리소스, 메서드, 메시지 3가지 요소로 구성된다.
 ㄴ 메서드: POST, GET, PUT, DELETE

123. 인터페이스 구현 방식에는 데이터 통신을 사용하는 인터페이스 구현 방식과 인터페이스 개체를 사용하는 구현 방식이 있다.
 
124. 데이터 통신을 사용하는 인터페이스 구현
 ㄴ 인터페이스 객체 생성 구현: 인터페이스 객체를 생성하기 위해서 데이터베이스에 있는 정보를 SQL을 통하여 선택한 후 이를 제이슨(JSON)으로 생성
 ㄴ 인터페이스 객체 전송 후 전송 결과를 수신 측에서 반환 받도록 구현: 송신 측에서 제이슨으로 작성된 인터페이스 객체를 AJAX 기술을 이용하여 수신 측에 송신, 수신 측에서는 제이슨 인터페이스 객체를 수신받고 이를 파싱 후 처리, 처리 결괏값은 송신 측에 True/False 값을 전달하여 인터페이스 성공 여부를 전달

125. 인터페이스 개체를 사용하는 인터페이스 구현
 ㄴ 송신 시스템의 인터페이스 테이블: 송신 관련 정보를 관리하기 위한 항목과 송신 시스템에서 필요한 항목 구현. 인터페이스 이벤트 발생 시 인터페이스 테이블에 내용이 기록되도록 구현, 데이터 전송을 위해서 DB 커넥션이 수신 측 인터페이스 테이블과 연계되도록 구현, 프로시저, 트리거, 배치 작업 등의 방법을 통해서 수신 테이블로 데이터를 전송하도록 구현
 ㄴ 수신 시스템의 인터페이스 테이블: 수신 관련 정보를 관리하기 위한 항목과 수신 시스템에서 필요한 항목 구현, 인터페이스 데이터를 읽은 후 산전에 정의된 데이터 트랜잭션을 진행할 수 있도록 구현, 오류 발생 시 오류 코드 칼럼에 정의된 오류 코드와 내용을 입력하도록 구현

126. 스니핑: 스니핑이란 공격 대상에게 직접 공격을 하지 않고 데이터만 몰래 들여다보는 수동적 공격기법이다.

127. 시큐어 코딩 가이드 적용: 입보시 에코캡아(입력데이터 검증 및 표현, 보안 기능, 시간 및 상태, 에러 처리, 코드 오류, 캡슐화, API 오용)
 
128. 데이터 베이스 암호화 알고리즘: 대비해(대칭 키 암호화 알고리즘/비대칭/해시)
 ㄴ 대칭 키 암호화 알고리즘: 암호화 알고리즘의 한 종류로, 암복호화에 같은 암호 키를 쓰는 알고리즘을 의미 ex) ARIA 128/192/256, SEED
 ㄴ 비대칭 키 암호화 알고리즘: 공기키는 누구나 알 수 있지만, 그에 대응하는 비밀키는 키의 소유자만이 알 수 있도록 공개키와 비밀키를 사용하는 알고리즘 ex) RSA, ECC, ECDSA
 ㄴ 해시 암호화 알고리즘: 해시 값으로 원래 입력값을 찾아낼 수 없는 일방향성의 특성을 가진 알고리즘 ex) SHA-256/384/512, HAS-160

129. 데이터 베이스 암호화 기법: 애플티하(API, Plug-in, TDE, Hybrid)
 ㄴ API 방식: 애플리케이션 레벨에서 암호모듈(API)을 적용하는 애플리케이션 수정 방식, 애플리케이션 서버에 암복호화, 정책 관리, 키 관리 등의 부하 발생
 ㄴ Plug-in 방식: 암복호화 모듈이 DB 서버에 설치된 방식, DB 서버에 암 복호화, 정책관리, 키 관리 등의 부하 발생
 ㄴ TDE 방식: DB 서버의 DBMS 커널이 자체적으로 암복호화 기능을 수행하는 방식, 내장되어 있는 암호화 기능 TDE(Transparent Data Encryption)을 이용
 ㄴ Hybrid 방식: API방식과 Plug-in 방식을 결합하는 방식, DB 서버와 애플리케이션 서버로 부하 분산

130. 중요 인터페이스 데이터의 암호화 전송
 ㄴ IPSec(IP Security): IP 계층(3계층)에서 무결성과 인증을 보장하는 인증 헤더와 기밀성을 보장하는 암호화를 이용하여 양 종단 간 구간에 보안 서비스를 제공하는 터널링 프로토콜, 동작모드는 전송 모드와 터널 모드가 있음
 ㄴ SSL/TLS: 전송계층과 응용계층 사이에서 클라이언트와 서버 간의 웹 데이터 암호화(기밀성), 상호 인증 및 전송 시 데이터 무결성을 보장하는 보안 프로토콜. IP Sec와는 다르게 클라이언트와 서버 간에 상호인증, 암호 방식에 대해 협상을 거치는 특징, 대칭, 공개키, 일방향 해시, 메시지 인증코드 등 특정 암호 기술에 의존하지 않고 다양한 암호 기술 적용, Https://~ 표시형식과 443 포트 이용
 ㄴ S-HTTP(Secure Hypertext Transfer Protocol): 웹상에서 네트워크 트래픽을 암호화하는 주요 방법 중 하나로서 클라이언트와 서버 간에 전송되는 모든 메시지를 각각 암호화하여 전송

131. 인터페이스 구현 검증 도구 개념
 ㄴ 구현된 인터페이스의 동작을 검증하기 위해 인터페이스 구현 및 감시 도구를 통해서 인터페이스 동작 상태를 검증하고 모니터링 할 수 있다.
 ㄴ 기능 단위로 테스트 하는 단위 테스트와 전체 인터페이스 흐름을 확인할 수 있는 시나리오를 통한 통합 테스트가 있다. 
 ㄴ 인터페이스 구현 검증 도구들을 통해서 테스트의 효율성을 높일 수 있다.

132. 인터페이스 구현 도구 종류: 엑스피 엔셀웨
 ㄴ xUnit: 자바, C++, .Net 등 다양한 언어를 지원하는 단위테스트 프레임워크, 소프트웨어의 함수나 클래스 같은 서로 다른 구성 원소를 테스트할 수 있게 해주는 도구
 ㄴ STAF: 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크. 각 테스트 대상 분산 환경에 데몬을 사용하여 테스트 대상 프로그램을 통해 테스트를 수행하고, 통합하며 자동화하는 검증 도구
 ㄴ FitNesse: 웹 기반 테스트 케이스 설계/실행/결과 확인 등을 지원하는 테스트 프레임워크, 사용자가 테스트 케이스 테이블을 작성하면 빠르고 편하게 자동으로 원하는 값에 대해 테스트를 할 수 있는 장점이 있음.
 ㄴ NTAF: FitNesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN의 테스트 자동화 프레임워크
 ㄴ Selenium: 다양한 브라우저 지원 및 개발언어를 지원하는 웹 애플리케이션 테스트 프레임워크, 테스트 스크립트 언어를 학습할 필요 없이 기능 테스트를 마들기 위한 도구를 제공
 ㄴ water: 루비 기반 웹 애플리케이션 테스트 프레임워크, 모든 언어 기반의 웹 애플리케이션 테스트와 브라우저 호환성 테스팅 가능

133. 인터페이스 감시 도구: 애플리케이션 모니터링 툴(APM: Application Performance Management)을 사용하여 동작 상태 감시
 ㄴ 데이터베이스, 웹 애플리케이션의 트랜잭션과 벼숫값, 호출 함수, 로그 및 시스템 부하 등 종합적인 정보를 조회하고, 커넥션 풀(Connection Pools) 등 지속적인 모니터링이 필요한 자원을 효과적으로 관리할 수 있다.

134. 감시 도구 종류
 ㄴ 스카우터: 애플리케이션에 대한 모니터링 및 DB Agent를 통해 오픈 소스 DB 모니터링 기능, 인터페이스 감시 기능을 제공
 ㄴ 제니퍼: 애플리케이션의 개발부터 테스트, 오픈, 운영, 안정화까지 전 생애주기 단계 동안 성능을 모니터링 하고 분석해주는 APM 소프트웨어

135. 데이터타입: 프로그래밍 언어에서 실수치, 정수 자료형과 같은 여러 종류의 데이터를 식별하는 형태이다. 메모리 공간을 효율적으로 사용하고 2진수 데이터를 다양한 형태로 사용하기 위해 존재한다.
 ㄴ 불린, 문자, 문자열, 정수, 부동 소수점

136. 변수: 저장하고자 하는 어떤 값이 있을 때, 그 값을 주시억장치에 기억하기 위한 공간이다. 자료형과 변수명을 작성하여 변수를 생성하는 과정이다. C, C++, 자바에서는 변수 선언을 하고, 파이썬에서는 별도로 변수 선언을 하지 않는다.

137. 배열: 같은 타입의 변수들로 이루어진 집합
 
138. 포인터: 변수의 주솟값을 저장하는 공간이다.
 ㄴ 포인터 선언: 데이터타입*포인터변수명 =&변수명
 ㄴ 데이터 타입 뒤에 *을 붙이면 주소를 저장하는 포인터 변수라는 의미이고, 일반 변수명에 &를 붙이면 해당 변수명의 주솟값이다.
 ㄴ int형 변수를 가리키는 포인터 변수 선언 시 int*을, char형은 char*, float는 float*을 사용한다.
 ㄴ 주소에 해당하는 값을 가리킬 때에는 *을 사용한다.

139. 자바 자료형
 ㄴ HashSet: 중복된 원소를 허용하지 않는 집합의 성질을 가진 자료형이며, 클래스이다. 순서는 중요하지 않음.
 ㄴ ArrayList: List의 하위 클래스로 크기가 가변적으로 변하는 선형리스트의 성질을 가지고 있는 자료형이며 클래스이다., 순서는 중요함, 중복도 허용
 ㄴ HashMap: 키와 값으로 구성된 객체를 저장하는 구조로 되어 있는 자료구조를 구현한 자료형이며 클래스이다.
 ㄴ LinkedList: 데이터를 저장하는 노드가 이전 노드와 다음 노드의 상태를 알고 있는 링크드 리스트 자료구조를 구현한 클래스

140. 파이썬 자료형
 ㄴ 세트형: 중복된 원소를 허용하지 않는 집합의 성질을 가지고 있는 자료구조 {1,  2, 3}...
 ㄴ 리스트형: 크기가 가변적으로 변하는 선형리스트의 성질을 가지고 있는 자료구조 [1, 2, 3]
 ㄴ 튜플형: 초기에 선언된 값에서 값을 생성, 삭제, 수정이 불가능한 형태의 자료구조( 1, 2, 3)
 ㄴ 딕셔너리형: 키와 값으로 구성된 객체를 저장하는 구조로 되어 있는 자료구조{ 'A':1, 'B':2}

141. 식별자(Identifier) 개념: 식별자는 변수, 상수, 함수 등 서로 구분하기 위해서 사용되는 이름.
 ㄴ 식별자 명명규칙: 영어 대/소문자, 숫자, 밑줄, 달러의 사용 가능, 첫자리에는 숫자 불가, 변수 이름 중간 공백 불가, 예약어의 경우 변수 사용 불가
 
142. 식별자 표기법
 ㄴ 카멜 표기법: 식별자 표기 시에 여러 단어가 이어지면 첫 단어 시작만 소문자로 표시하고, 각 단어의 첫 글자는 대문자로 지정하는 표기법 ex) inputFunction
 ㄴ 파스칼 표기법: 식별자 표기 시에 여러 단어가 이어지면 각 단어의 첫 글자는 대문자로 지정하는 표기법 ex) InputFunction
 ㄴ 스네이크 표기법: 식별자 표기 시에 여러 단어가 ㅣㅇ어지면 단어 사이에 언더바를 넣는 표기법 ex) input_function
 ㄴ 헝가리안 표기법: 식별자 표기 시 두어에 자료형을 붙이는 표기법, int형일 경우 n, char형일 경우 c, 문자열일 경우 sz를 붙임 ex) nScore -> int형을 말함

143. 클래스(Class)
 ㄴ 클래스는 객체지향 프로그래밍(OOP: Object-Oriented Programming)에서 특정 객체를 생성하기 위해 변수와 메서드를 정의하는 틀이다.
 ㄴ 접근제어자: 지정된 클래스, 변수, 메서드를 외부(같은 패키지이거나 다른 패키지)에서 접근할 수 있도록 권한을 설정하는 기능이다.
 
144. 접근 제어자 종류
 ㄴ public: 외부의 모든 클래스에서 접근이 가능한 접근 제어자
 ㄴ protected: 같은 패키지 내부에 있는 클래스, 하위 클래스(상속 받은 경우)에서 접근이 가능한 접근 제어자, 자기 자신과 상속받은 하위 클래스 둘 다 접근이 가능한 접근 제어자
 ㄴ default: 접근 제어자를 명시하지 않은 경우로 같은 패키지 내부에 있는 클래스에서 접근이 가능한 접근 제어자, 자바에서만 존재
 ㄴ private: 같은 클래스 내에서만 접근이 가능한 접근 제어자

145. 클래스 사용
 ㄴ 클래스는 변수와 메서드(함수) 형태로 구성되어 있다.
 ㄴ 클래스에서 변수는 변수 선언과 동일하고, 메서드는 사용자 정의함수와 문법이 동일하다.
 ㄴ 파이썬은 별도로 변수 선언을 하지 않기 때문에 메서드 형태로 구성되어 있다.
 
C++ 
class 클래스명{
private:
    변수_타입 변수명;
public:
    반환_데이터 타입 메서드명(){
        명령어;
        Return 반환값;
    }
}

146. 자신 클래스 참조
 this 포인터: this 포인터는 현재 객체를 가리키는 포인터이다. C++ JAVA에서 사용하는 것으로 클래스 내부의 변수와 함수를 가리킬 수 있다.
 self: 현재 객체를 가리키는 포인터이다. 파이썬에서 사용하는 것으로 클래스 내부의 변수와 함수를 가리킬 수 있다.

147. 클래스 선언
 ㄴ 클래스를 일반변수로 선언한 경우 선언함과 동시에 생성자가 호출되고, 일반 변수로 선언한 곳에서 함수가 종료되면 소멸자가 호출된다.
 ㄴ.클래스를 포인터 변수로 선언한 경우 new 키워드를 이용해 선언함과 동시에 생성자가 호출되고, delete 키워드를 이용해 해당 변수의 저장 공간을 삭제하면 소멸자가 호출된다.

148. 생성자
 ㄴ 생성자는 해당 클래스의 객체가 생성될 때 자동으로 호출되는 특수한 종류이 메서드이다. 생성자는 일반적으로 클래스의 멤버 변수를 초기화하거나 클래스를 사용하는데 필요한 설정이 필요한 경우 사용한다.
 ㄴ C++, 자바에서는 클래스명과 동일한 메서드명을 가지고, 반환 값이 없다.
 ㄴ 파이썬에서는 __init__이라는 메서드명을 사용하고, 첫 번재 매개변수로 self를 적어주며, 반환 값이 없다.

149. 소멸자
 ㄴ 소멸자는 객체의 수명이 끝났을 때 객체를 제거하기 위한 목적으로 사용되는 메서드이다. 
 ㄴ C++에서는 클래스명과 동일한 메서드명을 가지고 ~기호를 사용하며, 입력값과 반환값이 없다.
 ㄴ 자바에서는ㄴ finalize라는 메서드를 사용하며, 반환 값이 없다.
 ㄴ 파이썬에서는 __del__이라는 메서드명을 사용하고, 첫 번째 매개변수에 self를 적어주며, 반환 값이 없다.

150. 상속
 ㄴ 상속은 어떤 객체가 있을 때 그 객체의 변수와 메서드를 다른 객체가 물려받는 기능이다.

151. 오버로딩(Overloading): 동일 이름의 메서드를 매개변수만 다르게 하여 여러개 정의할 수 있는 기능이다. 파이썬에서는 오버로딩 기능 지원하지 않음

152. 오버라이딩: 하위 클래스에서 상위 클래스 메서드를 재정의할 수 있는 기능이다. C++에서는 virtual 키워드가 있어야 오버라이딩이 가능하다.

153. 추상 클래스: 추상 클래스는 미구현 추상 메서드를 한 개 이상 가지며, 자식 클래스에서 해당 추상 메서드를 반드시 구현하도록 강제하는 기능이다.

154. 인터페이스
 ㄴ 자바의 다형성을 극대화하여 개발코드 수정을 줄이고 프로그램 유지 보수성을 높이기 위한 문법이다.(일종의 추상 클래스)
 ㄴ 오직 추상 메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 다른 어떠한 요소도 허용하지 않는다. 
 ㄴ 구현된 것은 아무것도 없고, 밑 그림만 그려져 있는 '기본 설계도' 라고 할 수 있다.

155. 트랜잭션(Transaction)의 개념
  ㄴ 인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야하는 특성이자, 데이터베이스 시스템에서 하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위

156. 트랜잭션 특성: ACID(Atomicity/Consistency/Isolation/Durability)
 ㄴ 원자성: 분해가 불가능한 작업의 최소 단위, 연산 전체가 성공 또는 실패(All or Nothing), 하나라도 실패할 경우 전체가 취소되어야하는 특성
   ㄴ 주요기법: Commit/Rollback, 회복성 보장
 ㄴ 일관성: 트랜잭션이 실행 성공 후 항상 일관된 데이터베이스 상태를 보존해야하는 특성
   ㄴ 주요기법: 무결성 제약조건, 동시성 제어
 ㄴ 격리성: 트랜잭션 실행 중 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근 불가한 특성
   ㄴ 주요기법: Read Uncommited, Read Committed, Repeatable Read, Serializable
 ㄴ 영속성: 성공이 완료된 트랜잭션의 결과는 영속적으로 데이터베이스에 저장하는 특성
   ㄴ 주요기법: 회복기법

157. 트랜잭션의 상태 변화: 활부완실철(활동, 부분완료, 완료, 실패, 철회)
 ㄴ 활동 상태(Active): 초기상태, 트랜잭션이 실행 중일 때 가지는 상태
 ㄴ 부분 완료 상태(Partially Committed): 마지막 명령문이 실행 된 후에 가지는 상태
 ㄴ 완료 상태(Committed): 트랜잭션이 성공적으로 완료된 후 가지는 상태
 ㄴ 실패 상태(Failed): 정상적인 실행이 더 이상 진행될 수 없을 때 가지는 상태
 ㄴ 철회 상태(Aborted): 트랜잭션이 취소되고 데이터베이스가 트랜잭션 시작 전 상태로 환원된 상태

158. 트랜잭션 제어: 커롤체(커밋/롤백/체크포인트)
 ㄴ 트랜잭션 제어 언어는 TCL(Transaction Control Language)라고 하며, 트랜잭션의 결과를 허용하거나 취소하는 목적으로 사용되는 언어를 지칭한다.
 ㄴ 커밋: 트랜잭션 확정/트랜잭션을 메모리에 영구적으로 저장하는 명령어
 ㄴ 롤백: 트랜잭션 취소/트랜잭션 내역을 저장 무효화시키는 명령어
 ㄴ 체크포인트: 저장 시기 설정/롤백을 위한 시점을 지정하는 명령어

159. 병행제어(일관성 주요 기법)
 ㄴ 개념: 병행 제어는 다수 사용자 환경에서 여러 트랜잭션을 수행할 때, 데이터베이스 일관성 유지를 위해 상호작용을 제어하는 기법이다.
 ㄴ 목적: 데이터베이스의 공유를 최대화 한다. 시스템의 활용도를 최대화 한다. 데이터베이스 일관성을 유지. 사용자에 대한 응답시간을 최소화

160. 병행제어 미보장 시 문제점: 갱현모연
 ㄴ 갱신 손실(Lost Update): 먼저 실행된 트랜잭션의 결과를 나중에 실행된 트랜잭션이 덮어 쓸 때 발생하는 오류
 ㄴ 현황 파악오류(Dirty Read): 트랜잭션의 중간 수행 결과를 다른 트랜잭션이 참조하여 발생하는 오류
 ㄴ 모순성(Inconsistency): 두 트랜잭션이 동시에 실행되어 데이터베이스의 일관성이 결여되는 오류
 ㄴ 연쇄복귀(Cascading Rollback): 복수의 트랜잭션이 데이터 공유 시 특정 트랜잭션이 처리를 취소할 경우 트랜잭션이 처리한 곳의 부분을 취소하지 못하는 오류

161. 병행 제어 기법의 종류: 로낙타다
 ㄴ 로킹(Locking): 같은 자원을 액세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보장하는 직렬화 기법
 ㄴ 낙관적 검증: 트랜잭션이 어떠한 검증도 수행하지 않고 일단 트랜잭션을 수행하고, 트랜잭션 종료 시 검증을 수행하여 데이터베이스에 반영하는 기법
 ㄴ 타임 스탬프 순서(Time Stamp Ordering): 트랜잭션과 트랜잭셩이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 타임 스탬프(Time Stamp)를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법
 ㄴ 다중버전 동시성 제어(MVCC; Multi Version Concurrency Control): 트랜잭션의 타임스탬프와 접근하려는 데이터의 타임스탬프를 비교하여 직렬가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법

162. 로킹의 특징
 ㄴ 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있음
 ㄴ 로킹 단위가 작아지면 데이터베이스 공유도가 증가
 ㄴ 로킹 단위가 작아지면 로킹 오버헤드 증가
 ㄴ 한꺼번에 로킹할 수 있는 객체의 크기를 로킹 단위라고 함

163. 데이터베이스 고립화 수준(격리성 주요 기법)
 ㄴ 개념: 고립화 수준은 다른 트랜잭션이 현재의 데이터에 대한 무결성을 해치지 않기 위해 잠금을 설정하는 정도이다.
 ㄴ 종류
   가. Read Uncommitted: 한 트랜잭션에서 연산(갱신) 중인 데이터를 다른 트랜잭션이 읽는 것을 허용하는 수준, 연산 중인 데이터에 대한 연산을 불허
   나. Read Committed: 한 트랜잭션에서 연산(갱신)을 수행할 때, 연산 완료 시 까지 연산 대상 데이터에 대한 읽기를 제한하는 수준, 연산이 완료되어 커밋된 데이터는 다른 트랜잭션이 읽는 것을 허용
   다. Repeatable Read: 선행 트랜잭션이 특정 데이터를 읽을 때, 트랜잭션 종료 시 까지 해당 데이터에 대한 갱신, 삭제를 제한하는 수준
   라. Serializable Read: 선행 트랜잭션이 특정 데이터 영역을 순차적으로 읽을 때, 해당 데이터 영역 전체에 대한 접근 제한하는 수준 

164. 회복 기법(영속성 주요 기법)
 ㄴ 개념: 회복 기법은 트랜잭션을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업이다.
 ㄴ 종류: 회로체크: 회복 기법(로그 기반 / 체크 포인트 / 그림자 페이징 회복기법)
   가. 로그 기반 회복 기법
     ㄴ 지연 갱신 회복 기법(Deferred Update): 트랜잭션이 완료되기 전 까지 데이터베이스에 기록하지 않는 기법
     ㄴ 즉각 갱신 회복 기법(Immediate Update): 트랜잭션 수행 중 갱신 결과를 바로 DB에 반영하는 기법
  나. 체크 포인트 회복 기법: 장애 발생 시 검사점 이후에 처리된 트랜잭션에 대해서만 장애 발생 이전의 상태로 복원시키는 회복 기법
  다. 그림자 페이징 회복 기법: 데이터베이스 트랜잭션 수행 시 복제본을 생성하여 데이터베이스 장애 시 이를 이용해 복구하는 기법

165. DDL(Data Definition Language) 데이터 정의어
  ㄴ 개념: 데이터 정의어는 데이터를 정의하는 언어, 데이블과 같은 데이터 구조를 정의하는 데 사용되는 명령어들로 특정 구조를 생성, 변경, 삭제, 이름을 바꾸는 데이터 구조와 관련된 명령어들
 
166. DDL의 대상: 도스뷰테인
  ㄴ 도메인: 하나의 속성이 가질 수 있는 원자값들의 집합, 속성의 데이터 타입과 크기, 제약조건 등의 정보
  ㄴ 스키마: 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조, 스키마는 외부/개념/내부 3계층으로 구성되어 있음
     ㄴ 외부: 사용자나 개발자의 관점에서 필요로 하는 데이터베이스의 논리적 구조, 사용자 뷰를 나타냄, 서브 스키마로 불림
     ㄴ 개념: 데이터베이스의 전체적인 논리적 구조, 전체적인 뷰를 나타냄, 개체 간의 관계, 제약조건, 접근 권한, 무결성, 보안에 대해 정의
     ㄴ 내부: 물리적 저장장치의 관점에서 보는 데이터베이스의 구조, 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 표현
  ㄴ 뷰: 하나 이상의 물리 테이블에서 유도되는 가상의 테이블
  ㄴ 테이블: 데이터 저장 공간
  ㄴ 인덱스: 검색을 빠르게 하기 위한 데이터 구조

 167. 테이블: 테이블은 데이터를 저장하는 항목인 필드들로 구상된 데이터의 집합체이다. 하나의 DB 내에 여러 개의 테이블로 구성될 수 있고, 릴레이션 혹은 엔터티라고도 불린다.
 168. 테이블 관련 용어 
   ㄴ 튜플/행: 테이블 내의 행을 의미하며 레코드라고도 함, 튜플은 릴레이션에서 같은 값을 가질 수 없음
   ㄴ 애트리뷰트/열: 테이블 내의 열을 의미
   ㄴ 식별자: 여러 개의 집합체를 담고 있는 관계형 데이터베이스에서 각각을 구분할 수 있는 논리적인 개념
   ㄴ 카디널리티: 튜블의 개수
   ㄴ 차수: 애트리뷰트의 개수
   ㄴ 도메인: 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값 들의 집합

169. 뷰
  ㄴ 뷰는 논리 테이블로서 사용자에게(생성관점 아닌 사용관점) 테이블과 동일하다. 
  ㄴ 뷰는 물리 테이블로부터 생성 가능하며, 다수의 테이블 또는 다른 뷰를 이용해 만들 수 있다.
  ㄴ 뷰와 같은 결과를 만들기 위해 조인 기능을 활용할 수 있으나, 뷰가 만들어져 있다면 사용자는 조인 없이 하나의 테이블을 대상으로 하는 단순한 질의어를 사용할 수 있다.\
 
170. 뷰의 특징
  ㄴ 논리적 데이터 독립성 제공
  ㄴ 데이터 조작 연산 간소화
  ㄴ 보안 기능(접근제어) 제공
  ㄴ 뷰 변경 불가(AlTER 문을 이용하여 변경할 수 없음)

171. 뷰의 목적: 뷰를 사용하는 주된 이유는 단순 질의어를 사용할 수 있기 때문이다, FROM절에 있는 하나의 뷰를 통해 뷰를 구성하는 복수의 테이블을 대체하는 단순성에 그 의의가 있다. 중요 데이터 일부만을 제공할 수 있는 장단점이 있다.

172. 뷰의 장단점
  ㄴ 논리적 독립성 제공: 논리 테이블 구조가 변경되어도 뷰를 사용하는 응용프로그램은 변경하지 않아도 됨
  ㄴ 복수 테이블에 존재하는 여러 종류의 데이터에 대해 단순한 질의어 사용 가능
  ㄴ 데이터 보안 용이: 중요 보안 데이터를 저장 중인 테이블에는 접근 불허, 일부만 볼 수 있는 뷰에는 허용 
  ㄴ 뷰 자체 인덱스 불가: 인덱스는 물리적으로 저장된 데이터를 대상으로 하기에 논리적 구성인 뷰 자체는 인덱스를 가지지 못함
  ㄴ 뷰 정의 변경 불가: 정의를 변경하려면 제거하고 재생성
  ㄴ 데이터 변경 제약 존재: 뷰의 내용에 대한 삽입, 삭제, 변경 제약 있음

173. 인덱스
  ㄴ 인덱스는 데이터를 빠르게 찾을 수 있는 수단으로서, 테이블에 대한 조회속도를 높여 주는 자료구조이다.
  ㄴ 인덱스는 테이블의 특정 레코드 위치를 알려 주는 용도로 사용한다.

174. 인덱스 특징
  ㄴ 기본키(PK; Primary Key) 컬럼은 자동으로 인덱스가 생성된다.
  ㄴ 연월일이나 이름을 기준으로 하는 인덱스는 자동으로 생성되지 않는다.
  ㄴ 테이블의 컬럼에 인덱스가 없는 경우, 테이블의 전체 내용을 검색한다.
  ㄴ인덱스가 생성되어 있을 때 데이터를 빠르게 찾을 수 있다.

175. 인덱스의 종류: 순해비함 단결클(순서, 해시, 비트맵, 함수기반, 단일, 결합, 클러스터드)
176. 인덱스 스캔 방식
  ㄴ 인덱스 범위 스캔, 인덱스 전체 스캔, 인덱스 단일 스캔, 인덱스 생략 스캔

177. DDL 명령어: CREATE, ALTER, DROP, TRUNCATE

178. DML(Data Manipulation Language)
  ㄴ 개념: 데이터베이스에 저장된 자료들은 입력, 수정, 삭제, 조회하는 언어
 
179. DML 명령어: SELECT, INSERT, UPDATE, DELETE

180. SELECT 절: 데이터를 조회할 때 사용됨
  ㄴ SELECT: 검색하고자 하는 속성명, 계산식을 기술, 속성명 별칭은 AS를 사용하며 생략 가능함
  ㄴ SELECT 뒤에 아무것도 없으면 ALL이 기본값,
  ㄴ DISTINCT 중복된 속성이 조회될 경우 그 중 한개만 검색
  ㄴ FROM: 테이블 명 기술
  ㄴ WHERE: 조건 기술
  ㄴ GROUP BY: 그룹으로 분류할 떄 사용
  ㄴ HAVING: GROUP BY에 의해 분류한 후에 그룹에 대한 조건 지정
  ㄴ ORDER BY: 속성값을 정렬할 때 사용(ASC 오름차순, DESC 내림차순)

181. 조인 개념: 조인은 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법이다. 두 릴레이션으로부터 관련된 튜플들을 결합하여 하나의 튜플로 만드는 가장 대표적인 데이터 연결 방법이다. 
  ㄴ 내부조인: 공통 존재 컬럼의 값이 같은 경우를 추출하는 기법
  ㄴ 외부조인 왼쪽: 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 동일 데이터 추출, 오른쪽은 오른쪽의 모든 데이터, 완전 외부 조인은 양쪽의 모든 데이터 추출
  ㄴ 교차조인: 조인 조건이 없는 모든 데이터 조합을 추출
  ㄴ 셀프조인: 자기 자신에게 별칭을 지정한 후 다시 조인

182. 서브쿼리
  ㄴ 서브쿼리는 SQL 문 안에 포함된 또 다른 SQL 문이다.
  ㄴ 서브쿼리의 용도는 알려지지 않은 기준을 위한 검색을 위해 사용한다.
  ㄴ 메인쿼리와 서브쿼리 관계는 주종 관계로서, 서브쿼리에 사용되는 컬럼 정보는 메인쿼리의 컬럼 정보를 사용할 수 있으나, 역으로는 성립하지 않는다.

183. 서브쿼리 유형
  ㄴ SELECT 서브쿼리: 스칼라 서브쿼리 라고도 불림, 반드시 단일 행을 리턴해야함, SUM, COUNT, MIN, MAX 등과 같은 집계함수가 많이 쓰임
  ㄴ FROM 서브쿼리: 인라인 뷰 라고 불림, 뷰 처럼 결과가 동적으로 생성된 테이블 형태로 사용할 수 있음
  ㄴ WHERE 서브쿼리: 중첩 서브쿼리 라고도 불림

184. 집합 연산자
  ㄴ 집합 연산자는 테이블을 집합 개념으로 보고, 두 테이블 연산에 집합 연산자를 사용하는 방식이다.
  ㄴ 집합 연산자는 여러 질의 결과를 연겨라여 하나로 결합하는 방식을 사용한다.(2개 이상의 질의 결과를 하나의 결과로 만들어준다.)

185. 집합 연산자 유형
  ㄴ UNION: 중복 행이 제거된 쿼리 결과를 반환하는 집합 연산자.
  ㄴ UNION ALL: 중복 행이 제거되지 않은 쿼리 결과를 반환하는 집합 연산자.
  ㄴ INTERSECT: 두 쿼리 결과에 공통적으로 존재하는 결과를 반환하는 집합 연산자.
  ㄴ MINUS: 첫 쿼리에 있고 두번째 쿼리에는 없는 결과를 반환하는 집합 연산자.

186. DCL(Data Control Language)
  ㄴ 데이터 제어어는 데이터베이스 관리자가 데이터 보안, 무결성 유지, 병행 제어, 회복을 위해 관리자가 사용하는 제어용 언어.
  ㄴ GRANT와 REVOKE가 있다.

187. 데이터 분석 함수의 개념: 총합, 평균 등 데이터 분석을 위해서는 복수 행 기준의 데이터를 모아서 처리하는 것을 목적으로 하는 다중 행 함수이다. 

188. 데이터 분석 함수의 종류
  ㄴ 집계함수: 여러 행 또는 테이블 전체 행으로부터 하나의 결괏값을 반환하는 함수
  ㄴ 그룹함수: 소그룹 간의 소계 및 중계 등의 중간 합계 분석 데이터를 산출하는 함수
  ㄴ 윈도함수: 데이터베이스를 사용한 온라인 분석 처리 용도로 사용하기 위해서 표준 SQL에 추가된 기능

189. 집계함수의 개념과 종류: 여러 행 또는 테이블 전체 해응로부터 하나의 결괏값을 반환하는 함수이다. COUNT, SUM, AVG, MAX, MIN, STDDEV, VARIAN

190. 그룹함수 개념: 테이블의 전체 행을 하나 이상의 컬럼을 기준으로 컬럼 값에 따라 그룹화하여 그룹별로 결과를 출력하는 함수이다.

191. ROLLUP 함수
  ㄴ ROLLUP에 의해 지정된 컬럼은 소계 등 중간 집계 값을 산출하기 위한 그룹함수이다, 지정 컬럼의 수보다 하나 더 큰 레벨 만큼의 중간 집계 값이 생성된다.
  ㄴ ROLLUP 지정 컬럼은 계층별로 구성되기 때문에 순서가 바뀌면 수행 결과가 바뀜을 유의한다.
 
192. CUBE 함수: 결합가능한 모든 값에 대해 다차원 집계를 생성하는 그룹 함수. 연산이 많아 시스템에 부담을 준다.

193. GROUPING SETS 함수: 집계 대상 컬럼들에 대한 개별 집계를 구할 수 있으며, ROLLUP이나 CUBE와는 달리 컬럼 간 순서와 무관한 결과를 얻을 수 있는 그룹 함수이다.

194. 윈도 함수: 윈도 함수는 데이터베이스를 사용한 온라인 분석 처리 용도로 사용하기 위해서 표준 SQL에 추가된 함수이다. 윈도 함수를 OLAP 함수 라고도 한다.
  ㄴ OLAP: OnLine Analytical Processing, 의사결정 지원 시스템으로, 사용자가 동일한 데이터를 여러 기준을 이용하는 다양한 방식으로 바라보면서 다차원 데이터 분석을 할 수 있도록 도와주는 기술이다.

195. 윈도 함수의 분류: 순위함수, 행순서 함수, 그룹 내 비율 함수(순행비)

196. 순위함수 종류
  ㄴ RANK: 특정 항목(컬럼)에 대한 순위를 구하는 함수, 동일 순위의 레코드 존재 시 후순위는 넘어감(2위가 3개인 레코드의 경우 2위 2위 2위 5위 6위)
  ㄴ DENSE_RANK: 레코드의 순위를 계산, 동일 순위의 레코드 존재 시에도 후순위를 넘어가지 않음(2위가 3개인 레코드의 경우 2위 2위 2위 3위 4위)
  ㄴ ROW_NUMBER: 레코드의 순위를 계산, 동일 순위의 값이 존재해도 이와 무관하게 연속 번호를 부여(2위가 3개인 레코드의 경우 2위 3위 4위 5위 6위)

197. 행 순서 함수 종류
  ㄴ FIRST_VALUE: 파티션별 윈도에서 가장 먼저 나오는 값을 찾음, 집계 함수의 MIN과 동일한 결과를 출력
  ㄴ LAST_VALUE: 파티션별 윈도에서 가장 늦게 나오는 값을 찾음, 집계 함수의 MAX와 동일한 결과를 출력
  ㄴ LAG: 파티션별 윈도에서 이전 로우의 값 반환
  ㄴ LEAD: 파티션별 윈도에서 이후 로우의 값 반환

198. 그룹 내 비율 함수
  ㄴ RATIO_TO_REPORT: 주어진 그룹에 대해 합을 기준으로 각 로우의 상대적 비율을 반환하는 함수, 결과값은 0~1 범위를 가짐, OVER 괄호 안에 컬럼 생략 시 그룹은 테이블 전체가 대상
  ㄴ PERCENT_RANK: 주어진 그룹에 대해 제일 먼저 나오는 것을 0으로, 제일 늦게 나오는 것을 1로 하여 값이 아닌 행의 순서별 백분율을 구하는 함수, 결과값은 0~1 범위를 가짐

200. 절차형 SQL 개념: 절차형 SQL은 일반적인 개발 언어처럼 SQL 언어에서도 절차 지향적인 프로그램이 가능하도록 하는 트랜잭션 언어이다.

201. 절차형 SQL 종류
  ㄴ 프로시저: 일련의 쿼리들을 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합
  ㄴ 사용자 정의 함수: 일련의 SQL 처리를 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 절차형 SQL
  ㄴ 트리거: 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL

202. 프로시저 구성: 디비컨SET
  ㄴ Declare: 프로시저의 명칭, 변수와 인수 그리고 그에 대한 데이터 타입을 정의하는 부분
  ㄴ Begin/End: 프로시저의 시작과 종료를 표현하며, Begin/End가 쌍을 이룸, 다수 실행을 제어하는 기본적 단위가 되며 논리적 프로세스를 구성
  ㄴ Control: 기본적으로는 순차적으로 처리, 조건문과 반복문을 이용하여 처리
  ㄴ SQL: DML주로 사용, DDL 중 TRUNCATE 사용
  ㄴ Exception: 예외 발생 시 예외 처리 방법 정의하는 처리부
  ㄴ Transaction: 프로시저에서 수행된 DML 수행 내역의 DBMS의 적용 또는 취소 여부를 결정하는 처리부

203. 사용자 정의함수(User-Defined Function) 개념
  ㄴ 사용자 정의함수는 일련의 SQL 처리를 수행하고, 수행 결과를 단일 값으로 반환할 수 있는 절차형 SQL 이다.

204. 사용자 정의함수 구성: 디비컨SER
  ㄴ 기본적인 사항은 프로시저와 동일하고 반환에서의 부분만 프로시저와 다르다.
  ㄴ 사용자 정의 함수의 호출을 통해 실행되며, 반환되는 단일 값을 조회 또는 삽입, 수정 작업에 이용하는 것이 일반적이다.
  ㄴ Declare: 명칭, 변수와 인수 그리고 그에 대한 데이터 타입을 정의하는 부분
  ㄴ Begin/End: 시작과 종료를 표현하며, Begin/End가 쌍을 이룸, 다수 실행을 제어하는 기본적 단위가 되며 논리적 프로세스를 구성
  ㄴ Control: 기본적으로는 순차적으로 처리, 조건문과 반복문을 이용하여 처리
  ㄴ SQL: DML주로 사용, DDL 중 TRUNCATE 사용
  ㄴ Exception: 예외 발생 시 예외 처리 방법 정의하는 처리부
  ㄴ Return: 호출문에 대한 함숫값을 반환

205. 트리거 개념
  ㄴ 데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL이다.
  ㄴ 이벤트는 전체 트랜잭션 대상과 각 행에 의해 발생하는 경우 모두를 포함할 수 있으며 테이블과 뷰, DB작업을 대상으로 정의할 수 있다.

206. 트리거의 목적
  ㄴ 특정 테이블에 대한 데이터 변경을 시작점으로 설정하고, 그와 관련된 작업을 자동적으로 수행하기 위해 사용
  ㄴ 이벤트와 관련된 테이블의 데이터 삽입, 추가 삭제 작업을 DBMS가 자동적으로 실행시키는 데 활용

207. 트리거의 종류: 행 트리거: 데이터 변화가 생길 때 마다 실행, 문장 트리거: 트리거에 의해 단 한 번 실행

208. 트리거 구성: 디이비컨SE
  ㄴ 프로시저나 사용자 정의함수와 기본적 문법은 같다, 반환 값이 없고 DML을 주된 목적으로 한다는 점에서 프로시저와 유사, EVENT 명령어를 통해 트리거 실행을 위한 이벤트를 인지한다는 점, 외부 변수 IN/OUT이 없다는 점은 프로시저나 사용자 정의 함수와 다르다.
  ㄴ Declare: 명칭, 변수와 인수 그리고 그에 대한 데이터 타입을 정의하는 부분
  ㄴ Event: 트리거가 실행되는 타이밍, 이벤트를 명시하는 부분
  ㄴ Begin/End: 시작과 종료를 표현하며, Begin/End가 쌍을 이룸, 다수 실행을 제어하는 기본적 단위가 되며 논리적 프로세스를 구성
  ㄴ Control: 기본적으로는 순차적으로 처리, 조건문과 반복문을 이용하여 처리
  ㄴ SQL: DML주로 사용, DDL 중 TRUNCATE 사용
  ㄴ Exception: 예외 발생 시 예외 처리 방법 정의하는 처리부

209. 쿼리 성능 개선(튜닝) 개념
  ㄴ 쿼리 성능 개선은 데이터베이스에서 프로시저에 있는 SQL 실행 계획을 분석, 수정을 통해 최소의 시간으로 원하는 결과를 얻도록 프로시저를 수정하는 작업.
  ㄴ SQL 성능 개선을 통해 데이터 조작 프로시저의 성능 개선이 가능하다.

210. 쿼리 성능 개선 절차: 문제 있는 SQL식별 -> 옵티마이저 통계 확인 -> SQL문 재구성 -> 인덱스 재구성 -> 실행계획 유지관리

211. 옵티마이저 개념
  ㄴ 옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리경로를 생성해주는 DBMS 내부의 핵심 엔진이다.
  ㄴ 옵티마이저가 생성한 SQL 처리경로를 실행계획 이라고 부른다.

212. 옵티마이저 유형
  ㄴ RBO(Rule Based Optimizer) 규칙기반 옵티마이저: 통계 정보가 없는 상태에서 사전 등록된 규칙에 따라 질의 실행 계획을 선택하는 옵티마이저, 규칙(우선 순위)기반, 인덱스 구조, 연산자, 조건절 형태 등, 사용자가 원하는 처리경로로 유도하기 쉬움
  ㄴ CBO(Cost Based Optimizer) 비용기반 옵티마이저: 통꼐 정보로부터 모든 접근 경로를 고려한 질의 실행 계획을 선택하는 옵티마이저, 비용(수행 시간)기반, 레코드 개수, 블록 개수, 평균 행길이, 컬럼값의 수, 분포, 인ㄷ게스 높이, 클러스터링 팩터 등, 옵티마이저의 이해도가 낮아도 성능보장 가능(기본설정)

213. 옵티마이저 역할: 쿼리 변환, 비용 산정, 계획 생성

214. 힌트사용: SQL 성능 개선의 핵심 부분으로 옵티마이저의 실행 계획을 원하는 대로 변경할 수 있게 한다. 옵티마이저가 항상 최선의 실행 계획을 수립할 수 없어 명시적인 힌트를 통해 실행계획 변경
  ㄴ 개념: 실행하려 하는 SQL문에 사전에 정보를 주어서 SQL문 실행에 빠른 결과를 가져오는 효과를 만드는 문법

215. 개발환경 구축
  ㄴ 개발환경 구성 시 구현될 시스템 요구사항의 명확한 이해가 필요하다. 
  ㄴ 개발 도구와 서버의 선정이 이루어져야 하고, 개발에 사용되는 도구들의 사용 편의성과 성능, 라이선스를 확인한다.

216. 개발 도구의 분류: 빌구테형
  ㄴ 빌드도구: 작성한 코드의 빌드 및 배포를 수행, 각각의 구성요소와 모듈에 대한 의존성 관리를 지원
  ㄴ 구현도구: 개발자의 코드 작성과 디버깅, 수정 등과 같은 작업 지원, 프로그램을 개발할 때 가장 많이 사용되는 도구
  ㄴ 테스트도구: 코드의 기능 검증과 전체의 품질을 높이기 위해 사용하는 도구, 코드의 테스트, 테스트에 대한 계획 수행 및 부석 등의 작업 가능
  ㄴ 형상관리도구: 개발자들이 작성한 코드와 리소스 등 산출물에 대한 버전 관리를 위한 도구, 프로젝트 진행시 필수로 포함되는 도구

217. 서버 하드웨어 개발환경: 프로젝트 구성에 따라 웹 서버, 웹 애플리케이션 서버, 데이터베이스 서버, 파일 서버로 구분한다.
  ㄴ 웹서버: HTTP를 이용한 요청/응답을 처리, 웹 상의 정적 콘텐츠(CSS, Javascript, Image)를 처리, WEB-WAS-DB 3계층 구조를 실무에서 활용, 주요 제품으로 Apache 웹 서버, IIS 웹 서버, Google Web Server, Nginx 등 존재
  ㄴ 웹 애플리케이션 서버: 동적 콘텐츠(Servlet, JSP)를 처리하기 위해 사용, 사용자 요청 스레드를 처리하고, 데이터베이스에 접속하여 SQL 쿼리 문에 대한 결괏 값을 반환하는 역할을 수행하는 서버이다. 주요 제품으로 Tomcat, Weblogic, Jeus, Resin 등 존재
  ㄴ 데이터베이스 서버: 데이터의 수집, 저장을 위한 용도로 사용, 연계되는 주요 DBMS로 Mysql, Oracle, MS-SQL, DB2 등 존재
  ㄴ 파일 서버: 파일 저장 하드웨어로 물리 저장장치를 활용한 서버, 대용량 HDD, SSD 등의 장치가 존재

218. 클라이언트 하드웨어 개발환경: 서버 개발환경에서 제공된 서비스를 사용하기 위해 UI를 제공한다. 클라이언트 프로그램, 웹 브라우저, 모바일 앱, 모바일 웹으로 구분한다.

219. 소프트웨어 개발환경: 개발을 위한 기본적인 소프트웨어 개발환경을 선택 및 구성한다. 큰 틀에서 프로젝트 요구사항에 부합한 운영체제, 미들웨어, 데이터베이스 시스템을 선정한다.
  ㄴ 운영체제: 서버의 하드웨어를 사용자 관점에서 편리하고 유용하게 사용하기 위한 소프트웨어, 프로젝트의 성격에 따른 운영체제 사용
  ㄴ 미들웨어: 컴퓨터와 컴퓨터 간의 연결을 쉽고 안전하게 할 수 있도록 해주고 이에 대한 관리를 도와주는 소프트웨어, 자바 기반 환경에서 JVM을 설치하여 컨테이너로의 기능을 주로 이용
  ㄴ JVM: 시스템 메모리를 관리하면서 자바 기반 애플리케이션을 위해 이식 가능한 실행 환경을 제공하는 소프트웨어이다.
  ㄴ 컨테이너: JSP와 서블릿을 실행시킬 수 있는 소프트웨어이다.
  ㄴ DBMS: 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어, 데이터의 저장 및 활용을 위해 설치.

220. 형상 관리
  ㄴ 개념: 소프트웨어 개발을 위한 전체 과정에서 발생하는 모든 항목의 변경 사항을 관리하기 위한 활동이다, SW 생명주기 동안 형상 관리를 통해 산출물을 체계적으로 관리하여 SW의 가시성, 추적성, 무결성 등의 품질 보증을 보장할 수 있다.
  ㄴ 목적: 프로젝트 생명주기 동안 제품의 무결성과 변경에 대한 추적성을 확보할 수 있다, 변경이 발생 되었을 때 처리하는 메커니즘을 제공한다, 대표적인 메커니즘으로 형상 관리대상 파악, 베이스라인 지정, 형상 관리, 접근제어 등이 있다.
  * 베이스라인: 개발 과정의 각 단계의 산출물을 검토, 평가, 조정, 처리 등 변화를 통제하는 시점의 기준이다.

221. 형상관리 절차: 식통감기
  ㄴ 형상 식별: 형상 관리 대상을 정의 및 식별하는 활동, 추적성 부여를 위해 ID와 관리번호를 부여, 변경 관련 이슈 발생 시 ID와 관리번호를 이용하여 추적
  ㄴ 형상 통제: 형상 항목의 버전 관리를 위한 형상통제위원회 운영, 변경요구 관리, 변경제어, 형상 관리 등 통제 지원, 베이스라인에 대한 관리 및 형상 통제 수행 가능
  ㄴ 형상 감사: 소프트웨어 베이스라인의 무결성 평가, 베이스라인 변경 시 요구사항과  일치 여부 검토
  ㄴ 형상 기록: 소프트웨어 형상 및 변경관리에 대한 각종 수행결과를 기록, 형상결과 보고서 작성

222. 소프트웨어 형상 관리 도구 유형: 공클분
  ㄴ 공유폴더 방식(RCS, SCCS): 매일 개발이 완료된 파일은 약속된 위치의 공유 폴더에 복사하는 방식, 담당자 한 명이 매일 공유 폴더의 파일을 자기 PC로 복사하고 컴파일하여 에러 확인과 정상 동작 여부 확인
  ㄴ 클라이언트/서버 방식(CVS, SVN): 중앙에 버전 관리 시스템을 항시 동작시키는 방식, 개발자들의 현재 작업 내용과 이전 작업 내용 추적에 용이, 서로 다른 개발자가 같은 파일을 작업했을 때 경고 메시지 출력
  ㄴ 분산 저장소 방식(Git): 로컬 저장소와 원격 저장소로 분리되어 분산 저장하는 방식, 중앙의 저장소에서 로컬 파일을 클론한 순간 개발자 자신 만의 로컬 저장소 생성, 개발 완료한 파일을 수정한 다음에 로컬 저장소에 우선적으로 커밋한 이후, 다시 원격 저장소에 반영(Push)하는 방식

223. 소프트웨어 형상 관리 도구별 특징
  ㄴ CVS(Concurrent Versions System): 서버와 클라이언트로 구성되어있고, 다수의 인원이 동시에 범용적인 운영체제로 접근 가능한 형상 관리 도구
  ㄴ SVN(Subversion): 하나의 서버에서 소스를 쉽고 유용하게 관리할 수 있게 도와주는 도구, 저장소를 만들어 그곳에 소스를 저장해 소스 중복이나 여러 문제를 해결하기 위한 도구
  ㄴ RCS(Revision Control System): CVS와 달리 소스 파일의 수정을 한 사람만으로 제한하여 다수의 사람이 파일의 수정을 동시에 할 수 없도록 파일 잠금 방식으로 형상을 관리 하는 도구
  ㄴ Bitkeeper: SVN과 비슷한 중앙 통제 방식으로 대규모 프로젝트에서 빠른 속도를 내도록 개발된 형상 관리 도구
  ㄴ Git: Git의 속도에 중점을 둔 분산형 버전 관리 시스템이며, 대형 프로젝트에서 효과적이고 유용, Git의 Commit은 로컬 저장소, Push라는 동작으로 원격 저장소에 반영, 로컬 저장소에서 작업이 이루어져 매우 빠른 응답을 받을 수 있음, 전체 기록과 각 기록을 추적할 수 있는 정보를 포함하는 완전한 형태의 저장소
  ㄴ Clear Case: 복수 서버, 복수 클라이언트 구조이며 서버가 부족할 때 필요한 서버를 하나씩 추가하여 확장성을 기할 수 있음

224. JDK: Java Development Kit, 자바 애플리케이션을 구축하기 위한 핵심 플랫폼이다.

225. Maven: Java 기반 프로젝트 관리를 목적으로 하는 빌드 도구로 컴파일, 빌드, 패키지, 테스트, 라이브러리 관리 기능이 있다.

226. Gradle: Groovy를 기반으로 한 빌드 도구로 Ant와 Maven 등 이전 세대 빌드 도구의 단점을 보완하고 개선했다.

227. 모듈 개념
  ㄴ 모듈은 그 자체로 하나의 완전한 기능을 수행 할 수 있는 독립된 실체이다. 
  ㄴ 모듈화를 통해 분리된 시스템의 각 기능들로 서브프로그램, 서브 루틴, 소프트웨어 내의 단위 프로그램, 작업 단위 등과 같은 의미로 사용된다.

228. 모듈 특징
  ㄴ 각각의 모듈은 상대적으로 독립성을 가지고 있다.
  ㄴ 모듈 내부에는 그 모듈을 하나로 통합하는 수 많은 조합이 존재할 수 있다.
  ㄴ 모듈은 단독으로 컴파일할 수 있으며, 재사용 할 수 있다.
  ㄴ 독립성이 높은 모듈일수록 모듈 수정 시에도 다른 모듈들에는 영향을 거의 미치치 않고, 오류 발생 시에도 쉽게 해결할 수 있다.
  ㄴ 독립성은 결합도와 응집도에 의해 측정되며, 독립성을 높이려면 모듈의 결합도는 약하게, 응집도는 강하게, 크기는 작게 만들어야한다.

229. 모듈화(Modularity)의 개념 및 기법
  ㄴ 모듈화는 소프트웨어의 성능을 향상시키거나 복잡한 시스템의 수정, 재사용, 유지 관리 등이 용이하도록 기능 단위의 모듈로 분해나는 설계 및 구현 기법
  ㄴ기법: 루틴, 메인 루틴, 서브 루틴

230. 공통 모듈: 전체 프로그램의 기능 중 특정 기능을 처리할 수 있는 실행 코드이다. 자체적으로 컴파일이 가능하고, 다른 프로그램에서 재사용이 가능하다.
  ㄴ 소프트웨어 개발에 있어 기능을 분할하고 추상화하여 성능을 향상시키고 유지보수를 효과적으로 하기 위한 공통 컴포넌트 구현 기법이다, 인터페이스 모듈, 데이터베이스 접근 모듈 등 필요한 공통 모듈을 구현한다.

231. 응집도(Cohesion)의 개념
  ㄴ 응집도는 모듈의 독립성을 나타내는 정도로, 모듈 내부 구성요소 간 연관 정도이다. 하나의 모듈은 하나의 기능을 수행할 수록 응집도가 높다.
  ㄴ 하나의 모듈은 하나의 기능을 수행할 수록 응집도가 높다.

232. 응집도 순서: 우논시절 통 순기
  ㄴ 우연적(Coincidental cohesion): 모듈 내부의 각 구성요소가 연관이 없을 경우의 응집도
  ㄴ 논리적(Logical): 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우의 응집도
  ㄴ 시간적(Temporal): 연관된 기능이라기보다 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우의 응집도
  ㄴ 절차적(Procedural): 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소 들이 그 기능을 순차적으로 수행할 경우의 응집도
  ㄴ 통신적(Communication): 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우의 응집도
  ㄴ 순차적(Sequential): 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용할 경우의 응집도
  ㄴ 기능적(Functional): 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우의 응집도

233. 결합도(Coupling)의 개념
  ㄴ 모듈 내부가 아닌 외부의 모듈과의 연관도 또는 모듈 간의 상호의존성이다.
  ㄴ 소프트웨어 구조에서 모듈 간의 관련성을 측정하는 척도이다.

234. 결합도 순서: 내공 외제 스자
  ㄴ 내용(Content): 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도
  ㄴ 공통(Common): 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도
  ㄴ 외부(External): 두 개의 모듈이 외부에서 도입된 데이터 포맷, 통신 프로토콜, 또는 디바이스 인터페이스를 공유할 경우의 결합도
  ㄴ 제어(Control): 단순 처리할 대상인 값만 전달 되는 게 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달되는 경우의 결합도
  ㄴ 스탬프(Stamp): 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우의 결합도
  ㄴ 자료(Data): 모듈 간의 인터페이스로 전다로디는 파라미터를 통해서만 모듈 간의 상호 작용이 일어나는 경우의 결합도

235. MVC(Model View Controller Pattern)패턴
  ㄴ 모델: 애플리케이션이 무엇을 할 것인지 정의, 내부 비즈니스 로직을 처리하기 위한 역할
  ㄴ 뷰: 화면에 무엇인가를 보여주기 위한 역할, 모델, 컨트롤러가 보여주려고 하는 것들을 화면에 처리
  ㄴ 컨트롤러: 모델이 어떻게 처리할지를 알려주는 역할, 뷰에 명령을 보내어 화면 요청 결과를 전달

236. 팬인(Fan-In) 및 팬아웃(Fan-Out)
  ㄴ팬인과 팬아웃 분석을 통하여 시스테의 복잡도를 측정할 수 있다.
  ㄴ 소프트웨어의 구성요소인 모듈을 계층적으로 분석하기 위해서 팬인 팬아웃을 활용

237. 팬인
  ㄴ 개념: 어떤 모듈을 제어(호출)하는 모듈의 수
  ㄴ 모듈 숫자 계산: 모듈 자신을 기준으로 모듈에 들어오면 팬인
  ㄴ 고려사항: 팬인이 높으면 재사용 측면에서 설계가 잘되었지만, 단일 장애점 발생 가능, 팬인이 높으면 관리 비용 및 테스트 비용 증가

238. 팬아웃
  ㄴ 개념: 어떤 모듈에 의해 제어(호출)되는 모듈의 수
  ㄴ 모듈 자신을 기준으로 모듈에서 나가면 팬아웃
  ㄴ 팬아웃이 높을 경우는 불필요한 모듈 호출 여부 검토 필요, 팬아웃이 높을 경우는 단순화 여부 검토 필요

239. 서버 프로그램 구현: 업무 푸로세스를 기반으로 개발언어와 도구를 이용해 서버에서 서비스 제공에 필요한 기능을 구현하는 활동이다.

240. 서버 프로그램 세부 구현 프로세스: 디스 다써클
 DTO/VO -> SQL -> DAO -> Service -> Controller

DTO(Data Transfer Object): 프로세스 사이에서 데이터를 전송하는 객체로 데이터 저장, 회수 외에 다른 기능이 없는 객체이다.
VO(Value Object): 간단한 엔티티를 의미하는 작은 객체 가변 클래스인 DTO와 달리 고정 클래스를 가지는 객체이다
DAO(DataAccess Object): 특정 타입의 데이터베이스에 추상 인터페이스를 제공하는 객체로 세부내용 노출 없이 데이터를 조작하는 객체이다.
Service: 사용자의 요청을 처리하는 기능을 제공하기 위한 로직을 구현하고 DAO 클래스를 통해 DB연동을 처리하는 기능을 수행하는 클래스이다.

241. 배치 프로그램(Batch Program) 개념
  ㄴ 배치 프로그램은 사용자와의 상호작용 없이 일련의 작업들을 작업 단위로 묶어 정기적으로 반복 수행하거나 정해진 규칙에 따라 일괄 처리하는 방법이다.

242. 배치 프로그램 유형: 이온정
  ㄴ 이벤트 배치: 사전에 정의해 둔 조건 충족 시 자동으로 실행
  ㄴ 온디맨드 배치: 사용자의 명시적 요구가 있을 때 마다 실행
  ㄴ 정기 배치: 정해진 시점(주로 야간)에 정기적으로 실행

243. 배치 스케쥴러(Scheduler)의 개념
  ㄴ 배치 스케쥴러는 일괄 처리(Batch Processing)를 위해 주기적으로 발생하거나 반복적으로 발생하는 작업을 지원하는 도구이다.

244. 배치 스케줄러 종류
  ㄴ 스프링 배치: 스프링 프레임워크의 DI, AOP, 서비스 추상화 등 스프링 프레임워크의 3대 요소를 모두 사용할 수 있는 대용량 처리를 제공하는 스케줄러 배치 애플리케이션
  ㄴ 쿼츠 스케줄러: 스프링 프레임워크에 플러그인되어 수행하는 작업과 실행 스케줄을 정의하는 트리거를 분리하여 유연성을 제공하는 오픈 소스 기반 스케줄러

245. 크론(Cron) 표현식: 스케줄러를 실행시키기 위해 작업이 실행되는 시간 및 주기 등을 설정하게 되는데 크론 표현식을 통해 배치 수행시간 설정
  ㄴ 크게 리눅스/유닉스와 쿼츠로 구분(세부사항 책 참고)
  ㄴ 리눅스/유닉스 표현식: 분시일월요연
  ㄴ 쿼츠 크론 표현식: 초분시일 월요연

246. Cron 표현식 특수 문자 의미
  *: 모든 수
  ?: 해당 항목을 미사용
  -: 기간설정
  ,: 특정기간 설정
  /: 시작시간과 반복간격 설정
  L: 마지막 기간에 동작
  W: 가장 가까운 평일에 동작
  #: 몇 번째 주, 요일 설정

247. SW 개발 보안의 개념
  ㄴ 소스 코드 등에 존재하는 보안 취약점을 제거하고, 보안을 고려하여 기능을 설계 및 구현하는 등 소프트웨어 개발 과정에서 지켜야할 일련의 보안 활동을 말한다.

248. SW 보안의 3대 요소: 기무가
  ㄴ 기밀성(Confidentiality): 인가되지 않은 개인 혹은 시스템 접근에 따른 정보 공개 및 노출을 차단하는 특성
  ㄴ 무결성(Integrity): 정당한 방법을 따르지 않고서는 데이터가 변경될 수 없으며, 데이터의 정확성 및 완전성과 고의/악의로 변경되거나 훼손 또는 파괴되지 않음을 보장하는 특성
  ㄴ 가용성(Availability): 권한을 가진 사용자나 애플리케이션이 원하는 서비스를 지속해서 사용할 수 있도록 보장하는 특성

249. SW 개발 보안 용어: 자위취위
  ㄴ 자산(Assets), 위협(Threat), 취약점(Vulnerability), 위험(Risk)

250. DoS(Denial of Service) 공격 개념
  ㄴ 시스템을 악의적으로 공격해서 해당 시스템의 자원을 부족하게 하여 원래 의도된 용도로 사용하지 못하게 하는 공격
  ㄴ 특정 서버에게 수많은 접속 시도를 만들어 다른 이용자가 정상적으로 서비스 이용을 하지 못하게 하거나, 서버의 TCP 연결을 소진 시키는 등의 공격이다.

251. DoS 공격의 종류
  ㄴ SYN Flooding: TCP 프로토콜의 구조적 문제를 이용한 공격, 서버의 동시 가용 사용자 수를 SYN 패킷만 보내 점유하여 다른 사용자가 서버를 사용 불가능하게 하는 공격
		        공격자는 ACK를 발송하지 않고 계속 새로운 연결 요청을 하게 되어 서버는 자원할당을 해지하지 않고 자원만 소비하여 고갈됨
  ㄴ UDP Flooding: 대량의 UDP 패킷을 만들어 임의의 포트 번호로 전송하여 응답 메시지(ICMP Destination Unreachable)를 생성하게 하여 지속해서 자원을 고갈시키는 공격
		         ICMP 변조되어 공격자에게 전달되지 않아 대기함
  ㄴ Smurf/Smurfing: 출발지 주소를 공격 대상의 IP로 설정하여 네트워크 전체에게 ICMP Echo 패킷을 직접 브로드캐스팅 하여 마비시키는 공격
			 바운스 사이트라고 불리는 제3의 사이트를 이용해 공격
  ㄴ 죽음의 핑(PoD; Ping of Death): ICMP 패킷(Ping)을 정상적인 크기보다 아주 크게 만들어 전송하면 다수의 IP 단편화가 발생하고, 수신 측에서는 단편화된 패킷을 처리(재조합)하는 과정에서 많은 부하가 발생하거나, 재조합 버퍼의 오버플로우가 발생하여 정상적인 서비스를 하지 못하도록 공격하는 기법
  ㄴ Land Attack: 출발지(Source) IP와 목적지(Destination) IP를 같은 패킷 주소로 만들어 보냄으로써 수신자가 자기 자신에게 응답을 보내게 하여 시스템의 가용성을 침해하는 공격기법
  ㄴ Tear Drop: IP 패킷의 재조합 과정에서 잘못된 Fragment Offset 정보로 인해 수신 시스템이 문제를 발생하도록 만드는 공격
		  공격자는 IP Fragment Offset 값을 서로 중첩되도록 조작하여 전송하고, 이를 수신한 시스템이 재조합하는 과정에서 오류가 발생, 시스템의 기능을 마비시키는 공격방식
  ㄴ Bonk/Boink: 프로토콜의 오류 제어를 이용한 공격기법으로서 시스템의 패킷 재전송과 재조립이 과부하를 유발

252. DDoS(Distributed Dos) 공격 개념
  ㄴ DoS의 또 다른 형태로 여러 대의 공격자를 분산 배치하여 동시에 동작하게 함으로써 특정 사이트를 공격하는 기법
  ㄴ 해커들이 취약한 인터넷 시스템에 대한 액세스가 이뤄지면, 침입한 시스템에 소프트웨어를 설치하고 이를 실행시켜 원격에서 공격을 개시한다.

253. DDoS 공격 구성요소: HAMAD
  ㄴ Handler: 마스터 시스템의 역할을 수행하는 프로그램
  ㄴ Agent: 공격 대상에 직접 공격을 가하는 시스템
  ㄴ Master: 공격자에게서 직접 명령을 받는 시스템, 여러 대의 에이전트를 관리하는 역할
  ㄴ Attacker: 공격을 주도하는 해커의 컴퓨터
  ㄴ Daemon: 에이전트 시스템의 역할을 수행하는 프로그램

254. DDoS 공격도구
  ㄴ Trinoo: 많은 소스로부터 통합된 UDP flood 서비스 거부 공격을 유발하는 데 사용되는 도구, Trinoo 공격은 몇 개의 서버들과 많은 수의 클라이언트들로 이루어짐
  ㄴ Tribe Flood Network: TFN은 Trinoo와 거의 유사한 분산 도구로 많은 소스에서 하나 혹은 여러개의 목표 시스템에 대해 서비스 거부 공격을 할 수 있는 도구, TFN 서비스 거부 공격은 공격자가 클라이언트 프로그램을 통해 공격 명령을 일련의 TFN 서버들에게 보냄으로써 이루어짐
  ㄴ Stacheldrant: 분산 서비스 거부 에이전트 역할을 하는 Linux 및 Solaris 시스템용 멀웨어 도구

255. DRDoS(Distributed Reflection DoS) 공격의 개념
  ㄴ 공격자는 출발지 IP를 공격대상 IP로 위조하여 다수의 반사 서버로 요청 정보를 전송, 공격 대상자는 반사 서버로부터 다량의 응답을 받아서 서비스 거부가 되는 공격

256. DDoS와 DRDoS의 차이점: DRDoS는 DDoS에 비해 공격 근원지 파악이 어렵고, 공격 트래픽 생성 효율이 훨씬 크다.

257. 애플리케이션 공격(DDoS 서비스 마비 공격)
  ㄴ HTTP GET Flooding: Cache Control Attack 공격, 과도한 Get 메시지를 이용하여 웹 서버의 과부하를 유발시키는 공격, HTTP 캐시 옵션을 조작하여 캐싱 서버가 아닌 웹 서버가 직접 처리하도록 유도, 웹 서버 자원을 소진시키는 서비스 거부 공격
  ㄴ Slowloris: HTTP GET 메서드를 사용하여 헤더의 최종 끝을 알리는 개행 문자열인 \r\n\r\n 을 전송하지 않고 \r\n만 전송하여 대상 웹 서버와 연결상태를 장시간 지속시키고 연결 자원을 모두 소진시키는 서비스 거부 공격
  ㄴ RUDY: 요청 헤더의 Content-Length를 비정상적으로 크게 설정하여 메시지 바디 부분을 매우 소량으로 보내 계속 연결상태를 유지시키는 공격
  ㄴ Slow HTTP Read DoS: TCP 윈도 크기가 데이터 처리율을 감소시킨 상태에서 다수 HTTP 패킷을 지속적으로 전송하여 대상 웹 서버의 연결상태가 장시간 지속, 연결자원을 소진시키는 서비스 거부 공격
  ㄴ Hulk Dos: 공격자가 공격대상 웹 사이트 주소를 지속적으로 변경하면서 다량으로 GET요청을 발생시키는 서비스 거부 공격, 주소를 지속적으로 변경시키는 이유는 임계치 기반의 디도스 대응 장비를 우회하기 위한 방법
  ㄴ Hash Dos: 웹 서버는 클라이언트 HTTP 요청을 통해 전달되는 파라미터를 효율적으로 저장하고 검색하기 위한 자료 구조로 해시테이블을 주로 사용, 공격자는 이러한 특성을 악용하여 조작된 수 많은 파라미터를 POST방식으로 웹 서버로 전달하여 다수의 해시 충돌(Collision)을 발생시켜서 자원을 소모시키는 서비스 거부 공격

258. 네트워크 공격
  ㄴ Sniffing: 공격대상에게 직접 공격하지 않고 데이터만 몰래 들여다보는 수동적 공격
  ㄴ Network Scanner, Sniffer: 네트워크 하드웨어 및 소프트웨어 구성의 취약점 파악을 위해 공격자가 취약점을 탐색하는 공격도구
  ㄴ Passwork Cracking: Dictionary Cracking(패스워드가 될 가능성 있는 단어를 파일로 만들어서 대입해서 공격), Brute Force Cracking(무작위로 패스워드 대입), Password Hybrid Attack(딕셔너리 + 브루트 포스), Rainbow Table Attack(해시 값을 미리 생성해서 테이블에 모아놓고 공격하고자 하는 해시 값을 테이블에서 검색해서 역으로 패스워드 찾는 기법)
  ㄴ IP Spoofing: 침입자가 인증된 컴퓨터 시스템인 것처럼 속여서 타깃 시스템의 정보를 빼내기 위해서 본인의 패킷 해더를 인증된 호스트의 IP 어드레스로 위조하여 타깃에 전송하는 공격기법
  ㄴ ARP Spoofing: ARP Spoofing은 공격자가 특정 호스트의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Reply를 만들어 희생자에게 지속적으로 전송하여 희생자의 ARP Cache Table에 특정 호스트의 MAC 정보를 공격자의 MAC 정보로 변경, 희생자로부터 특정 호스트로 나가는 패킷을 공격자가 스니핑하는 공격
  ㄴ ICMP Redirect: 3계층에서 스니핑 시스템을 네트워크에 존재하는 또 다른 라우터라고 알림으로써 패킷의 흐름을 바꾸는 공격기법, ICMP Redirect 메시지를 공격자가 원하는 형태로 만들어서 특정 목적지로 가는 패킷을 공격자가 스니핑
  ㄴ Trojan horses(트로이 목마): 악성 루틴이 숨어 있는 프로그램으로 겉보기에는 정상적인 프로그램으로 보이지만 실행하면 악성 코드를 실행하는 프로그램

259. Buffer Overflow
  ㄴ 메모리에 할당된 버퍼 크기를 초과하는 양의 데이터를 입력하여 이로 인해 프로세스 흐름을 변경시켜 악성 코드 실행
  ㄴ 스택 버퍼 오버플로우: 메모리 영역 중 Local Value나 함수의 Return Address가 저장되는 스택 영역에서 발생, 스택 영역에 할당 된 버퍼 크기를 초과하는 양의 데이터를 입력하여 복귀 주소를 변경하고 임의의 코드를 실행
  ㄴ 힙 버퍼 오버플로우: 프로그램 실행 시 동적으로 할당되는 힙 영역에 할당된 버퍼 크기를 초과하는 데이터를 입력하여 메모리의 데이터와 함수 주소 등을 변경, 공격자가 원하는 임의의 코드 실행, 인접한 메모리의 데이터가 삭제될 수 있고 해당 위치에 특정 함수에 대한 포인터 주소가 있으면 이를 악용하여 관리자 권한 파일에 접근하거나 특정 코드를 실행함

260. 버퍼 오버플로우 대응방안
  ㄴ 스택가드 활용: 카나리라고 불리는 무결성 체크용 값을 복귀 주소와 변수 사이에 삽입해두고, 버퍼 오버플로우 발생 시 카나리 값을 체크, 변할경우 복귀 주소 호출 하지 않음
  ㄴ 스택쉴드: 함수 시작시 복귀 주소를 Global RET이라는 특수 스택에 저장하고, 함수 종료시 저장값과 RET비교하여 다를경우 오버플로우로 간주ㅡ
  ㄴ ASLR(Address Space Layout Randomization): 메모리 공격을 방어하기 위해 주소 공간 배치를 난수화하고, 실행 시 마다 메모리 주소를 변경시켜 오버플로우 공격 차단
  ㄴ 안전한 함수 활용
  ㄴ 실행 제한

261. 백도어(Backdoor)
  ㄴ 어떤 제품이나 컴퓨터 시스템, 암호시스템 혹은 알고리즘에서 정상적인 인증 절차를 우회하는 기법이다.
  ㄴ 우리말 뒷문이라는 단어의 어감에서 알 수 있듯이 허가 받지 않고 시스템에 접속하는 권리를 얻기 때문에 대부분 은밀하게 작동한다. 
  ㄴ 백도어는 어떤 고정적인 형태가 있는 것은 아니라 프로그램 일부로 감춰져 있을 수도 있고 독자적인 프로그램이나 하드웨어 모습을 갖기도 한다. 
  ㄴ 해커는 백도어를 통해서 이용자 몰래 컴퓨터에 접속하여 악의적인 행위를 하기도 한다.

262. 주요 시스템 보안 공격기법
  ㄴ 포맷 스트링 공격(Format String Attack): 포맷 스트링을 인자로 하는 함수의 취약점을 이용한 공격으로 외부로부터 입력된 값을 검증하지 않고 입출력 함수의 포맷 스트링을 그대로 사용하는 경우 발생하는 취약점 공격기법, printf(argv[1]) 등 포맷 스트링을 인자로 사용 시 포맷 스트링을 지정하지 않고 사용자 입력값을 통해 스트링이 지정된다면 공격자는 이를 조작하여 메모리 내용을 참조하거나 특정 영역 값 변경 가능
  ㄴ 레이스 컨디션 공격(Race Condition Attack): 둘 이상의 프로세스나 스레드가 공유자원을 동시에 접근할 때 접근 순서에 따라 비정상저긴 결과가 발생하는 조건/상황, 실행되는 프로세스가 임시파일을 만드는 경우 악의적인 프로그램을 통해 그 프로세스의 실행 중에 끼어들어 임시파일을 심볼릭 링크하여 악의적인 행위를 수행하게 하는 공격기법
  ㄴ 키로거 공격(Key Logger Attack): 사용자 키보드 움직임을 탐지해서 저장하고, ID나 패스워드, 계좌번호, 카드번호와 같은 개인 정보를 빼가는 해킹 공격, 
  ㄴ 루트킷(Rootkit): 시스템 침입 후 침입 사실을 숨긴 채 차후의 침입을 위한 백도어, 트로이 목마 설치, 원격 접근, 내부 사용 흔적 삭제, 관리자 권환 획득 등 주로 불법적인 해킹에 사용되는 기능을 제공하는 프로그램의 모음

263. 보안 관련 용어
  ㄴ 스피어 피싱(Spear Phishing): 사회 공학의 한 기법으로, 특정 대상을 선정한 후 그 대상에게 일반적인 이메일로 위장한 메일을 지속적으로 발송하여, 발송 메일의 본문 링크나 첨부된 파일을 클릭하도록 유도하여 사용자의 개인정보를 탈취하는 기법
  ㄴ 스미싱(Smishing): 스미싱은 SMS와 Phising의 합성어, 문자메시지를 이용하여 신뢰할 수 있는 사람 또는 기업이 보낸 것 처럼 가장하여 개인 비밀정보를 요구하거나 휴대폰 소액 결제를 유도하는 피싱 공격
  ㄴ 큐싱: QR코드와 피싱의 합성어, 금융 업무를 처리하는 사용자에게 인증 등이 필요한 것 처럼 속영 QR코드를 통해 악성 앱을 내려받도록 유도, 금융 정보 드응ㄹ 빼내는 피싱 공격
  ㄴ 봇넷: 악성 프로그램에 감염되어 악의적인 의도로 사용될 수 있는 다수의 컴퓨터들이 네트워크로 연결된 형태
  ㄴ APT(Advanced Persistent Threat): 특정 타깃을 목표로 하여 다양한 수단을 통한 지속적이고 지능적인 맞춤형 공격, 특수목적의 조직이 하나의 표적에 대해 다양한 IT 기술을 이용하여, 지속적으로 정보를 수집하고, 취약점을 분석하여 피해를 주는 공격기법
  ㄴ 공급망 공격(Supply Chain Attack): 소프트웨어 개발사의 네트워크에 침투하여 소스 코드의 수정 등을 통해 악의적인 코드를 삽입하거나 배포 서버에 접근하여 악의적인 파일로 변경하는 방식을 통해 사용자 PC에 소프트웨어를 설치 또는 업데이트 시 자동적으로 감염되도록 하는 공격기법
  ㄴ 제로데이 공격(Zero Day Attack): 보안 취약점이 발견되어 널리 공표되기 전에 해당 취약점을 악용하여 이루어지는 보안 공격기법, 공격의 신속성을 의미하는 것으로, 일반적으로 컴퓨터에서 취약점이 발견되면 제작자나 개발자가 취약점을 보완하는 패치를 배포하고 사용자가 이를 다운받아 대처하지만, 제로데이 공격은 대응책이 공표되기도 전에 공격이 이루어지기 때문에 대처 방법이 없음
  ㄴ 웜(Worm): 스스로 복제하여 네트워크 등의 연결을 통하여 전파하는 악성 소프트웨어 컴퓨터 프로그램, 컴퓨터 바이러스와 비슷하지만, 바이러스가 다른 실행 프로그램에 기생하여 실행되는 데 반해 웜은 독자적으로 실행되며 다른 실행 프로그램이 필요하지 않은 특징이 있음
  ㄴ 악성 봇(Malicious Bot): 스스로 실행되지 못하고, 해커의 명령에 의해 원격에서 제어 또는 실행이 가능한 프로그램 혹은 코드, 주로 취약점이나 백도어 등을 이용하여 전파되고 스팸 메일 전송이나 분산 서비스 거부 공격 등에 악용, 좀비PC는 악성 봇에 감염된 PC
  ㄴ 사이버 킬 체인: 록히드 마틴의 사이버 킬체인은 공격형 방위시스템으로 지능적, 지속적 사이버공격에 대해 7단계 프로세스별 공격분석 및 대응을 체계화한 APT 공격 방어 분석 모델
  ㄴ 랜섬웨어(Ransomware): 악성 코드의 한 종류로 감염된 시스템의 파일들을 암호화하여 복호화할 수 없도록 하고, 피해자로 하여금 암호화된 파일을 인질로 잡고 값을 요구하는 악성 소프트웨어
  ㄴ 이블 트윈(Evil Twin): 무선 Wifi 피싱 기법으로 공격자는 합법적인 Wifi 제공자처럼 행세하며 노트북이나 휴대 전화로 핫스팟에 연결한 무선 사용자들의 정보를 탈취하는 무선 네트워크 공격기법
  ㄴ 난독화(Obfuscation): 코드의 가독성을 낮춰 역공학에 대한 대비를 하기 위해서 프로그램 코드의 일부 또는 전체를 변경하는 기법, 난독화를 적용하는 범위에 따라 소스 코드 난독화와 바이너리 난독화로 나눔
  ㄴ Tripwire: 크래커가 침입하여 시스템에 백도어를 만들어 놓거나 설정 파일을 변경해 놓았을 때 이러한 사실을 알 수 있게 분석하는 도구, 시스템 내의 중요한 디렉토리 파일에 대한 데이터베이스 생성 후 새로 생성된 데이터베이스와 비교하여 차이점을 체크함으로서 변화를 감지
  ㄴ Ping: 인터넷으로 접속하려는 원격 호스트가 정상적으로 운영되고 있는지를 확인하는 진단 목적으로 사용하는 명령어
  ㄴ Tcpdump: 네트워크 인터페이스를 거치는 패킷의 내용을 출력해주는 프로그램, 스니핑 도구의 일종으로 자신의 컴퓨터로 들어오는 모든 패킷의 내용을 도청할 수 있으며, 공격자에 대한 추적 및 공격 유형 분석을 위한 패킷 분석 시 활용할 수 있는 도구

264. 서버 인증 기술 유형: 지소생특
  ㄴ 지식기반: 사용자가 기억하고 있는 지식, ID, Password 등
  ㄴ 소지기반: 소지하고 있는 사용자 물품, 공인인증서, OTP 등
  ㄴ 생체기반: 고유한 사용자의 생체 정보, 홍채, 정맥, 얼굴, 지문 등
  ㄴ 특징기반: 사용자의 특징을 활용, 서명, 발걸음, 몸짓 등

265. 접근 통제 유형
  ㄴ 임의적 접근 통제(DAC; Discretionary Access Control): 시스템에 대한 접근을 사용자/그룹의 신분 기반으로 제한하는 방법, DAC에서 사용자는 자원과 관련된 ACL(ACCESS CONTROL LIST)이 수정됨으로써 자원에 대한 권한을 부여
  ㄴ 강제적 접근 통제(MAC:Mandatory Access Control): 시스템 정보의 허용등급을 기준으로 사용자가 갖는 접근 허가 권한에 근거하여 시스템에 대한 접근을 제한하는 방법, MAC에서 사용자들은 자원에 대한 권한을 관리자로부터 부여, 관리자만이 시스템 자원에 대한 권한을 할당할 수 있음
  ㄴ 역할기반 접근 통제(RBAC; Role Based Access Control): 중앙 관리자가 사용자와 시스템의 상호관계를 통제하며 조직 내 맡은 역할에 기초하여 자원에 대한 접근을 제한하는 방법, RBAC에서 자원에 대한 접근은 사용자에게 할당된 역할에 기반, 관리자는 사용자에게 특정한 권리와 권한이 정의된 역할을 할당

266. 접근 통제 보호 모델: 벨기비무(벨 라파듈라 - 기밀성, 비바 - 무결성)
  ㄴ 벨-라파듈라 모델(BLP; Bell-LaPadula Policy): 미 국방부 지원 보안 모델로 보안 요소 중 기밀성을 강조하며 강제적 정책에 의해 접근 통제하는 모델
      No Read Up, No Write Down
  ㄴ 비바 모델: 벨-라파듈라 모델의 단점을 보완한 무결성을 보장하는 최초의 모델
      No Read Down, No Write Up

267. 암호 알고리즘(Encryption Algorithm) 개념
  ㄴ 데이터의 무결성 및 기밀성 확보를 위해 정보를 쉽게 해독할 수 없는 형태로 변환하는 기법

268. 대칭 키 암호: 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘
  ㄴ 블록 암호 방식: 긴 평문을 암호화하기 위해 고정 길이의 블록을 암호화하는 블록 암호 알고리즘을 반복
  ㄴ 스트림 암호: 매우 긴 주기의 난수열을 발생시켜 평문과 더불어 암호문을 생성하는 방식
  ㄴ 암호화 키 = 복호화 키, 암호 알고리즘을 공개, 계산 속도가 빠르나 키 분배 및 관리의 어려움, 기밀성만 보장됨

269. 비대칭 키 암호(=공개 키 암호): 사전에 개인 키를 나눠 가지지 않은 사용자들이 안전하게 통신하는 방식, 공개키로 암호화된 메시지는 반드시 비밀키로 복호화, 비대칭 키 암호 방식에서는 공개키와 비밀키가 존재하며, 공개키는 누구나 알 수 있지만, 그에 대응하는 비밀키는 소유자만이 알 수 있어야 한다.
  암호화 키 /= 복호화 키, 암호 알고리즘을 공개, 암호화 키 사전 공유 불필요, 관리해야할 키 개수가 적은 장점이 있다. 하지만 계산 속도가 느림

270. 해시 암호 방식(일방향 암호화): 임의 길이의 정보를 입력받아, 고정된 길이의 암호문(해시값)을 출력하는 암호 방식잉다. 해시 암호화 알고리즘이 적용된 정보는 복호화가 불가능하다.
  ㄴ MAC: MAC은 키를 사용하는 메시지 인증 코드로 메시지의 무결성과 송신자의 인증 보장
  ㄴ MDC: MDC는 키를 사용하지 않는 변경 감지 코드로 메시지의 무결성 보장

271. 대칭 키 암호화 알고리즘
  ㄴ DES(Data Encryption Standard): 1975년 미국 연방 표준국에서 바료한 대칭 키 기반 블록 암호화 알고리즘, 블록 크기는 64bit, 키 길이는 54BIT인 페이스텔 구조, DES를 3번 적용하여 보안을 더욱 강화한 3DES도 활용됨
  ㄴ AES(Advanced Encryption Standard): 2001년 미국 표준 기술 연구소에서 발표한 블록 암호화 알고리즘, DES의 개의 키에 대한 전사적 공격이 가능해지고 3DES 성능문제를 극복하기 위해 개발, 블록 크기는 128비트이며 키 길이에 따라 128, 192, 256비트로 분류
  ㄴ SEED: 1999 국내 한국인터넷진흥원이 개발한 블록 암호화 알고리즘, 128비트 비밀키로부터 생성된 16개의 64비트 라운드 키를 사용하여 총 16회의 라운드를 거쳐 128비트 평문 블록을 128비트 암호문 블록으로 암호화하여 출력하는 방식, 블록 크기는 128비트이며, 키 길이에 따라 128, 256으로 분류
  ㄴ ARIA(Academy, Research Institute, Agency): 2004년 국가정보원과 산학연구 협회가 개발한 블록 암호화 알고리즘, Academy, Research Institute, Agency의 영문 앞글자로 구성, 블록 크기는 128비트이며, 키 길이에 따라 128, 192, 256비트로 분류, ARIA는 경량 환경 및 하드웨어에서의 효율성 향상을 위해 개발되었으며, ARIA가 사용하는 대부분의 연산은 XOR과 같은 단순한 바이트 단위 연산으로 구성
  ㄴ IDEA(International Data Encryption Algorithm): DES를 대체하기 위해 스위스 연방기술 기관에서 개발한 블록 암호화 알고리즘, 128비트의 키를 사용하여 64비트의 평문을 8라운드에 거쳐 64비트의 암호문으로 만듦
  ㄴ LFSR(Linear Feedback Shift Register): 선형 되먹임 시프트 레지스터 시프트 레지스터의 일종으로, 레지스터에 입력되는 값이 이전 상태 값들의 선형 함수로 계산되는 구조로 되어있는 스트림 암호화 알고리즘, 주로 사용되는 선형 함수는 XOR이고, LFSR의 초기 비트 값은 시드라고 함

272. 비대칭 키 암호화 알고리즘
  ㄴ 디피-헬만(Diffie-Hellman): 최초의 공개키 알고리즘으로 디피와 헬만이 1976년에 고안한 알고리즘으로서 유한 필드 내에서 이산대수 계산이 어려운 문제를 기본 원리로 하고 있음, 공개키 암호 방식의 개념을 이용하여 두 사용자 간에 공통의 암호화 키를 안전하게 공유할 비법을 제시하였으며, 많은 키 분배 방식에 관한 연구의 기본이 됨
  ㄴ RSA(Rivest- Shamir- Adleman): 1977년  3명의 MIT 수학 교수가 고안한 큰 인수의 소인수 분해하는 수학적 알고리즘 이용하는 공개키 암호화 알고리즘, 비밀키의 복호화가 어려운 RSA 안전성은 소인수 분해 문제의 어려움에 근거를 두고 있음
  ㄴ ECC(Elliptic Curve Cryptography): 1985년 코블리치와 밀러가 RSA 암호 방식에 대한 대안으로 처음 제안, 타원 곡선 암호(ECC)는 유한체 위에서 정의된 타원곡선 군에서의 이산대수의 문제에 기초한 공개키 암호화 알고리즘, RSA의 문제점인 속도와 안전성 해결하기 위해 타원 기반 구조체의 안정성과 효율성을 기반으로 생성되었고, RSA보다 키의 비트 수를 적게하면서 동일한 성능을 제공하는 것이 가장 큰 특징
  ㄴ ElGamal: 이산대수의 개산이 어려운 문제를 기본 원리로 하고 있으며, RSA와 유사하게 전자서명과 데이터 암복호화에 함께 사용 가능

273. 해시 암호화 알고리즘
  ㄴ MD5(Message-Digest algorithm 5): MD4를 개선한 암호화 알고리즘으로 프로그램이나 파일의 무결성 검사에 사용, 각각의 512비트짜리 입력 메시지 블록에 대해 차례로 동작하여 128비트의 해시값을 생성하는 해시 알고리즘
  ㄴ SHA-1(Secure Hash Algorithm): NSA에서 미 정부 표준으로 지정되었고 DSA(Digital Signature Algorithm)에서 사용, 160비트의 해시값을 생성하는 해시 알고리즘
  ㄴ SHA-256/384/512: 256비트의 해시 값을 생성하는 해시 함수, AES의 키 길이인 128, 196, 256비트에 대응하도록 출력 길이를 늘인 해시 알고리즘
  ㄴ HAS-160: 국내 표준 서명 알고리즘 KCDSA를 위하여 개발된 해시함수, MD5와 SHA1의 장점을 취하여 개발된 해시 알고리즘

274. IP Sec(Internet Protocol Security)개념
  ㄴ IP Sec는 IP 계층에서 무결성과 인증을 보장하는 인증 헤더(AH)와 기밀성을 보장하는 암호화(ESP)를 이용한 IP 보안 프로토콜이다.
  ㄴ IPSec의 기능: 기밀성, 비연결형 무결성, 인증, 재전송 공격 방지, 접근 제어
  ㄴ IPSec 동작 모드: 전송모드(IP패킷의 페이로드를 보호하는 모드, IP 상위 프로토콜 데이터를 보호하는 모드), 터널모드(IP패킷 전체를 보호하는 모드, 패킷 전체를 IPSec으로 캡슐화하여 헤더를 식별할 수 없기 때문에 네트워크상 패킷 전송이 불가능, 전송구간 주소 정보 담은 New IP 헤더 추가)

275. IPSec Protocol
  ㄴ 인증(AH) 프로토콜: 메시지 인증 코드(MAC)을 이용하여 인증과 송신처 인증을 제공해주는 프로토콜로 기밀성은 제공하지 않는 프로토콜, 무결성, 인증 제공
  ㄴ 암호화(ESP) 프로토콜: 메시지 인증 코드와 암호화를 이용하여 인증과 송신처 인증과 기밀성을 제공하는 프로토콜, 기밀성, 무결성, 인증 제공
  ㄴ 키 관리(IKE) 프로토콜: Key를 주고받는 알고리즘, 공개된 네트워클르 통하여 키를 어떻게 할 것인가를 정의, IKE 교환을 위한 메ㅣ지를 전달하는 프로토콜
  
276. SSL/TLS(Secure Socket Layer/Transport Layer Security) 개념
  ㄴ SSL/TLS는 전송계층과 응용계층 사이에서 클라이언트와 서버 간의 웹 데이터 암호화(기밀성), 상호 인증 및 전송 시 데이터 무결성을 보장하는 보안 프로토콜이다.

277. SSL/TLS 특징
  ㄴ Netscaape사가 웹 보안을 위해 처음 개발
  ㄴ 다양한 암호 통신 방법 활용: 대칭키, 공개키, 해시함수, 메시지 인증코드, 의사난수생성기, 전자서명 조합하여 암호화 통신 수행
  ㄴ 특정 암호기술에 의존하지 않음: 암호 도구 목록을 변경하여 강력한 알고리즘 사용, HTTP를 올려 HTTPS로 변경되어 사용

278. SSL/TLS 보안 기능: 기밀성, 상호인증, 메시지 무결성

279. S-HTTP(Secure Hypertext Transfer Protocol)
  ㄴ 웹상에서 네트워크 트래픽을 암호화하는 주요 방법 중 하나로 클라이언트와 서버 간에 전송되는 모든 메시지를 각각 암호화하여 전송하는 기술

280. 개인정보보호 관련 법령: 개망신
  ㄴ 개인정보 보호법: 개인정보 처리 과정상의 정보 주체와 개인정보 처리자의 권리, 의무 등 규정
  ㄴ 정보통신망 이용촉진 및 정보보호 등에 관한 법률: 정보통신망을 통하여 수집, 처리, 보관, 이용되는 개인정보의 보호에 관한 규정
  ㄴ 신용정보의 이용 및 보호에 관한 법률: 개인 신용정보의 취급 단계별 보호조치 및 의무사항에 관한 규정

281. SW 개발 보안 적용 사례
  ㄴ BSIMM(Building Security In Maturity Model): 미국 국토안보국의 지원을 받아 수행된 소프트웨어 보증 프로젝트의 결과물 중 하나, 보안 활동의 성숙도 수준을 영역별로 측정함으로써 소프트웨어 개발에 필요한 보안 능력 향상을 목표로하는 개발 프레임워크
  ㄴ Open SAMM(Software Assurance Maturity Model): OWASP에서 개발한 개방형 보완 프레임워크, 개방을 원치긍로 소, 중, 대규모 점진적 확대 가능한 융통성 있는 프레임워크, BSIMM과는 달리 설계 리뷰와 코드 리뷰, 그리고 보안 테스팅을 3개의 중요한 검증 활동으로 정의함으로써 이들 활동간의 연계성 강조
  ㄴ Seven Touch Points: 실무적으로 검증된 개발 보안 방법론 중 하나로써 SW 보안의 모범사례를 SDLC(Software Development Life Cycle)에 통합한 소프트웨어 개발 보안 생명주기 방법론
  ㄴ MS SDL(Security Development Lifecycle): 마이크로 소프트사가 2004년 이후 자사의 소프트웨어 개발에 의무적으로 적용하도록 고안한 보안강화 프레임워크, SDL은 개발 중인 제품이 보안 위협에 대해 얼마나 강인한가를 측정하기 위해 pre-SDL과 post SDL 의 두개의 버전으로 테스트 
  ㄴ OWASP CLASP: 개념 관점, 역할기반 관점, 활동평가 관점, 활동구현 관점, 취약성 관점 등의 활동중심, 역할기반의 프로세스로 구성된 보안 프레임워크로 이미 운영 중인 시스템에 적용하기 쉬운 보안 개발방법론, 프로그램 설계나 코딩 오류를 찾아내어 개선하기 위해 개발팀에 취약점 목록을 제공

282. 시큐어 코딩 가이드: 설계 및 구현 단계에서 해킹 등의 공격을 유발할 가능성이 있는 잠재적인 보안 취약점을 사전에 제거하고, 외부 공격으로부터 안전한 소프트웨어를 개발하는 기법이다. 소프트웨어 보안 약점을 방지하기 위한 시큐어 코딩 가이드에 따른 개발 수행이 필요하다.

283. 시큐어 코딩 가이드 적용대상: 입보시 에코캡아
  ㄴ 입력데이터 검증 및 표현
  ㄴ 보안기능
  ㄴ 시간 및 상태
  ㄴ 에러 처리
  ㄴ 코드 오류
  ㄴ 캡슐화
  ㄴ API 오용

284. 입력 데이터 검증 및 표현 취약점
  ㄴ XSS(Cross Site Script): 검증되지 않은 외부 입력 데이터가 포함된 웹페이지가 전송되는 경우, 사용자가 해당 웹페이지를 열람함으로써 페이지에 포함된 부적절한 스크립트가 실행 되는 공격
  ㄴ 사이트 간 요청 위조(CSRF; Cross-Site Request Forgery): 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 하는 공격
  ㄴ SQL 삽입(Injection): 응용 프로그램의 보안 취약점을 이용해서 악의적인 SQL 구문을 삽입, 실행시켜서 데이터베이스의 접근을 통해 정보를 탈취하거자 조작 등의 행위를 하는 공격기법

285. XSS 공격 유형
  ㄴ Stored XSS: 방문자들이 악성 스크립트가 포함된 페이지를 읽어 봄과 동시에 악성 스크립트가 브라우저에서 실행되면서 감염되는 기법
  ㄴ Reflected XSS: 공격용 악성 URL을 생성한 후 이메일로 사용자에게 전송, 주소 클릭 시 즉시 공격 스크립트가 피해자로 반사되어 접속 사이트에 민감 정보를 공격자에게 전송
  ㄴ DOM(Document Object Model XSS): 공격자는 DOM 기반 XSS 취약점이 있는 브라우저를 대상으로 조작된 주소를 이메일을 통해 발송하고 클릭 시 공격 피해 당하는 기법

286. SQL 삽입 공격 유형
  ㄴ Form SQL Injection
  ㄴ Union SQL Injection
  ㄴ Stored Procedure SQL Injection
  ㄴ Mass SQL Injection
  ㄴ Error-Based SQL Injection
  ㄴ Blind SQL Injection

287. 보안기능 개념: 보안 기능은 소프트웨어 개발 단계에서 인증, 접근제어, 기밀성, 암호화, 권한 관리 등을 적절하게 구현하기 위한 보안 점검 항목들이다.

288. 보안기능 취약점
  ㄴ 적절한 인증 없이 중요 기능 허용
  ㄴ 부적절한 인가
  ㄴ 취약한 암호화 알고리즘 사용
  ㄴ 중요 정보 평문 저장 및 전송
  ㄴ 하드 코드 된 비밀번호

289. 에러 처리 개념: 프로그램 실행 시 발생하는 에러를 예외 처리하지 못하거나, 에러 정보에 중요한 정보가 포함될 때 발생할 수 있는 취약점을 예방하기 위한 보안점검 항목들, 각 프로그래밍 언어의 예외 처리 구문을 통해 오류에 대한 사항을 정의하지 않으면 중요정보를 노출시키거나, 실행이 중단되는 등 예기치 못한 문제 발생

290. 에러 처리 취약점
  ㄴ 취약한 패스워드 요구 조건
  ㄴ 오류 메시지 통한 정보 노출
  ㄴ 오류 상황 대응 부재
  ㄴ 적절하지 않은 예외 처리

291. 세션 통제 개념: 다른 세션 간 데이터 공유 등 세션과 관련되어 발생하 수 있는 취약점 예방하기 위한 보안 점검 항목, 이미 연결이 종료된 클라이언트의 정보가 사용 가능한 상태로 방치되는 경우 허가되지 않은 사용자가 시스템에 접근할 수 있는 약점이 있다.

292. 세션 통제 취약점: 불충분한 세션 관리

293. 코드 오류 개념: 소프트웨어 구현 단계에서 프로그램 변환 시 오류, 서버의 리소스 자원의 부적절한 반환 등 개발자가 흔하게 실수하는 프로그램 오류를 예방하기 위한 보안 점검 항목

294. 코드 오류 취약점
  ㄴ 널 포인터 역참조
  ㄴ 정수를 문자로 변환
  ㄴ 부적절한 자원 해제
  ㄴ 초기화되지 않은 변수 사용

295. 캡슐화 개념: 외부에 은닉이 필요한 중요한 데이터와 필요한 기능성을 불충분하게 캡슐화 했을 때 인가되지 않은 사용자에게 데이터 유출, 권한 문제 등이 발생할 수 있는 보안 취약점 예방을 위한 항목

296. 캡슐화 취약점
  ㄴ 잘못된 세션에 의한 정보 노출
  ㄴ 제거되지 않고 남은 디버그 코드
  ㄴ 민감한 데이터를 가진 내부 클래스 사용
  ㄴ 시스템 데이터 정보 노출

297. API 오용 개념: 서비스에서 제공되는 이용에 반하는 방법으로 API를 이용하거나 보안에 취약한 API를 오용하여 발생할 수 있는 보안 취약점 예방을 위한 보안 검증 항목들

298. API 오용 취약점
  ㄴ DNS Lookup에 의존한 보안 결정
  ㄴ 위험하다고 알려진 함수 사용
  ㄴ 널 매개변수 미검사

299. 네트워크 보안 솔루션
  ㄴ 방화벽(Firewall): 기업 내부, 외부 간 트래픽을 모니터링 하여 시스템의 접근을 허용하거나 차단하는 시스템
  ㄴ 웹 방화벽(WAF; Web Application Firewall): 일반적인 네트워크 방화벽과는 달리 웹 애플리케이션 보안에 특화된 보안장비, SQL 인젝션, XSS 같은 웹 공격 탐지 및 차단
  ㄴ 네트워크 접근 제어(NAC; Network Access Control): 단말기가 내부 네트워크에 접속을 시도할 떄 이를 제어하고 통제하는 기능을 제공하는 솔루션, 바이러스나 웜 등의 보안위협으로 부터 네트워크 제어 및 통제기능 수행
  ㄴ 침입 탐지 시스템(IDS; Intrusion Detection System): 네트워크에서 발생하는 이벤트를 모니터링하고 비인가 사용자에 의한 자원접근과 보안정책 위반 행위(침입)을 실시간으로 탐지하는 시스템
  ㄴ 침입 방지 시스템(IPS; Intrusion Prevention System): 네트워크에 대한 공격이나 임입을 실시간으로 차단하고, 유해 트래픽에 대한 조치를 능동적으로 처리
  ㄴ 무선 침입 방지 시스템(WIPS; Wireless Intrusion Prevention System): 인가되지 않은 무선 단말기의 접속을 자동으로 탐지 및 차단, 보안에 취약한 무선 공유기 탐지
  ㄴ 통합 보안 시스템(UTM; Unified Threat Management): 방화벽, IDS, IPS, VPN, 안티바이러스 이메일 필터링 등 다양한 보안 장비의 기능을 하나의 장비로 통합하여 제공하는 시스템
  ㄴ 가상사설망(VPN; Virtual Private Network): 인터넷과 같은 공중망에 인증, 암호화, 터널링 기술을 활용하여 마치 전용망을 사용하는 효과를 가지는 보안 솔루션

300. 시스템 보안 솔루션
  ㄴ 스팸 차단 솔루션(Anti Spam Solution): 메일 서버 앞단에 위치하여 프록시 메일 서버로 동작, 메일 바이러스 검사, 내부 ->외부 본문 검색 기능 통한 내부 정보 유출 방지
  ㄴ 보안 운영체제(Secure OS): 컴퓨터 운영체제 커널에 보안 기능 추가, 운영체제ㅔ 내재된 결함으로 인해 발생할 수 있는 각종 해킹 공격으로부터 시스템을 보호하기 위해 보안 기능 통합된 보안 커널을 추가한 운영체제

301. 콘텐츠 유출 방지 보안 솔루션
  ㄴ 보안 USB: 정보 유출 방지 등의 보안 기능을 갖춘 USB, 사용자 식별/인증, 데이터 암/복호화, 임의복제 방지, 분실 시 데이터 삭제 기능
  ㄴ 데이터 유출 방지(DLP; Data Loss Prevention): 조직 내부 중요 자료가 외부로 빠져나가는 것을 탐지 및 차단, 정보 흐름에 대한 모니터링과 실시간 차단 기능
  ㄴ 디지털 저작권 관리(DRM; Digital Right Management): MP3, E-Book과 같은 디지털 저작물에 대한 보호와 관리를 위한 솔루션, 파일 자체에 암호를 걸어 권한 없는 사용자는 금지, 

302. 취약점 분석 대상: 환경 및 시설, 하드웨어, 소프트웨어

303. 취약점 분석 절차: 자진 제진결보(자산 조사 및 분석 -> 진단 대상 선정 -> 제약사항 확인 -> 진단 수행 -> 결과 분석/보고서 작성

304. 비즈니스 연속성 계획(BCP; Business Continuity Plan): 각종 재해, 장애, 재난으로부터 위기관리를 기반으로 재해복구, 업무복구 및 재개, 비상계획 등을 통해 비즈니스 연속성 보장하는 체계

305. 비즈니스 연속성 계획 관련 용어
  ㄴ BIA(Business Impact Analysis): 장애나 재해로 인해 운영상의 주요 손실을 볼 것을 가정하여 시간 흐름에 따른 영향도 및 손실평가를 조사하는 BCP를 구축하기 위한 비즈니스 영향 분석
  ㄴ RTO(Recovery Time Objective): 업무중단 시점부터 업무가 복구되어 다시 가동될 때 까지의 시간, 재해 시 복구 목표 시간의 선정
  ㄴ RPO(Recovery Point Objective): 업무중산 시점부터 데이터가 복구되어 다시 정상가동될 때 데이터의 손실 허용 시점, 재해 시 복구 목표 지점의 선정
  ㄴ DRP(Disaster Recovery Plan): 재난으로 장기간에 걸쳐 시설의 운영이 불가능한 경우를 대비한 재난 복구 계획
  ㄴ DRS(Disaster Recovery System): 재해복구계획의 원활한 수행을 지원하기 위하여 평상시에 확보하여 두는 인적, 물적 자원 및 이들에 대한 지속적인 관리체계가 통합된 재해복구센터

306. DRS 유형
  ㄴ Mirror Site: 주 센터와 데이터복구센터 모두 운영 상태로 실시간 동시 서비스가 가능한 재해복구센터, 재해 발생 시 복구까지 소요시간은 즉시
  ㄴHot Site: 주 센터와 동일한 수준의 자원을 대기상태로 원격지에 보유하면서 동기, 비동기 방식의 미러링을 통하여 최신 상태 유지하는 복구센터, RTO는 4시간 이내
  ㄴ Warm Site: Hot site와 유사하나 동일한 수준의 자원을 대기 상태로 원격지 보유하는 대신 중요성 높은 자원만 부분적으로, RTO는 수일~수주, 백업 주기가 수시간 ~ 1일
  ㄴ Cold Site: 데이터만 원격지에 보관하고 재해시 데이터를 근간으로 필요 자원 조달하여 복구 RTO는 수주~수개월, 저렴하나 시간 길고 신뢰성 낮음

307. 보안 관련 중요 용어
  ㄴ 부채널 공격(Side Channel Attack)
  ㄴ 드라이브 바이 다운로드(Drive By Download)
  ㄴ 워터링 홀(Watering Hole)
  ㄴ 스캠(SCAM)
  ㄴ 하트 블리드(Heart Bleed)
  ㄴ 크라임웨어(Crimeware)
  ㄴ 프로토콜 취약점(IoT-SSDP; Simple Service Discovery Protocol)
  ㄴ 윈드 토커(Wind Talker)
  ㄴ 토르 네트워크(Tor network)
  ㄴ 멜트다운(Meltdown)
  ㄴ 스펙터(Specter)
  ㄴ MITM(Man in the Middle)
  ㄴ DNS spoofing
  ㄴ Port Scanning
  ㄴ Directory Listing
  ㄴ Reverse Shell
  ㄴ Exploit
  ㄴ Stuxnet
  ㄴ Credential Stuffing

308. 보안 공격 대응 관련 중요 용어
  ㄴ Honeypot
  ㄴ OWASP Top 10
  ㄴ Finger Printing
  ㄴ Water Marking
  ㄴ 이상금융거래탐지시스템(FDS; Fraud Detection System)
  ㄴ CPTED(Crime Prevent Through Environment Design)
  ㄴ CC(Common Criteria)
  ㄴ 사이버 위협정보 분석 공유시스템(C-TAS; Cyber Threats Analysis System)
  ㄴ 장착형 인증 모듈(PAM; Pluggable Authentication Module)
  ㄴ CVE(Common Vulnerabilities and Exposures)
  ㄴ CWE(Common Weakness Enumeration)
  ㄴ CVSS(Common Vulnerability Scoring System)

309. 소프트웨어 테스트 개념: 개발된 응용 애플리케이션이나 시스템이 사용자가 요구하는 기능과 성능, 사용성, 안정성 등을 만족하는지 확인하고ㅡ, 노출되지 않은 결함을 찾아내는 활동

310. 소프트웨어 테스트 필요성: 발예향
  ㄴ 오류 발견 관점: 잠재된 오류 발견 및 수정하기 위해 필요
  ㄴ 오류 예방 관점: 동료 검토, 워크스루, 인스펙션 등을 통해 오류를 사전에 예방
  ㄴ 품질 향상 관점: 사용자의 요구사항 및 기대 수준 만족하도록 반복적 테스트 거쳐 신뢰도 향상

311. 소프트웨어 테스트의 기본 원칙: 결완초집 살정오
  ㄴ 테스팅은 결함이 존재함을 밝히는 것: 결함이 존재함을 밝히는 활동, 결함이 없다는 것을 증명할 수는 없음
  ㄴ 완벽한 테스팅은 불가능: 완벽하게 테스팅하려는 시도는 불필요한 시간과 자원낭비, 무한경로, 무한 입력값으로 인한 테스트 어려움
  ㄴ 개발 초기에 테스팅 시작: 조기 테스트 설계 시 장점: 테스팅 결과를 단시간에 알 수 있고, 테스팅 기간 단축, 재작업을 줄여 개발 기간 단축 및 결함예방, SW 개발 초기 체계적인 분석 및 설계가 수행되지 못하면 그 결과가 프로젝트 후반에 영향을 미치게 되어 비용이 커진다는 요르돈의 법칙 적용(Snowball Effect)
  ㄴ 결함집중: 적은 수의 모듈에서 대다수의 결함이 발견됨, 오류의 80%는 전체 모듈의 20% 내에서 발견, 파레토 법칙의 내용인 80대 20 법칙 적용
  ㄴ 살충제 패러독스: 동일한 테스트 케이스에 의한 반복적 테스트는 새로운 버그를 찾지 못함, 테스트 케이스의 정기적 리뷰와 개선 및 다른 시각에서의 접근이 필요
  ㄴ 테스팅은 정황에 의존적: 소프트웨어의 성격에 맞게 테스트 실시, 정황과 비즈니스 도메인에 따라 테스트를 다르게 수행
  ㄴ 오류-부재의 궤변: 요구사항을 충족시켜주지 못한다면, 결함이 없다고 해도 품질이 높다고 볼 수 없음

312. 소프트웨어 테스트 프로세스
  ㄴ 계획
  ㄴ 분석 및 디자인
  ㄴ 테스트 케이스 및 시나리오 작성
  ㄴ 테스트 수행
  ㄴ 테스트 결과 평가 및 리포팅

313. 소프트웨어 테스트 산출물
  ㄴ 테스트 계획서: 목적과 범위 정의, 대상 시스템 구조 파악, 테스트 수행 절차, 테스트 일정, 조직의 역할 및 책임 정의, 종료 조건 정의 등 수행을 계획한 문서
  ㄴ 테스트 베이시스: 분석, 설계 단계의 논리적인 케이스로 테스트 설계를 위한 기준이 되는 문서
  ㄴ 테스트 케이스: 테스트를 위한 설계 산출물로, 응용 소프트웨어가 사용자의 요구사항을 준수하는지 확인하기 위해 설계된 입력값, 실행조건, 기대 결과로 구성된 테스트 항목의 명세서
  ㄴ 테스트 슈트: 테스트 케이스를 실행환경에 따라 구분해 놓은 테스트 케이스의 집합, 단 시나리오가 포함되지 않은 단순한 테스트 케이스들의 모음
  ㄴ 테스트 시나리오: 애플리케이션의 테스트 되어야 할 기능 및 특징, 테스트가 필요한 상황을 작성한 문서, 하나의 단일 테스트 시나리오가 하나 또는 여러개의 테스트 케이스들을 포함할 수 있음, 테스트 시나리오가 테스트 케이스와 일 대 다의 관계를 가짐
  ㄴ 테스트 스크립트: 테스트 케이스의 실행 순서를 작성한 문서, 테스트 스텝, 테스트 절차서라고도 함
  ㄴ 테스트 결과서: 테스트 결과를 정리한 문서로 테스트 프로세스를 리뷰하고, 테스트 결과를 평가하고 리포팅하는 문서

314. 프로그램 실행 여부에 따른 분류
  ㄴ 정적 테스트: 테스트 대상을 실행하지 않고 구조를 분석하여 논리성을 검증하는 테스트, 리뷰/정적분석
  ㄴ 동적 테스트: 소프트웨어를 실행하는 방식으로 테스트를 수행하여 결함을 검출하는 테스트, 화이트박스/블랙박스/경험기반 테스트

315. 화이트박스 테스트: 각 응용 프로그램의 내부 구조와 동작을 검사하는 소프트웨어 테스트
  ㄴ 코드 분석과 프로그램 구조에 대한 지식을 바탕으로 문제가 발생할 가능성이 있는 모듈 내부를 테스트 하는 방법이다.
  ㄴ 소스코드의 모든 문장을 한 번 이상 수행함으로써 진행되고, 산출물의 기능별로 적절한 프로그램의 제어 구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검한다.
  ㄴ 내부 소스코드의 동작을 개발자가 추적할 수 있기 때문에, 동작의 유효성 뿐만 아니라 실행되는 과정을 확인할 수 있다.

316. 화이트박스 테스트 유형: 구결조 조변다 기제데
  ㄴ 구문 커버리지(Statement Coverage): 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지
  ㄴ 결정 커버리지(Decision Coverage): 각 분기의 결정 포인트 내의 전체 조건식이 적어도 한 번은 참과 거짓의 결과를 수행하는 테스트 커버리지, 구문 커버리지를 포함
  ㄴ 조건 커버리지(Condition Coverage): 각 분기의 결정 포인트 내의 각 개별 조건식이 적어도 한 번은 참과 거짓의 결과가 되도록 수행하는 테스트 커버리지, 구문 커버리지를 포함
  ㄴ 조건/결정 커버리지: 전체 조건식 뿐만 아니라 개별 조건식도 참 한번, 거짓 한 번 결과가 되도록 수행하는 테스트 커버리지
  ㄴ 변경 조건/결정 커버리지: 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 함으로써 조건/결정 커버리지를 향상시킨 커버리지
  ㄴ 다중 조건 커버리지(Multiple Condition Coverage): 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 커버리지
  ㄴ 기본 경로 커버리지(Base Path Coverage): 기본 경로 커버리지는 수행 가능한 모든 경로를 테스트하는 기법
  ㄴ 제어 흐름 테스트(Control Flow Testing): 프로그램 제어 구조를 그래프 형태로 나타내어 내부로직을 테스트하는 기법
  ㄴ 데이터 흐름 테스트(Data Flow Testing): 제어 흐름 그래프에 데이터 사용현황을 추가한 그래프를 통해 테스트하는 기법

317. 블랙박스 테스트: 프로그램 외부 사용자의 요구사항 명세를 보면서 수행하는 테스트(기능 테스트)이다.
  ㄴ 소프트웨어의 특징, 요구사항, 설계 명세서 등에 초점을 맞춰 테스트가 이루어진다.
  ㄴ 기능 및 동작 위주의 테스트를 진행하기 때문에 내부 구조나 작동 원리를 알지 못해도 가능하다.
  ㄴ 곧 명세 테스트라고도 불린다.

318. 블랙박스 테스트 유형: 동경결상 유분페원비
  ㄴ 동등분할 테스트(Equivalence Partitioning Testing): 입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 대푯값 테스트 케이스를 도출하여 테스트 하는 기법
  ㄴ 경곗값 분석 테스트(Boundary Value Analysis Testing): 등가 분할 후 경곗값 부분에서 오류 발생 확률이 높기 때문에 경곗값을 포함하여 테스트 케이스를 설계하여 테스트, 최솟값 바로 위, 최대치 바로 아래 등 입력값의 극한 한계를 테스트
  ㄴ 결정 테이블 테스트(Decision Table Testing): 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합하여 테스트하는 기법
  ㄴ 상태 전이 테스트(State transition Testing): 테스트 대상, 시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트
  ㄴ 유스케이스 테스트(Use Case Testing): 시스템이 실제 사용되는 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트케이스를 명세화하여 수행하는 테스트
  ㄴ 분류 트리 테스트(Classification Tree Method Testing): SW의 일부 또는 전체를 트리 구조로 분석 및 표현하여 테스트 케이스를 설계하여 테스트
  ㄴ 페어와이즈(Pairwise Testing): 테스트 데이터 값들 간에 최소 한 번 씩 조합하는 방식이며, 이는 커버해야할 기능적 범위를 모든 조합에 비해 상대적으로 적은 양의 테스트 세트를 구성하기 위한 테스트 기법
  ㄴ 원인-결과 그래프 테스트(Cause-Effect Graphing Testing): 그래프를 활용하여 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정하여 테스트하는 기법
  ㄴ 비교 테스트(Comparison): 여러 버전의 프로그램 같은 입력값을 넣어서 동일한 결과 데이터가 나오는지 비교해 보는 테스트 기법

319. 테스트 시각에 따른 분류
  ㄴ 검증(Verification): 소프트웨어 개발 과정을 테스트, 올바른 제품을 생산하고 있는지 검증, 이전 단계에서 설정된 개발 규격과 요구를 충족시키는지 판단, 개발자 혹은 시험자의 시각으로 소프트웨어가 명세화된 기능을 올바로 수행하는지 알아보는 과정
  ㄴ 확인(Validation): 소프트웨어 결과를 테스트, 만들어진 제품이 제대로 동작하는지 확인, 최종 사용자 요구 또는 소프트웨어 요구에 적합한지 판단, 사용자 시각으로 올바른 소프트웨어가 개발되었는지 입증하는 과정

320. 테스트 목적에 따른 분류: 회안성 구회병
  ㄴ 회복 테스트(Recovery): 시스템에 고의로 실패를 유도하고, 시스템의 정상적 복귀 여부를 테스트하는 기법
  ㄴ 안전 테스트(Security): 불법적인 소프트웨어가 접근하여 시스템을 파괴하지 못하도록 소스 코드 내의 보안적인 결함을 미리 점검하는 테스트 기법
  ㄴ 성능(Performance): 사용자의 이벤트에 시스템이 응답하는 시간, 특정 시간 내에 처리하는 업무량, 사용자의 요구에 시스템이 반응하는 속도 등을 측정하는 테스트 기법
  ㄴ 구조(Structure): 시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가하는 테스트 기법
  ㄴ 회귀(Regression): 오류를 제거하거나 수정한 시스템에서 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지 확인하는 일종의 반복 테스트 기법
  ㄴ 병행(Parallel): 변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 결과를 비교해보는 테스트 기법

321. 성능 테스트의 상세 유형: 부스스내
  ㄴ 부하 테스트(Load Testing): 부하를 계속 증가시키면서 시스템의 임계점을 찾는 테스트, 병목 지점을 찾아서 병목 현상을 제거하는 과정을 반복
  ㄴ 스트레스(Stress): 시스템 처리 능력 이사으이 부하, 임계점 이상의 부하를 가하여 비정상적인 상황에서의 처리를 테스트
  ㄴ 스파이크(Spike): 짧은 시간에 사용자가 몰릴 때 시스템의 반응 측정 테스트
  ㄴ 내구성(Endurance): 오랜 시간 동안 시스템에 높은 부하를 가하여 시스템 반응 테스트

322. 테스트 종류에 따른 분류: 명구경
  ㄴ 명세기반 = 블랙박스 테스트
  ㄴ 구조기반 = 화이트박스 테스트
  ㄴ 경험기반 = 블랙박스 테스트 

323. 정적 테스트는 리뷰와 정적분석으로 분류할 수 있다.

324. 리뷰: 소프트웨어의 다양한 산출물에 존재하는 결함을 검출하거나 프로젝트의 진행 상황을 점검하기 위한 활동으로, 전문가가 수행한다.

325. 리뷰의 유형
  ㄴ 관리 리뷰
  ㄴ 기술 리뷰
  ㄴ 인스펙션
  ㄴ 워크스루
  ㄴ 감사

326. 인스펙션(Inspection)
  ㄴ 소프트웨어 요구, 설계, 원시 코드 등의 저작자 외에 다른 전문가 또는 팀이 검사하여 문제를 식별하고 문제에 대한 올바른 해결을 찾아내는 형식적인 검토 기법
  ㄴ 인스펙션을 동료검토(Peer Review)라고도 할 수 있다.
  ㄴ 개발 초기에 검사해야만 초기 작업물에서 문제를 발견할 수 있다.

327. 워크스루(Walk Throughts)
  ㄴ 검토 자료를 회의 전에 배포해서 사전 검토한 후 짧은 시간 동안 회의를 진행하는 형태로 리뷰를 통해 문제 식별, 대안 조사, 개선 활동, 학습 기회를 제공하는 가장 비형식적인 기법
  ㄴ 결함을 검출할 뿐만 아니라 참가자들의 교육이나 지식 공유를 위해 수행하기도 함.
  ㄴ 작성자 본인이 보통 회의를 주재하며 기록자 역할도 담당할 수 있다.
  ㄴ 작성자가 작업물을 따라 돌아다니면서 작업물에 대한 설명을 진행하고 검출된 결함에 대한 권고 및 조치사항들을 기록한다.

328. 정적분석(Static Analysis)
  ㄴ 정적 분석은 도구의 지원을 받아 정적 테스트를 수행하는 방법
  ㄴ 자동화된 도구를 이요하여 산출물의 결함을 검출하거나 복잡도를 측정한다.

329. 정적분석 유형
  ㄴ 코딩 표준: 개발자가 프로그램 작성 시 지켜야할 코딩 표준 및 코딩 지침에 대한 준수 여부 검사
  ㄴ 복잡도 측정: 신뢰할 수 있는 척도를 사용하여 프로그램의 복잡도 측정 및 분석 검사, McCabe의 순환 복잡도(Cyclomatic Complexity) 의 복잡도 지표가 가장 널리 사용되고 많은 정적 도구가 이 지표를 지원
  ㄴ 자료흐름분석: 프로그램의 자료 흐름에 이상 존재 여부에 대한 분석 검사

330. 기본 경로 커버리지는 맥케이브의 순환 복잡도를 기반으로 커버리지를 계산

331. 맥케이브(McCabe)의 순환복잡도 개념
  ㄴ 제어 흐름의 복잡한 정보를 정량적으로 표시하는 기법
  ㄴ 해당 제어 흐름 그래프에서 선형적으로 독립적인 경로의 수를 나타낸다.

332. 맥케이브 순환복잡도 측정 방법
  ㄴ 계산식: V(G) = E-N+2(복잡도 V(G)는 노드(N) 수와 간선(E) 수로 계산)
  ㄴ V(G) = P-1(복잡도 V(G)는 조건 분기문(P)의 수로 계산)

333. 경험기반 테스트: 유사 소프트웨어나 유사 기술 평가에서 테스터의 경험을 토대로 한, 직관과 기술 능력을 기반으로 수행하는 테스트 기법
  ㄴ 탐오체특
  ㄴ 탐색적 테스트: 테스트 스크립트, 테스트 케이스를 문서로 작성하지 않고 경험에 바탕을 두고 탐색적으로 기능을 수행해 보면서 테스트 중대한 테스트 위주, 테스트 엔지니어의 휴리스틱한 능력 필요, 제품을 익히면서 테스트 수행
  ㄴ 오류 측정: 개발자가 범할 수 있는 실수를 추정하고 이에 따른 결함이 검출되도록 테스트케이스를 설계하여 테스트하는 기법, 다른 기법이나 공식적인 테스트를 보완할 때 유용
  ㄴ 체크리스트: 테스트하고 평가해야할 내용과 겸험을 분류하여 나열한 이후 하나씩 확인하는 테스트 기법
  ㄴ 특성테스트: 국제표준인 ISO/IEC 9126 등의 품질모델에 있는 품질 특성을 염두에 두고 이를 근간으로 경험적으로 테스트 케이스를 설계하고 테스트하는 기법

334. 테스트 오라클: 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참 값을 입력하여 비교하는 기법

335. 테스트 오라클 종류: 참샘휴일
  ㄴ 참(True) 오라클: 모든 입력값에 대하여 기대하는 결과를 생성함으로써 발생된 오류를 모두 검출할 수있는 오라클
  ㄴ 샘플링(Sampling) 오라클: 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해 주는 오라클
  ㄴ 휴리스틱(Heuristic): 샘플링 오라클을 개선한 오라클로 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클
  ㄴ 일관성 검사(Consistent): 애플리케이션 변경이 있을 때, 수행 전과 후의 결괏값이 동일한지 확인하는 오라클

336. 테스트 레벨 개념
  ㄴ 함께 편성되고 관리되는 테스트 활동의 그룹
  ㄴ 테스트 레벨은 프로젝트에서 책임과 연관되어 있다.
  ㄴ 각각의 테스트 레벨은 서로 독립적이다.

337. 테스트 레벨 종류: 단통시인
  ㄴ 단위 테스트: 사용자 요구사항에 대한 단위 모듈, 서브 루틴 등을 테스트하는 단계(자료 구조 테스트, 실행 경로 테스트, 오류처리 테스트, 인터페이스 테스트)
  ㄴ 통합테스트: 단위 테스트를 통과한 모듈 사이의 인터페이스, 통합된 컴포넌트 간의상호작용을 검증하는 테스트(빅뱅, 샌드위치, 상향식, 하향식)
  ㄴ 시스템테스트: 통합된 단위 시스템의 기능이 시스템에서 정상적으로 수행되는지를 검증하는 단계(기능 비기능 요구사항 테스트)
  ㄴ 인수 테스트: 계약상의 요구사항이 만족되었는지 확인하기 위한 테스트 단계: 계약 인수, 규정 인수, 사용자 인수, 운영상 인수, 알파, 베타 테스트)

338. 시스템 테스트 분류
  ㄴ 기능적 요구사항 테스트: 요구사항 명세서, 비즈니스 절차, 유스케이스 등 명세서 기반의 블랙박스 테스트
  ㄴ 비기능적 요구사항 테스트: 성능 테스트, 회복 테스트, 보안 테스트, 내부 시스템의 메뉴 구조, 웹 페이지의 내비게이션 등의 구조적 요소에 대한 화이트박스 테스트

339. 인수 테스트 종류
  ㄴ 사용자 인수 테스트: 비즈니스 사용자가 시스템 사용의 적절정 여부 확인
  ㄴ 운영상의 인수 테스트: 시스템 관리자가 시스템 인수시 수행, 백업/복원 시스템, 재해 복구, 사용자 관리, 정기 점검 등 확인
  ㄴ 계약 인수 테스트: 계약상의 인수/검수 조건 준수여부 확인
  ㄴ 규정 인수 테스트: 정부 지침, 법규, 규정 등이 규정에 맞게 개발되었는지 확인
  ㄴ 알파 테스트: 선택된 사용자(회사 내의 다른 사용자 또는 실제 사용자)가 개발자 환경에서 통제된 상태로 개발자와 함께 수행하는 인수 테스트
  ㄴ 베타 테스트: 실제 환경에서 일정 수의 사용자에게 대상 소프트웨어를 사용하게 하고 피드백 받는 인수 테스트

340. 테스트 시나리오(Test Scenario) 개념
  ㄴ 테스트 수행을 위한 여러 테스트 케이스의 집합으로서, 테스트 케이스의 동작 순서를 기술한 문서이며 테스트를 위한 절차를 명세한 문서
  ㄴ 테스트 수행 절차를 미리 정함으로써 설계 단계에서 중요시되던 요구사항이나 대안 흐름과 같은 테스트 항목을 빠짐없이 테스트한다.

341. 목(Mock) 객체 생성 프레임워크 개념
  ㄴ 객체지향 프로그램에서는 컴포넌트 테스트 수행 시 테스트 되는 메서드는 다른 클래스의 객체에 의존한다.
  ㄴ 메서드를 고립화하여 테스트 하는 것이 불가능하므로 독립적인 컴포넌트 테스트를 위해서는 스텁의 객체지향 버전인 목 객체가 필요하다.

342. 목 객체 유형
  ㄴ 더미 객체(Dummy): 테스트 할 때 객체만 필요하고 해당 객체의 기능까지는 필요하지 않은 경우에 사용
  ㄴ 테스트 스텁(Stub): 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로 더미 객체에의 단순 기능에 특정 상태를 가정해서 특정한 값을 리턴하거나 메시지 출력
  ㄴ 테스트 드라이버(Driver): 테스트 대상 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 수행 후의 결과를 도출
  ㄴ 테스트 스파이(Spy): 주로 테스트 대상 클래스와 협력하는 클래스로 가는 출력을 검증하는 데 사용
  ㄴ 가짜 객체(Fake): 실제 협력 쿨래스의 기능을 대체해야할 경우에 사용, 전체나 일부를 훨씬 단순하게 구현

343. 통합테스트는 점증적인 방법과 비 점증적인 방법으로 나뉨, 빅뱅 방식은 모든 컴포넌트를 사전에 통합하여 전체 프로그램을 한꺼번에 테스트하며, 점증적 방식은 상향식 통합과 하향식 통합으로 구분
 
344. 하향식 통합(Top Down)
  ㄴ 메인 제어 모듈(프로그램)로 부터 아래 방향으로 제어의 결로를 따라 이동하면서 하향식으로 통합하면서 테스트를 진행하며, 메인 제어 모듈에 통합되는 하위 모듈과 최하위 모듈은 '깊이-우선' 또는 '너비-우선' 방식으로 통합된다.
  ㄴ 깊이-우선: 루트 노드(혹은 임의의 노드) 에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
  ㄴ 너비-우선: 루루트 노드(혹은 임의의 노드) 에서 시작해서 인접한 노드를 먼저 탐색하는 방법
  ㄴ 스텁(Stub): 모듈 및 모든 하위 컴포넌트를 대신하는 더미 모듈, 스텁은 하위 모듈의 반환 값만 전달하면 된다.
  
345. 하향식 통합 수행 단계
  ㄴ 1단계: 메인 제어 모듈은 작성된 프로그램을 사용하고, 아직 작성되지 않은 하위 모듈을 제어함
  ㄴ 2단계: 위에서 아래로 내려오기 때문에 검사 초기에 시스템 구조가 파악되어야 함
  ㄴ 3단계: 모듈 및 모든 하위 컴포넌트를 대신하여 더미 모듈인 스텁 개발
  ㄴ 4단계: 깊이우선방식 또는 너비우선 방식에 따라, 하위 모듈인 스텁이 한 번에 하나씩 실제 모듈로 대체
  ㄴ 5단계: 각 모듈 또는 컴포넌트를 통합하면서 테스트 수행
  ㄴ 6단계: 테스트가 완료되면 스텁이 실제 모듈 또는 컴포넌트로 작성

346. 상향식 통합(Bottom Up)
  ㄴ 애플리케이션 구조에서 최하위 레벨의 모듈 또는 컴포넌트로부터 위쪽 방향으로 제어의 경로를 따라 이동하면서 구축과 테스트 수행
  ㄴ 드라이버(Driver): 상위의 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈, 상위 모듈 흐름을 작성해야하기 때문에 스텁이 개발하기 쉽다.

347. 상향식 통합 수행 단계
  ㄴ 1단계: 하위 레벨의 모듈 또는 컴포넌트들이 하위 모듈의 기능을 수행하는 클러스터로 결합
  ㄴ 2단계: 상위의 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈인 드라이버 작성
  ㄴ 3단계: 각 통합된 클러스터 단위 테스트
  ㄴ 4단계: 테스트가 완료되면 각 클러스터들은 프로그램의 위쪽으로 결합되며, 드라이버는 실제 모듈 또는 컴포넌트로 대체

348. 샌드위치 통합
  ㄴ 상향식 통합 테스트와 하향식 통합 테스트 방식을 결합하는 테스트방식
  ㄴ 하위 프로젝트가 있는 큰 규모의 통합테스트에서 사용
  ㄴ 병렬 테스트가 가능하고 시간 절약 가능
  ㄴ 스텁과 드라이버의 필요성이 매우 높은 방식이고, 비용이 많이 소요된다.

349. 하스상드: 하향식-스텁 / 상향식-드라이버

350. 테스트 자동화 도구 개념
  ㄴ 테스트 도구를 활용하여 반복적인 테스트 작업을 스크립트 형태로 구현합으로써, 테스트 시간 단축과 인력 투입 비용을 최소화하는 한편, 쉽고 효율적인 테스트 수행 가능
 
351. 테스트 자동화 도구 유형: 정실성통
  ㄴ 정적 분석 도구(Static Analysis Tools): 애플리케이션을 실행하지 않고 분석하는 도구, 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함 발견을 위해 사용, 테스트를 수행하는 사람이 작성된 소스 코드에 대한 이해를 바탕으로 도구를 이용해서 분석
  ㄴ 테스트 실행 도구(Test Execution Tools): 테스트를 위해 작성된 스크립트를 실행하고, 작성된 스크립트는 각 스크립트마다 특정 데이터와 테스트 수행 방법을 포함하고 있다, 데이터 주도 접근 방식과 키워드 주도 접근 방식으로 나눌 수 있다.
  ㄴ 성능 테스트 도구(Performance Test Tools): 애플리케이션의 처리량, 응답 시간, 경과 시간, 자원 사용률에 대해 가상의 사용자를 생성하고 테스트를 수행함으로써 성능 목표를 달성하였는지를 확인하는 도구이다.
  ㄴ 테스트 통제 도구(Test Control Tools): 테스트 통제 도구에는 테스트 계획 및 관리를 위한 테스트 관리 도구, 테스트 수행에 필요한 데이터와 도구를 관리하는 형상관리 도구, 결함 추적/관리 도구 등이 있다.

352. 테스트 하네스(Test Harness) 개념: 애플리케이션 컴포넌트 및 모듈을 테스트하는 환경의 일부분으로, 테스트를 지원하기 위한 코드와 데이터를 말하며, 단위 또는 모듈 테스트에 사용하기 위해 코드 개발자가 작성한다.

353. 테스트 하네스 구성요소: 드 슈스케 스목
  ㄴ 테스트 드라이버: 테스트 대상 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 수행 후의 결과를 도출하는 등 상향식 테스트에 필요
  ㄴ 테스트 스텁: 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로 하향식 테스트에 필요
  ㄴ 테스트 슈트: 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
  ㄴ 테스트 케이스: 입력값, 실행 조건, 기대 결과 등의 집합
  ㄴ 테스트 스크립트: 자동화된 테스트 실행 절차에 대한 명세
  ㄴ 목 오브젝트: 사용자의 행위를 조건부로 사전에 입력해 두면, 그 상황에 예정된 행위를 수행하는 객체

354. 소프트웨어 결함
  ㄴ 에러(Error)/오류: 에러는 결함(Defect)의 원인이 되는 것으로, 일반적으로 사람에 의해 생성된 실수
  ㄴ 결함/결점/버그(Bug): 에러 또는 오류가 원인이 되어 소프트웨어 제품에 포함되어 있는 결함, 이를 제거하지 않으면 소프트웨어 제품이 실패하거나 문제 발생
  ㄴ 실패/문제: 소프트웨어 제품에 포함된 결함이 실행될 때 발생하는 현상

355. 테스트 리포팅: 정요품 결실
  ㄴ 테스트 결과 정리
  ㄴ 테스트 요약문서
  ㄴ 품질 상태
  ㄴ 테스트 결과서
  ㄴ 테스트 실행 절차 리뷰 및 평가

356. 결함관리 개념: 단계별 테스트 수행 후 발생한 결함의 재발 방지와 유사 결함 발견 시 처리 시간 단축을 위해 결함을 추적하고 관리하는 활동

357. 결함관리 프로세스: 계기검수 재추최
  ㄴ 결함 관리 계획: 전체 프로세스에서 결함 관리에 대한 일정, 인력, 업무 프로세스를 확보하여 계획을 수립하는 것
  ㄴ 결함 기록: 테스터는 발견된 결함에 대한 정보를 결함 관리 DB에 기록
  ㄴ 결함 검토: 등록된 결함에 있어서 주요 내용 검토 및 개발자에게 전달
  ㄴ 결함 수정: 개발자는 결함 프로그램 수정
  ㄴ 결함 재확인: 테스터는 개발자가 수정한 내용을 확인하고 재테스트 수행
  ㄴ 결함 상태 추적 및 모니터링 활동: 결함 관리 팀장은 결함 관리 데이터베이스를 이용하여 대시보드 또는 게시판 형태의 서비스 제공
  ㄴ 최종결함 분석 및 보고서 작성: 발견된 결함에 관환 내용과 이해관계자들의 의견이 반영된 보고서를 작성하고 결함 관리 종료

348. 결함 분석 방법: 구고일
  ㄴ 구체화: 결함의 원인을 찾기 위해 결함을 발생기킨 입력값, 테스트 절차, 테스트 환경을 명확히 파악
  ㄴ 고립화: 입력값 테스트 절차, 테스트환경 중 어떤 요소가 결함 발생에 영향을 미치는지 분석하는 방법
  ㄴ 일반화: 결함 발생에 영향을 주는 요소를 최대한 일반화 시키는 방법

349. 결함 생명주기
  ㄴ 결함 등록
  ㄴ 결함 검토
  ㄴ 결함 할당
  ㄴ 결함 수정
  ㄴ 결함 확인
  ㄴ 결함 종료
  ㄴ 결함 재등록
  ㄴ 결함 조치 보류

350. 테스트 커버리지 개념: 테스트 커버리지는 주어진 테스트 케이스에 의해 수행되는 소프트웨어의 테스트 범위를 측정하는 테스트 품질 측정 기준이다. 테스트의 정확성과 신뢰성 향상

351. 테스트 커버리지 유형: 기라코
  ㄴ 기능 기반 커버리지: 테스트 대상 애플리케이션의 전체 기능을 모수로 설정하고, 실제 테스트가 수행된 기능의 수를 측정하는 방법, 100% 달성을 목표로 하며, 일반적으로 UI가 많은 시스템의 경우 화면 수를 모수로 사용
  ㄴ 라인 커버리지: 애플리케이션 전체 소스 코드의 라인 수를 모수로 테스트 시나리오가 수행한 소스 코드의 라인 수 측정: 단위 테스트에서는 라인 커버리지를 척도로 삼음
  ㄴ 코드 커버리지: 소프트웨어 테스트 충분성 지표 중 하나, 소스 코드위 구문, 조건, 결정 등의 구조 콛 자체가 얼마나 테스트 되었는지를 측정, 일반적으로 테스트 커버리지라 하면 코드 커버리지를 일컬음

352. 결함의 분류: 시기지문
  ㄴ 시스템 결함: 비정상적인 종료/중단, 응답 시간 지연, 데이터베이스 에러 등 주로 애플리케이션 환경과 데이터베이스 처리에서 발생하는 결함
  ㄴ 기능 결함: 사용자의 요구사항 미반영/불일치, 부정확한 비즈니스 프로세스, 스크립트 에러, 타 시스템 연동 시 오류 등 기획, 설계, 업무 시나리오 단계에서 발견한 결함
  ㄴ GUI 결함: 응용 프로그램의 UI 비일관성, 부정확한 커서/메시지, 데이터 타이브이 표시 오류 등으로 사용자 화면 설계에서 발생한 결함
  ㄴ 문서 결함: 기획자, 사용자, 개발자 간의 의사소통과 기록이 원활하지 않은 경우 발생

353. 결함 심각도별 분류: 치주 보경단
  ㄴ 치명적(Critical)
  ㄴ 주요(Major)
  ㄴ 보통(Normal)
  ㄴ 경미한(Minor)
  ㄴ 단순(Simple)

354. 애플리케이션 성능 측정 지표: 처응경자
  ㄴ 처리량(Throughput): 애플리케이션이 주어진 시간에 처리할 수 있는 트랜잭션의 수, 웹 애플리케이션의 경우 시간당 페이지 수로 표현
  ㄴ 응답 시간(Response Time): 사용자 입력이 끝난 후, 애플리케이션의 응답 출력이 개시될 때 까지의 시간, 애플리케이션의 경우 메뉴 클릭 시 해당 메뉴가 나타나기 까지 걸리는 시간
  ㄴ 경과 시간(Turnaround Time): 애플리케이션에 사용자가 요구를 입력한 시점부터 트랜잭션을 처리 후 그 결과의 출력이 완료할 때 까지 걸리는 시간
  ㄴ 자원 사용률(Resource Usage): 애플리케이션이 트랜잭션을 처리하는 동안 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량

355. 애플리케이션 성능 저하 원인
  ㄴ 데이터 베이스 관련 성능 저하 원인: 락페릭사커
    ㄴ DB Lock: 대량의 데이터 조회, 과도한 업데이트, 인덱스 생성 시 발생하는 현상
    ㄴ DB Fetch: 실제 필요한 데이터보다 많은 대량의 데이터 요청이 들어올 경우 응답시간 저하 현상 발생
    ㄴ Connection Leak: DB연결과 관련한 JDBC객체를 사용 후 종료하지 않은 경우 발생
    ㄴ Connection Pool Size: 너무 작거나 크게 설정한 경우 발생
    ㄴ Commit: 확정되지 않고 커넥션 풀에 반환 될 때 발생
  ㄴ 내부 로직으로 인한 성능 저하 원인
  ㄴ 외부 호출(HTTP, 소켓 통신)로 인한 성능 저하 원인
  ㄴ 잘못된 환경 설정이나 네트워크 문제로 인한 성능 저하 원인

356. 애플리케이션 성능 테스트 수행 절차: 도환시성
  ㄴ 성능 테스트 도구 설치
  ㄴ 테스트 환경 설정
  ㄴ 시나리오 생성
  ㄴ 성능 테스트 실행 및 모니터링

357. 베드코드(Bad Code): 다른 개발자가 로직을 이해하기 어렵게 작성된 코드

358. 베드코드 사례
  ㄴ 외계인 코드: 아주 오래되거나 참고문서 혹은 개발자가 없어 유지보수 작업이 아주 어려운 코드
  ㄴ 스파게티 코드: 컴퓨터 프로그램의 소스 코드가 복잡하게 얽힌 모습을 스파게티의 면발에 비유한 표현, 작동은 정상적으로 하지만, 코드를 읽으면서 그 코드의 작동을 파악하기는 어려움
  ㄴ 알 수 없는 변수 명
  ㄴ 로직 중복

359. 베드 코드 유형: 오문이 결침
  ㄴ 오염: 비즈니스 기능을 수행하지 못하는 많은 컴포넌트들이 존재
  ㄴ 문서부족: 현재 코드와 문서가 일치하지 않고 수정과 변경을 위한 도메인 지식은 크게 증가 하지만 개발자의 지식부족 초래
  ㄴ 의미 없는 이름: 함수, 클래스, 컴포넌트 이름들이 명확한 의미를 갖지 못하거나 실제 작동과 불일치
  ㄴ 높은 결합도: 클래스와 컴포넌트 간에 데이터와 컨트롤 흐름이 네트워크로 복잡하게 연결
  ㄴ 아키텍처 침식: 아키텍처가 더 이상 구별되지 않고 여러 솔루션으로 이루어져 아키텍처상 변형들로 인해 시스템 품질이 떨어짐

360. 클린코드(Clean Code): 잘 작성되어 가독성이 높고, 단순하며, 의존성을 줄이고, 중복을 최소화하여 깔끔하게 잘 정리된 코드를 말한다.
  ㄴ 중복 코드 제거로 애플리케이션의 설계가 개선된다.
  ㄴ 가독성이 높으므로 기능에 대해 쉽게 이해할 수 있다.
  ㄴ 버그를 찾기 쉬워지며, 프로그래밍 속도가 빨라진다.

361. 클린 코드 작성 원칙: 가단의 중추
  ㄴ 가독성: 이해하기 쉬운 용어를 사용, 코드 작성 시 들여쓰기 기능을 사용
  ㄴ 단순성: 한 번에 한 가지 처리만을 수행, 클래스/메서드/함수를 최소 단위로 분리
  ㄴ 의존성 최소: 영향도를 최소화, 코드의 변경이 다른 부분에 영향이 없게 작성
  ㄴ 중복 제거: 중복된 코드 제거
  ㄴ 추상화: 클래스/메서드/함수에 대해 동일한 수준의 추상화 구현, 상세 내용은 하위 클래스/메서드/함수에서 구현

362. 소스 코드 최적화 기법의 유형
  ㄴ 의미 있는 이름
  ㄴ 간결하고 명확한 주석
  ㄴ 보기 좋은 배치
  ㄴ 작은 함수
  ㄴ 읽기 쉬운 제어 흐름
  ㄴ 오류 처리
  ㄴ 클래스 분할 배치
  ㄴ 느슨한 결합 기법
  ㄴ 코딩 형식 기법

363. 소스 코드 품질 분석
  ㄴ 소스 코드에 대한 코딩 스타일, 설정된 코딩 표준, 코드의 복잡도, 코드 내에 존재하는 메모리 누수 현황, 스레드의 결함 등을 발견하기 위한 활동이다.

364. 소스 코드 품질분석 도구 유형
  ㄴ 정적 분석 도구: 작성된 소스 코드를 실행시키지 않고, 코드 자체만으로 코딩 표준 준수 여부, 코딩 스타일 적정 여부, 잔존 결함 발견 여부를 확인하는 코딩 분석 도구
  ㄴ 동적 분석 도구: 애플리케이션을 실행하여 코드에 존재하는 메모리 누수 현황을 발견하고, 발생한 스레드의 결함 등을 분석하기 위한 도구

365. 소스 코드 품질 분석 도구
  ㄴ 정적 분석 도구
    ㄴ pmd: 자바 및 타 언어 소스 코드에 대한 버그, 데드코드 분석
    ㄴ cppcheck: C/C++ 코드에 대한 메모리 누수, 오버플로우 등 문제 분석
    ㄴ SonarQube: 소스 코드 품질 통합 플랫폼
    ㄴ checkstyle: 자바 코드에 대한 코딩 표준 검사 도구
    ㄴ ccm: 다양한 언어의 코드 복잡도 분석 도구, 리눅스, 맥 환경 CLI형태 지원
    ㄴ cobertura: jcoverge 기반의 테스트 커버리지 측정 도구
  ㄴ 동적 분석 도구
    ㄴ Avalanche: Valgrind 프레임워크 및 STP 기반 소프트웨어 에러 및 취약점 동적 분석 도구
    ㄴ Valgrind: 자동화된 메모리 및 스레드 결함 발견 분석 도구

366. 리팩토링(Refactoring) 개념
  ㄴ 유지보수 생산성 향상을 목적으로 기능을 변경하지 않고, 복잡한 소스 코드를 수정, 보완하여 가용성 및 가독성을 높이는 기법이다.
  ㄴ 소프트웨어 모듈의 외부적 기능은 수정하지 않고 내부적으로 구조, 관계 등을 단순화하여 소프트웨어의 유지보수성을 향상시키는 기법

367. 운영체제(OS; Operating System) 개념
  ㄴ 사용자가 컴퓨터의 하드웨어를 쉽게 사용할 수 있도록 인터페이스를 제공해 주는 소프트웨어
  ㄴ 한정된 시스템 자원을 효과적으로 사용할 수 있도록 관리 및 운영함으로써 사용자에게 편리성 제공
  ㄴ 컴퓨터 시스템과 사용자 간의 인터페이스 기능을 담당한다.

368. 운영체제 특징
  ㄴ 사용자 편리성 제공: 한정된 시스템 자원을 효과적으로 사용할 수 있도록 관리 및 운영함
  ㄴ 인터페이스 기능을 담당: 컴퓨터 시스템과 사용자를 연결함
  ㄴ 스케줄링 담당: 다중 사용자와 다중 응용 프로그램 환경하에서 자원의 현재 상태를 파악하고 자원 분배를 위한 스케줄링을 담당
  ㄴ 자원 관리: CPU, 메모리 공간, 기억장치, 입출력 장치 등의 자원을 관리함
  ㄴ 제어 기능: 입출력 장치와 사용자 프로그램을 제어

369. 운영체제는 크게 인터페이스(쉘) + 커널의 구조이다.
  ㄴ 커널: 운영체제의 핵심이 되는 기능들이 모여있는 컴퓨터 프로그램
  ㄴ 쉘은 운영체제 바깥 부분에 위치해서 사용자 명령에 대한 처리를 담당하고, 커널은 하드웨어와 관련된 내부적일 역할은 담당한다.

370. 커널의 기능
  ㄴ 프로세스 관리: 프로세스 스케줄링 및 동기화 관리, 프로세스 생성과 제거, 시작과 정지, 메시지 전달 등 담당
  ㄴ 기억장치 관리: 프로세스에게 메모리 할당 및 회수 관리 담당
  ㄴ 주변장치 관리: 입출력 장치 스케줄링 및 전반적인 관리 담당
  ㄴ 파일 관리: 파일 관리 파일의 생성과 삭제, 변경, 유지 등의 관리 담당

371. 윈도우즈 특징: 지선자 오
  ㄴ GUI 제공: Graphical User Interface, 마우스로 아이콘이나 메뉴를 선택하여 작업을 수행
  ㄴ 선점형 멀티 태스킹 방식 제공: 동시에 여러개의 프로그램을 실행하면서 운영체제가 각 작업의 CPU 이용 시간 제어
  ㄴ 자동감지 기능 제공(Plug and Play): 하드웨어를 설치 했을 때 필요한 시스템 환경을 운영체제가 자동으로 구성해주는 자동감지 기능 제공
  ㄴ OLE(Object Linking and Embedding): 개체를 현재 작성 중인 문서에 자유롭게 연결 또는 삽입하여 편집할 수 있게 하는 기능 제공

372. 유닉스(Unix) 계열 운영체제 개념
  ㄴ 교육 및 연구 기관에서 사용되는 범용 다중 사용자 방식의 시분할 운영체제

373. 유닉스(Unix) 운영체제 특징: 대다 사이계
  ㄴ 대화식 운영체제 기능 제공: 프롬프트가 나타난 상태에서 사용자가 명령을 입력하면 시스템은 그 명령을 수행하는 사용자 명령 기반의 대화식 운영체제 기능을 제공
  ㄴ 다중 작업 기능 제공: 다수의 작업(프로세스)이 중앙처리장치(CPU)와 같은 공용자원을 나누어 사용하여 한 번에 하나 이상의 작업을 수행하는 기능 제공
  ㄴ 다중 사용자 기능 제공: 여러 대의 단말이 하나의 컴퓨터에 연결되어서, 여러 사람이 동시에 시스템을 사용하여 각각의 작업을 수행할 수 있는 기능 제공
  ㄴ 이식성 제공: 90%이상 C언어로 구현되어 있고, 시스템 프로그램이 모듈화 되어 있어서 다른 하드웨어 기종으로 쉽게 이식 가능
  ㄴ 계층적 트리 구조 파일 시스템 제공: 계층적 트리 구조를 가짐으로써 통합적인 파일 관리가 용이

374. 안드로이드 운영체제
  ㄴ 휴대 전화를 비롯한 휴대용 장치를 위한 운영체제와 미들웨어, 사용자 인터페이스 그리고 표준 응용 프로그램등을 포함하고 있는 운영체제
  ㄴ 리눅스 기반
  ㄴ 자바와 코틀린 언어
  ㄴ 런타임 라이브러리
  ㄴ 안드로이드 소프트웨어 개발 키트(SDK)

375. 리눅스/유닉스 운영체제의 기본 명령어
  ㄴ uname -a: 시스템의 모든 정보를 확인하는 명령어, 시스템 이름, 사용 중인 운영체제와 버전, 호스트명, 하드웨어 정보 등을 표시
  ㄴ uname -r: 운영체제의 배포 버전 출력
  ㄴ cat: 파일의 내용을 화면에 출력하는 명령어
  ㄴ uptime: 시스템의 가동 시간와 현재 사용자 수, 평균 부하량 등을 확인하는 명령어
  ㄴ id: 사용자의 로그인 명, id 등을 출력하는 명령어
  ㄴ last: 시스템의 부팅부터 현재까지 모든 사용자의 로그인과 로그아웃에 대한 정보 표시
  ㄴ who: 현재 접속 사용자 정보 표시
  ㄴ ls: 자신이 속해있는 폴더 내 파일 및 폴더 표시
  ㄴ pwd: 현재 작업중인 디렉토리의 절대 경로 출력
  ㄴ rm: 파일 삭제 
  ㄴ cp: 파일 복사
  ㄴ mv: 파일 이동
  ㄴ ps: 현재 실행되고 있는 프로세스 목록 출력
  ㄴ pmap: 프로세스 ID기준으로 매ㅔ모리 맵 정보 출력
  ㄴ kill: 특정 PID 프로세스 종료 명령어
  ㄴ chmod: 특정 파일 또는 디렉토리의 퍼미션 수정 명령어
  ㄴ chown: 파일이나 디렉토리의 소유자, 소유 그룹 수정 명령어
  ㄴ ifconfig: 네트워크 인터페이슬르 설정하거나 확인
  ㄴ host: 도메인 명은 알고 있는데 ip 주소를 모르거나 혹은 그 반대의 경우에 사용
  ㄴ tar: 여러개의 파일을 하나의 파일로 묶거나 풀 때 사용
  ㄴ gzip: 압축
  ㄴ grep: 입력으로 전달 된 파일의 내용에서 특정 문자열 찾고자 할때 사용
  ㄴ find: 특정한 파일 찾음
  ㄴ cp: 디렉토리 복사할 때 사용
  ㄴ rsync: 로컬 또는 원격에 파일과 디렉토리를 복사하고 동기화
  ㄴ df: 하드디스크 남은 용량 확인
  ㄴ du: 파일 사이즈를 킬로 바이트 단위로 표시
  ㄴ cd: 디렉토리 이동

376. 리눅스/유닉스 운영체제의 파일 접근 제어 
  ㄴ 사용자 혹은 프로세스가 파일을 읽거나 실행하면 open(), read(), write() 같은 시스템 호출이 수행되고 각 파일의 정보가 저장된 i-node 값을 읽게 된다.
  ㄴ i-node: 유닉스 계통 파일 시스템에서 사용하는 자료구조, i-node에는 각 파일의 물리적 위치, 생성수정사용 날짜 등의 정보와 더불어 소유자, 그룹, 접근 권한 등의 파일 접근제어와 관련된 정보가 수록되며, 해당 정보를 이용하여 DAC 기반 접근제어를 수행

377. 운영체제 핵심 기능 파악
  ㄴ 메모리 관리: 프로그램 실행이 종료될 때 까지 메모리를 가용한 상태로 유지 및 관리하는 기능, 메모리가 꽉차게 되면 속도가 느려지고 시스템 멈춤 현상 발생, 메모리에 있는 프로그램은 CPU로 이동하여 처리(CPU는 가상 주소를, 메모리는 물리 주소를 사용하는데 MMU가 주소를 매핑하는 역할 수행)
  ㄴ 프로세스 관리: 프로세스란 일반적으로 CPU에 의해 처리되는 프로그램으로 현재 실행중인 프로그램, 일시 중지 및 재실행, 동기화, 통신, 교착상태 처리, 프로세스 생성 삭제 등
  ㄴ MMU(Memory Management Unit): CPU가 메모리에 접근하는 것을 관리하는 컴퓨터 하드웨어 부품으로 가상 메모리 주소를 실제 메모리 주소로 변환하는 장치

378. 메모리 관리 기법: 반배할교
  ㄴ 반입 기법: 주기억장치에 적재할 다음 프로세스의 반입 시기 결정(메모리로 적재 시기 결정)
  ㄴ 배치 기법: 디스크에 있는 프로세스를 주기억장치의 어느 위치에 저장할 것인지 결정(적재 위치 결정)
  ㄴ 할당 기법: 실행해야 할 프로세스를 주기억장치에 어떤 방법으로 할당할 것인지 결정(적재 방법 결정)
  ㄴ 교체 기법: 재배치 기법으로 주기억장치에 있는 프로세스 중 어떤 프로세스를 제거할 것인지를 결정(교체대상 결정)

379. 메모리 배치 기법: 초적악
  ㄴ 최초 적합: 프로세스가 적재될 수 있는 가용 공간 중에서 첫 번째 분할에 할당하는 방식
  ㄴ 최적 적합: 가용 공간 중에서 가장 크기가 비슷한 공간을 선택하여 프로세스를 적재
  ㄴ 최악 적합: 프로세스의 가용 공간들 중에서 가장 큰 공간에 할당하는 방식

380. 프로세스 상태: 하나의 프로세스는 여러가지 이벤트에 의해 일련의 서로 구분되는 상태 변화를 겪는다.: 생준 실대완
  ㄴ 생성(Create) 상태: 사용자에 의해 프로세스가 할당된 상태 
  ㄴ 준비(Ready) 상태: CPU를 할당받을 수 있는 상태, 준비 리스트: 각각 우선순위를 부여하여 가장 높은 우선순위를 갖는 프로세스가 다음 순서에 CPU를 할당 받음
  ㄴ 실행(Running) 상태: 프로세스가 CPU를 할당받아 동작 중인 상태
  ㄴ 대기(Waiting) 상태: 프로세스 실행 중 입출력 처리 등으로 인해 CPU를 양도하고 입출력 처리가 완료 까지 대기리스트에서 기다리는 상태, 대기 리스트: 우선순위가 존재하지 않음
  ㄴ 완료(Complete) 상태: 프로세스가 완전히 수행을 종료한 상태

381. 프로세스 상태 전이 개념
  ㄴ 하나의 작업이 컴퓨터 시스템에 입력되어 완료되기 까지 프로세스의 상태가 준비, 실행 및 대기 상태로 변하는 활동
  ㄴ 활동 상태란 프로세스가 기억장치를 할당 받은 상태
  ㄴ 지연 상태란 프로세스가 기억장치를 할당받지 못한 상태

382. 프로세스 상태 전이 유형: 디타블웨
  ㄴ 디스패치(Dispatch): 준비 상태에 있는 여러 프로세스 중 실행될 프로세스를 선정하여 CPU를 할당 -> 문맥교환 발생, 프로세스는 준비 -> 실행으로 전이
  ㄴ 타이머 런 아웃(Timer run out): CPU를 할당받은 프로세스는 지정된 시간이 초과되면 스케줄러에 의해 PCB저장, CPU 반납 후 다시 준비 상태로 전이, 실행 -> 준비로 전이,
  ㄴ 블록(Block): 실행 상태에 있는 프로세스가 지정된 할당시간을 초과하기 전에 입출력이나 기타 사건이 발생하면 CPU를 스스로 반납하고 입출력이 완료될 때 까지 대기 상태로 전이, 실행 -> 대기로 전이
  ㄴ 웨이크 업(Wake-up): 어느 순간 입출력이 종료되면 대기 상태의 프로세스에게 입출력 종료 사실을 알려주고 대기 -> 준비로 전이

383. 프로세스 스케줄링
  ㄴ CPU를 사용하려는 프로세스들 사이의 우선순위를 관리하는 작업
  ㄴ 처리율과 CPU 이용률을 증가시키고 오버헤드, 응답시간, 반환시간, 대기시간을 최소화 시키기 위한 기법
  ㄴ 특정 프로세스가 적합하게 실행되도록 프로세스 스케줄링에 의해 프로세스 사이에서 CPU 교체가 일어난다.

384. 선점형 스케줄링 개념
  ㄴ 하나의 프로세스가 CPU를 차지하고 있을 때, 우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 방식
  ㄴ 장점: 비교적 빠른 응답, 대화식 시분할 시스템에 적합
  ㄴ 단점: 높은 우선순위 프로세스들이 들어오는 경우 오버헤드 초래
  ㄴ 활용: 실시간 응답 환경, Deadline 응답 환경

385. 선점형 스케줄링 알고리즘 유형
  ㄴ 라운드 로빈(Round Robin): 프로세스는 같은 크기의 CPU 시간을 할당, 프로세스가 할당된 시간 내에 처리 완료를 못하면 준비 큐 리스트의 가장 뒤로 보내지고, CPU는 대기 중인 다음 프로세스로 넘어감, 균등한 CPU 점유 시간, 시분할 시스템 사용
  ㄴ SRT(Shortest Remaining Time First): 가장 짧은 시간이 소요되는 프로세스를 먼저 수행하고, 남은 처리 시간이 더 짧다고 판단되는 프로세스가 준비 큐에 생기면 언제라고 프로세스 선점됨, 짧은 수행시간 프로세스 우선 수행
  ㄴ 다단계 큐(Multi Level Queue): 작업들을 여러 종류 그룹으로 분할, 여러 개의 큐를 이용하여 상위단계 작업에 의한 하위단계 작업이 선점 당함, 각 큐는 자신만의 독자적인 스케줄링을 가짐
  ㄴ 다단계 피드백 큐(Multi Level Feedback Queue): 입출력 위주와 CPU 위주인 프로세스의 특성에 따라 큐마다 서로 다른 CPU 시간 할당량을 부여, FCFS(FIFO)와 라운드 로빈 스케줄링 기법을 혼합한 것으로, 새로운 프로세스는 높은 우선순위, 프로세스의 실행시간이 길어질수록 점점낮은 우선순위 큐로 이동하고 마지막 단계는 라운드 로빈 적용, 큐마다 다른 시간 할당량, 마지막 단계는 라운드 로빈 방식 처리

386. 비선점형 스케줄링 개념
  ㄴ 한 프로세스가 CPU를 할당받으면 작업 종료 후 CPU 반환 시 까지 다른 프로세스는 CPU 점유가 불가능한 스케줄링 방식
  ㄴ 장점: 응답시간 예상이 용이, 모든 프로세스에 대한 요구를 공정하게 처리
  ㄴ 단점: 짧은 작업을 수행하는 프로세스가 긴 작업 종료시 까지 대기
  ㄴ 활용: 처리시간 편차가 적은 프로세스 환경

387. 비선점형 스케줄링 알고리즘 유형
  ㄴ 우선순위(Priority): 프로세스별로 우선순위가 주어지고, 우선순위에 따라 CPU 할당, 동일 순위는 FCFS, 주요/긴급 프로세스에 대한 우선 처리
  ㄴ 기한부(Deadline): 작업들이 명시된 시간이나 기한 내에 완료되도록 계획, 요청에 명시된 시간 내 처리를 보장
  ㄴ FCFS(First Come First Service): 프로세스가 대기 큐에 도착한 순서에 따라 CPU 할당, FIFO 라고도 함, 도착 순서대로 처리
  ㄴ SJF(Shortest Job First): 프로세스가 도착하는 시점에 따라 그 당시 가장 작은 서비스 시간을 갖는 프로세스가 종료 시 까지 자원 점유, 준비 큐 작업 중 가장 짧은 작업부터 수행, 평균 대기 시간 최소, CPU 요구 시간이 긴 작업과 짧은 작업간 불평등이 심하여, CPU 요구 시간이 긴 프로세스는 기아현상 발생
  ㄴ HRN(Highest Response Ratio Next): 대기 중 프로세스 중 현재 응답률이 가장 높은 것을 선택, SJF의 약점인 기아 현상을 보완한 기법으로 긴 작업과 짧은 작업 간의 불평등 완화, HRN의 우선순위: 대기시간+서비스시간/서비스시간

388: 반종도 대반서: 반환시간 = 종료시간 - 도착시간, 대기시간 = 반환시간 - 서비스시간

389. 가상화(Virtualization) 개념
  ㄴ 물리적인 리소스들을 사용자에게 하나로 보이게 하거나, 하나의 물리적인 리소스를 여러 개로 보이게 하는 기술
  ㄴ 대부분의 서버는 용량의 20% 정도만을 사용하는데, 가상화를 통해 서버의 가동률을 60~70% 이상으로 올릴 수 있다.
  ㄴ 가상화의 종류: 플랫폼 가상화, 리소스 가상화

390. 가상화 기술요소
  ㄴ 컴퓨팅 가상화: 물리적으로 컴퓨터 리소스를 가상화하여 논리적 단위로 리소스를 활용할 수 있도록 하는 기술, 서버 가상화를 통해 하나의 시스템에서 1개 이상의 운영체제를 동시에 가동시킬 수 있으므로 서버 이용률이 크게 향상, ex) 하이퍼 바이저
  ㄴ 스토리지와 서버 사이에 소프트웨어/하드웨어 계층을 추가하여 스토리지를 논리적으로 제어 및 활용할 수 있도록 하는 기술, 이기종 스토리지 시스템의 통합을 가능하게 하는 기술 ex) 분산 파일 시스템
  ㄴ I/O 가상화: 서버와 I/O 디바이스 사이에 위치하는 미들웨어 계층으로, 서버의 I/O 자원을 물리적으로 분리하고 케이블과 스위치 구성을 단순화하여 효율적인 연결을 지원하는 기술
  ㄴ 컨테이너: 컨테이너화 된 애플리케이션들이 단일 운영체제상에서 실행되도록 해주는 기술, 하이퍼바이저 없이 운영체제가 격리된 프로세스로 동작하기 때문에 오버헤드가 낮음 ex)도커
  ㄴ 분산처리 기술: 여러 대의 컴퓨터 계산 및 저장능력을 이용하여 커다란 계산문제나 대용량의 데이터를 처리하고 저장하는 기술
  ㄴ 네트워크 가상화 기술: 물리적으로 떨어져 있는 다양한 장비들을 연결하기 위한 수단으로 중계장치의 가상화를 통한 가상 네트워크를 지원하는 기술

391. 클라우드 컴퓨팅(Cloud Computing)
  ㄴ 클라우드 컴퓨팅은 인터넷을 통해 가상화된 컴퓨터 시스템 리소스를 제공하고, 정보를 자신의 컴퓨터가 아닌 클라우드에 연결된 다른 컴퓨터로 처리하는 기술

392. 클라우드 컴퓨팅 분류: 사공하
  ㄴ 사설 클라우드: 기업 또는 조직 내부에서 보유하고 있는 컴퓨팅 자원 등을 사용하여 내부에 구축되어 운영되는 클라우드, 자체 컴퓨팅 자원으로 모든 하드웨어, 소프트웨어, 데이터를 수용, 직접적인 통제가 가능하며 보안성을 높일 수 있음
  ㄴ 공용 클라우드: 클라우드 서비스 제공 업체에서 다중 사용자를 위한 컴퓨팅 자원 서비스 제공, 일정한 비용을 지불하고 하드웨어, 소프트웨어 등 사용
  ㄴ 하이브리드 클라우드: 기업 또는 조직 내부 자원을 이용한 사설 클라우드와 공용 클라우드를 모두 사용하는 클라우드, 사설 클라우드의 약점인 구축 비용 문제와 공용 클라우드의 약점인 보안성 확보 문제를 해결

393. 클라우드 서비스 유형: IPS
  ㄴ 인프라형 서비스(IaaS; Infrastructure as a Service): 서버, 스토리지 같은 시스템 자원을 클라우드로 제공하는 서비스, 컴퓨팅 자원에 운영체제나 애플리케이션 등의 소프트웨어 탑재 및 실행, 하위의 클라우드 인프라를 제어하거나 관리하지 않지만, 스토리지, 애플리케이션에 대해서는 제어권 가짐
  ㄴ 플랫폼형 서비스(Paas; Platform as a Service): 인프라를 생성, 관리 하는 복잡함 없이 애플리케이션을 개발, 실행, 관리할 수 있게 하는 플랫폼을 제공하는 서비스, SaaS의 개념을 개발 플랫폼에도 확장한 방식으로 개발을 위한 플랫폼을 구축할 필요 없이, 필요한 개발 요소를 웹에서 빌려 쓸 수 있게 하는 모델, OS, 애플리케이션과 애플리케이션 호스팅 환경 구성의 제어권을 가짐
  ㄴ 소프트웨어형 서비스(SaaS; Software as a Service): 소프트웨어 및 관련 데이터는 중앙에 호스팅 되고 사용자는 웹 브라우저 등의 클라이언트를 통해 접속하여 소프트웨어를 서비스 형태로 이용하는 서비스

394. 네트워크 개념: 원하는 정보를 원하는 수신자 또는 기기에 정확하게 전송하기 위한 기반 인프라이다.
  ㄴ WAN: 광대역 네트워크, LAN에 비해 전송 거리가 넓음, 라우팅 알고리즘이 필요, LAN 대비 에러율이 높고 전송 지연이 큼
  ㄴ LAN: 근거리 네트워크: 한 건물 또는 작은 지역을 커버하는 네트워크

395. OSI(Open System Interconnection) 7계층
  ㄴ 국제 표준화 기구인 ISO에서 개발한 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 개방형 시스템 상호 연결 모델이다.
  ㄴ 각 계층은 서로 독립적으로 구성되어 있고, 각 계층은 하위 계층의 기능을 이용하여 상위 계층에 기능을 제공한다.
  ㄴ 물리(Physical), 데이터링크(Data Link), 네트워크(Network), 전송(Transport), 세션(Session), 표현(Presentation), 응용(Application)
 
396. 1계층 장비
  ㄴ 허브: 여러 대의 컴퓨터를 연결하여 네트워크로 보내거나, 하나의 네트워크로 수신된 정보를 여러 대의 컴퓨터로 송신하기 위한 장비
  ㄴ 리피터: 디지털 신호를 증폭시켜 주는 역할을 하여 신호가 약해지지 않고 컴퓨터로 수신되도록 하는 장비

397. 2계층 장비
  ㄴ 브리지: 두 개의 근거리통신망(LAN)을 서로 연결해 주는 통신망 연결 장치
  ㄴ L2 스위치: 느린 전송속도의 브리지, 허브의 단점을 개선하기 위해서, 출발지에서 들어온 프레임(Frame)을 목적지 MAC 주소 기반으로 빠르게 전송시키는 데이터 링크 계층의 통신 장치, L2 스위치는 종류에 따라 3가지 방식 중 하나 사용(Store and Forwarding / Cut Through / Fragment Free)
  ㄴ NIC: Network Interface Card의 약자, 외부 네트워크와 접속하여 가장 빠른 속도로 데이터를 주고 받을 수 있게 컴퓨터 내에 설치되는 장치
  ㄴ 스위칭 허브: 스위치 기능을 가진 허브, 사용되는 대부분의 허브가 스위칭 허브

398. 3계층 장비
  ㄴ 라우터: LAN과 LAN을 연결하거나 LAN과 WAN을 연결하기 위한 인터넷 네트워킹 장비, 패킷의 위치를 추출하여, 그 위치에 대한 최적의 경로를 지정하며, 이 경로를 따라 데이터 패킷을 다음 장치로 전송시키는 장비, 라우팅 프로토콜은 경로 설정을 하여 원하는 목적지까지 지정된 데이터가 안전하게 전달되도록 함
  ㄴ 게이트웨이: 프로토콜을 서로 다른 통신망에 접속할 수 있게 해주는 장치, LAN에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아들이는 출입구 역할
  ㄴ L3 스위치: 3계층에서 네트워크 단위들을 연결하는 통신 장비, IP 레이어에서의 스위칭을 수행하여 외부로 전송, 라우터와의 경계가 모호
  ㄴ 유무선 인터넷 공유기: 외부로부터 들어오는 인터넷 라인을 연결하여 유선으로 여러대의 기계를 연결하거나 무선 신호로 송출하면서 여러 대이 컴퓨터가 하나의 인터넷 라인을 공유할 수 있도록 하는 장비
  ㄴ 망(백본) 스위칭 허브: 광역 네트워크를 커버하는 스위칭 허브, 예를 들어 경남권 스위칭, 부산권 스위칭 등 대단위 지역을 커버함

399. 4계층 장비
  ㄴ L4 스위치: 4계층에서 네트워크 단위들을 연결하는 통신 장비, TCP/UDP 등 스위칭 수행, FTP, HTTP 등을 구분하여 스위칭하는 로드 밸런싱 가능, 애플리케이션 레이어에서 파악이 가능한 이메일 내용 등 정교한 로드 밸런싱 수행 불가, 4계층 정보인 TCP/UDP 포트번호를 분석하여 포워딩을 경정하고 QoS와 GLB/SLB 기능을 제공하는 스위치

400. 프로토콜(Protocol) 개념
  ㄴ 프로토콜은 서로 다른 시스템이나 기기들 간의 데이터 교환을 원활히 하기 위한 표준화된 통신규약이다.
  ㄴ 심리학자 톰 마릴은 컴퓨터가 메시지를 전달하고, 메시지가 제대로 도착했는지 확인하며, 도착하지 않았을 경우 메시지를 재전송하는 일련의 방법을 프로토콜이라고 정의했다.
  ㄴ 통신을 위해 프로토콜이 가져야 하는 일반적인 기능에는 데이터 처리 기능, 제어기능, 관리적 기능이 있다.

401. 프로토콜의 3요소: 구의타
  ㄴ 구문(Syntax): 시스템 간의 정보 전송을 위한 데이터 형식, 코딩, 신호 레벨 등의 규정
  ㄴ 의미(Semantic): 시스템 간의 정보 전송을 위한 제어 정보로 조정과 에러 처리를 위한 규정
  ㄴ 타이밍(Timing): 시스템 간의 정보 전송을 위한 속도 조절과 순서 관리 규정

402. 네트워크 프로토콜 개념
  ㄴ 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계
  ㄴ 통신 규약 또는 규칙에는 전달 방식, 통신 방식, 자료의 형식, 오류 검증 방식, 코드 변환 규칙, 전송 속도 등을 정하게 됨
  ㄴ 다른 기종의 장비는 각기 다른 통신 규약을 사용하는데 프로토콜을 사용하면 다른 기기 간 정보의 전달을 표준화 할 수 있다.
 
403. 네트워크 프로토콜 특징
  ㄴ 단편화: 전송이 가능한 작은 블록으로 나누어지는 기법
  ㄴ 재조립: 단편화되어 온 조각들을 원래 데이터로 복원하는 기법
  ㄴ 캡슐화: 상위 계층의 데이터에 각종 정보를 추가하여 하위 계층으로 보내는 기법
  ㄴ 연결 제어: 데이터의 전송량이나 속도를 제어하는 기법
  ㄴ 오류 제어: 전송 중 잃어버리는 데이터나 오류가 발생한 데이터를 검증하는 제어 기법
  ㄴ 동기화: 송신과 수신 측의 시점을 맞추는 기법
  ㄴ 다중화: 하나의 통신 회선에 여러 기기들이 접속할 수 있는 기술
  ㄴ 주소 지정: 송신과 수신지의 주소를 부여하여 정확한 데이터 전송을 보장하는 기법

404. 데이터 링크 계층의 개념: 오흐회
  ㄴ 링크의 설정과 유지 및 종료를 담당하며 노드 간의 회선제어, 흐름제어, 오류 제어 기능을 수행하는 계층
  ㄴ 오류제어: OSI 7 Layer의 하위의 두 계층 사이에서 데이터의 전송 오류를 검출하여 복구하는 기술로 해밍 코드와 같은 전진 오류 수정(FEC) 기법과 체크썸, CRC, ARQ과 같은 후진 오류 수정(BEC) 기법이 있다.
  ㄴ 흐름 제어: 전송 스테이션으로 하여금 전송 데이터의 양을 제한하기 위해서 사용되는 기술러 정지-대기 기법과 슬라이딩 윈도우 기법이 있다.
  ㄴ 회선제어: 두 개의 스테이션이 동시에 신호를 전송하는 경우 신호 간 충돌이 발생하지 않도록 제어하는 기술로, ENQ/ACK 기법과 풀링 기법이 있다.

405. 데이터 링크 계층 프로토콜: HPFA
  ㄴ HDLC(High-level Data Link Control): 점대점 방식이나 다중방식의 통신에 사용되는 ISO에서 표준화한 동기식 비트 중심의 데이터 링크 프로토콜
  ㄴPPP(Point to Point Protocol): 네트워크 분야에서 두 통신 노드 간의 직접적인 연결응ㄹ 위해 일반적으로 사용되는 데이터 링크 프로토콜
  ㄴ 프레임 릴레이(Frame Relay): 프로토콜 처리를 간략화하여 단순히 데이터 프레임들의 중계(Relay) 기능과 다중화 기능만 수행함으로써 데이터 처리속도의 향상 및 전송지연을 감소시킨 고속의 데이터 전송 기술
  ㄴ ATM(Asynchronous Transport Mode): 정보 전달의 기본 단위를 53바이트 셀 단위로 전달하는 비동기식 시분할 다중화 박식의 패킷형 전송 기술

406. 네트워크 계층의 개념
  ㄴ 다양한 길이의 패킷을 네트워크들을 통해 전달하고, 그 과정에서 전송 계층이 요구하는 서비스 품질(QoS)을 위한 수단을 제공하는 계층이다, 라우팅, 패킷 포워딩, 인터 네트워킹 등을 수행한다.

407. 네트워크 계층 프로토콜
  ㄴ IP(Internet Protocol): 송수신 간의 패킷 단위로 데이터를 교환하는 네트워크에서 정보를 주고받는 데 사용하는 통신 프로토콜
  ㄴ ARP(Address Resolution Protocol): IP 네트워크 상에서 IP 주소를 MAC주소(물리 주소)로 변환하는 프로토콜
  ㄴ RARP(Reverse Address Resolution Protocol): IP 호스트가 자신의 물리 네트워크 주소(MAC)는 알지만 IP 주소를 모르는 경우, 서버로부터 IP 주소를 요청하기 위해 사용하는 프로토콜
  ㄴ ICMP(Internet Control Message Protocol): IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜. 메시지 형식은 8바이트의 헤더와 가변 길이의 데이터 영역으로 분리, 수신지 도달 불가 메시지는 수신지 또는 서비스에 도달할 수 없는 호스트를 통지하는 데 사용
  ㄴ IGMP(Internet Group Management Protocol): 인터넷 그룹 관리 프로토콜은 호스트 컴퓨터와 인접 라우터가 멀티캐스트 그룹 멤버십을 구성하는 데 사용하는 통신 프로토콜. 화상회의. IPTV에서 활용되는 프로토콜
  ㄴ 라우팅 프로토콜(Routing Protocol): 데이터 전송을 위해 목적지 까지 갈 수 있는 여러 경로 중 최적의 경로를 설정해주는 라우터 간의 상호 통신 프로토콜

408. IPv4(Internet Protocol version 4) 개념
  ㄴ IPv4는 인터넷에서 사용되는 패킷 교환 네트워크상에서 데이터를 교환하기 위한 32비트 주소체계를 갖는 네트워크 계층의 프로토콜이다.

409. IPv4 헤더
  ㄴ IP 패킷의 앞부분에서 주소 등 각종 제어정보를 담고 있는 부분, IPv4 헤더 사이즈는 옵션 미지정 시 최소 20바이트 이상 
  ㄴ 버헤타토 아플프 타플해 소데옵페: Version, Header Length / Type of Service / Total Length / Identification / Flag / Fragment Offset / Time to Live / Protocol / Header Checksum / Source Address / Destination Address / Options / Padding

410. IPv4 주소체계
  ㄴ IPv4 주소체계 10진수로 총 12자리이며, 네 부분으로 나뉜다.
  ㄴ 각 부분은 0~255까지 3자리의 수로 표현
  ㄴ IPv4 주소는 32비트로 구성되어 있으며, 인터넷 사용자의 증가로 인해 주소 공간의 고갈로 128비트의 주소체계를 갖는 IPv6가 등장, 점차 확산되고 있다.
  ㄴ 32비트 IP주소는 Network 를 나타내는 부분과 Host를 나타내는 부분으로 구성되어 있고, Network부분과 Host 부분을 구분하는 것은 서브넷 마스크이다.

411. IPv4 클래스의 분류
  ㄴ A 클래스: 가장 높은 단위의 클래스, 1~126범위의 IP주소를 가짐, 두번째, 세번째, 네번째 단위의 세 숫자는 A Class가 자유롭게 네트워크 사용자에게 부여가 가능한 IP임
  ㄴ B 클래스: 두번째로 높은 단위의 클래스, 첫번째 단위의 세 숫자는 128~191 가운데 하나를 가짐
  ㄴ C 클래스: 최하위 클래스, 첫 번째 단위의 세 숫자는 192~223 가운데 하나를 가짐
  ㄴ D 클래스: 멀티캐스트 용도로 예약된 주소
  ㄴ E 클래스: 연구를 위해 예약된 주소

412. IPv6(Internet Protocol version 6) 개념
  ㄴ IPv6는 인터넷 프로토콜 스택 중 네트워크 계층의 프로토콜로서 버전 6 인터넷 프로토콜로 제정된 차세대 인터넷 프로토콜
  ㄴ 현재 IPv4가 가지고 있는 주소 고갈, 보안성, 이동성 지원 등의 문제점을 해결하기 위해서 개발된 128Bit 주소체계를 갖는 차세대 인터넷 프로토콜이다.

413. IPv6 특징
  ㄴ IP 주소의 확장: IPv4의 기존 32비트 주소공간에서 벗어나, 128비트 주소공간 제공
  ㄴ 이동성: IPv6 호스트는 네트워크의 물리적 위치에 제한받지 않고 같은 주소를 유지하면서도 자유롭게 이동가능
  ㄴ 인증 및 보안 기능: 패킷 출처 인증과 데이터 무결성 및 비밀 보장 기능을 IP 프로토콜 체계에 반영, IPSec 기능적용 및 IPv4보다 보안성 강화
  ㄴ 개선된 QoS 지원: 흐름 레이블 개념을 도입, 특정 트래픽은 별도의 특별한 처리를 통해 높은 품질의 서비스를 제공
  ㄴ Plug&Play 지원: IPv6 호스트는 IPv6 네트워크에 접속하는 순간 자동적으로 네트워크 주소를 부여받음, 멀티미디어의 실시간 처리가 가능
  ㄴ Ad-hoc 네트워크 지원: Ad-hoc 네트워크를 위한 자동 네트워킹 및 인터넷 연결 지원, 자동으로 네트워크 환경 구성이 가능
  ㄴ 단순 헤더 적용: IP 패킷의 처리를 신속하게 할 수 있도록 고정 크기의 단순 헤더를 사용하는 동시에, 확장 헤더를 통해 기능에 대한 확장 및 옵션 기능의 사용이 용이한 구조
  ㄴ 실시간 패킷 추적 가능: 흐름 레이블을 사용하여 패킷의 흐름을 실시간 제공

414. IPv6 헤더
  ㄴ 버트플 페넥홉 소데: Version / Traffic Class / Flow Label / Payload Length / Next header / Hop Limit / Source Address / Destination Address

415. IPv6 주소체계
  ㄴ IPv6 128비트의 주소 공간
  ㄴ 일반적으로 16비트 단위로 나누어지며 각 16비트 블록은 다시 4자리 16진수로 변환되고 콜론으로 구분된다.
  ㄴ 64비트를 기준으로 앞 64비트를 네트워크 주소로, 뒤 64비트를 네트워크에 연결된 랜카드 장비 등에 할당하는 인터페이스 주소로 활용된다.
 
416. IPv4와 IPv6 전송방식 차이
  ㄴ IPv4: 유멀브(유니캐스트/멀티캐스트/브로드캐스트)
  ㄴ IPv6: 유멀애(유니캐스트/멀티캐스트/애니캐스트)

417. IPv4에서 IPv6로 전환 방법: 듀터주
  ㄴ 듀얼스택: 듀얼 스택은 IP 계층에 두가지(IPv4, IPv6)의 프로토콜이 모두 탑재되어 있고 통신 상대방에 따라 해당 IP 스택을 선택하는 방법이다.
    ㄴ 장점: DNS 주소 해석 라이브러리가 두 IP 주소 유형을 모두 지원
    ㄴ 단점: 프로토콜 스택 수정으로 인한 과다비용 발생
  ㄴ 터널링: IPv6망에서 인접한 IPv4 망을 거쳐 다른 IPv6 망으로 통신할 때 IPv4 망에 터널을 만들고 IPv4에서 사용하는 프로토콜로 캡슐화하여 전송하는 방법
    ㄴ 장점: 여러 표준화 활동 존재하고 다양한 기술 표준이 제안되고 있음
    ㄴ 단점: 구현이 어려우며, 복잡한 동작 과정을 가짐
  ㄴ 주소변환: 주소변환 기술은 IPv4 망과 IPv6 망 사이에 주소변환기(IPv4-IPv6 게이트웨이)를 사용하여 서로 다른 네트워크상의 패킷을 변환시키는 방법
    ㄴ 장점: IPv4, IPv6 호스트 프로토콜 스택에 대한 수정이 필요 없으며, 변환 방식이 투명하고 구현이 용이
    ㄴ 단점: 고가의 주소 변환기 필요

418. 멀티캐스트 프로토콜
  ㄴ 인터넷에서 같은 내용의 데이터를 여러 명의 특정한 그룹의 수신자들에게 동시에 전송할 수 있는 프로토콜이다.
  ㄴ 멀티캐스트 프로토콜 = 멀티캐스트 라우팅 프로토콜 + 그룹관리 프로토콜

419. 유니캐스트 프로토콜
  ㄴ 고유 주소로 식별된 하나의 네트워크 목적지에 1:1로 트래픽 또는 메시지를 전송하는 프로토콜

420. 브로드캐스트 프로토콜
  ㄴ 하나의 송신자가 같은 서브 네트워크 상의 모든 수신자에게 데이터를 전송하는 프로토콜
  ㄴ 전체에게 트래픽을 전달하는 All to All 통신은 각 송신자가 그룹 내의 모든 수신자에게 메시지를 전송하는 컴퓨터 통신 방법으로 네트워킹에서 종종 멀티캐스트 프로토콜을 사용하여 수행될 수 있다.

421. 애니캐스트 프로토콜
  ㄴ 단일 송신자로부터의 데이터그램을 토폴로지상의 잠재적인 수신자 그룹 안에서 가장 가까운 노드로 연결시키는 전송 프로토콜이다.
  ㄴ 하나의 수신 주소로 식별되는 다수의 노드로 데이터그램의 전송이 가능하다.

422. 라우팅 프로토콜(3계층)
  ㄴ 데이터 전송을 위해 목적지까지 갈 수 있는 여러 경로 중 최적의 경로를 설정해주는 라우터 간의 상호 통신 규약이다.

423.RIP(Routing Information Protocol)
  ㄴ 개념: AS(Autonomous System, 자율 시스템) 내에서 사용하는 거리 벡터(Distance-Vector) 알고리즘에 기초하여 개발된 내부 라우팅 프로토콜
  ㄴ 특징: 벨만-포드(Bellman-Ford) 알고리즘 사용하는 내부 라우팅 프로토콜, 15홉 제한, UDP 포트번호 520 사용, 39초마다 전체 라우팅 정보를 브로드캐스팅
  ㄴ 홉이란? 데이터가 목적지까지 전달되는 과정에서 거치는 네트워크의 수를 의미한다.

424. OSPF(Open Shortest Path First) 개념
  ㄴ OSPF는 규모가 크고 복잡한 TCP/IP 네트워크에서 RIP의 단점을 개선하기 위해 자신을 기준으로 링크 상태 알고리즘을 적용하여 최단 경로를 찾는 라우팅 프로토콜

425. OSPF 특징
  ㄴ 다익스트라 알고리즘 사용: 링크 상태 라우팅 기반 메트릭 정보를 한 지역 내 모든 라우터에 변경이 발생했을 때만 보내고 라우팅 테이블을 구성
  ㄴ 라우팅 메트링 지정
  ㄴ AS 분할 사용
  ㄴ 홉 카운트 무제한

426. BGP(Border Gateway Protocol) 개념
  ㄴ AS 상호 간(Inter-AS)에 경로 정보를 교환하기 위한 라우팅 프로토콜

427. BGP 특징
  ㄴ 변경 발생 시 대상까지의 가장 짧은 경로를 경로 벡터 알고리즘을 통해 선정하고, TCP 연결을 통해 자치 시스템으로 라우팅 정보를 신뢰성 있게 전달한다.
  ㄴ ISP 사업자들 상호간에 주로 사용되는 라우팅 프로토콜
  ㄴ 순환을 피할 수 있도록 목적지 까지 가는 경로 정보를 제공한다.
  ㄴ 라우팅 비용이 많이 들고, 라우팅 테이블의 크기가 커서 메모리 사용량이 많다.

428. 라우팅 알고리즘: 목적지까지의 최적 경로를 산출하기 위한 법칙이 라우팅 알고리즘
  ㄴ 거리 벡터 알고리즘(Distance Vector Algorithm): 거리 벡터 알고리즘은 인접 라우터와 정보를 공유하여 목적지까지의 거리와 방향을 결정하는 라우팅 프로토콜 알고리즘, 벨만-포트 알고리즘 사용
  ㄴ 링크 상태 알고리즘(Link state Algorithm): 링크 상태 정보를 모든 라우터에 전달하여 최단 경로 트리를 구성하는 라우팅 프로토콜 알고리즘, 다익스트라 알고리즘 사용, 링크 상태 알고리즘을 사용하면 네트워크를 일관성 있게 파악할 수 있으나 거리 벡터 알고리즘에 비하여 계산이 더 복잡하고 트래픽을 광범위한 범위까지 전달

429. 전송계층(Transport Layer) 개념
  ㄴ 전송계층은 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해주면서 종단 간 사용자들에게 신뢰성 있는 데이터를 전달하는 계층
 
430. TCP(Transmission Control Protocol) 개념
  ㄴ 전송 제어 프로토콜은 인터넷 프로토콜 스위트의 핵심 프로토콜 중 하나로, IP와 함께 TCP/IP 라는 명칭으로 사용된다.
  ㄴ TCP는 전송 계층에 위치하면서 근거리 통신망이나 인트라넷, 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 옥텟을 안정적으로, 순서대로, 에러 없이 교환할 수 있게 해주는 프로토콜

431. TCP 특징: 신연흐혼
  ㄴ 신뢰성 보장: 패킷 손실, 중복, 순서 바뀜 등이 없도록 보장, TCP 하위 계층인 IP 계층의 신뢰성 없는 서비스를 보완
  ㄴ 연결 지향적 특징:  같은 전송계층의 UDP가 비연결성인 것과는 달리 TCP는 연결 지향적, 양단간 애플리케이션/프로세스는 TCP가 제공하는 연결성 회선을 통하여 서로 통신
  ㄴ 흐름제어(Flow control): 흐름 제어 기능을 활용하여 송신 및 수신 속도를 일치시킴
  ㄴ 혼잡제어(Cogestion control): 네트워크가 혼잡하다고 판단될 때는 혼잡제어 기법을 사용하여 송신율을 감속함

432. TCP 헤더 구조
  ㄴ TCP 헤더의 최소 크기는 20바이트
  ㄴ 소데씨엑 헤리플윈 체어옵패: Source Port Number / Destination Port Number / Sequence Number / Acknowledgement Number / HLEN(Header Length) / Flag Bit / Window Size / Checksum / Urgent Pointer / Options and Padding

433. UDP(User Datagram Protocol) 개념: 비연결성이고, 신뢰성이 없으며, 순서화 되지 않은 데이터그램 서비스를 제공하는 전송 계층 통신 프로토콜

434. UDP 특징: 비순실단
  ㄴ 비신뢰성: 데이터그램 지향의 전송계층용 프로토콜(논리적인 가상회선 연결 필요없음), 메시지가 제대로 도착했는지 확인하지 않음, 검사 합을 제외한 특별 오류 검출 및 제어 없음
  ㄴ 순서화되지 않은 데이터그램 서비스 제공: 수신된 메시지의 순서를 맞추지 않음, 흐름 제어를 위한 피드백을 제공하지 않음
  ㄴ 실시간 응용 및 멀티캐스팅 가능: 빠른 요청과 응답이 필요한 실시간 응용에 적합, 여러 다수 지점에 전송 가능
  ㄴ 단순 헤더: 헤더는 고정 크기의 8바이트만 사용, 헤더 처리에 시간과 노력이 필요하지 않음

435. UDP 헤더 구조: 소데 랭체다
  ㄴ Source Port Number / Destination Port Number / UDP Length / UDP Checksum / Data

436. 세션 계층 개념
  ㄴ 응용 프로그램 간의 대화를 유지하기 위한 구조를 제공하고, 이를 처리하기 위해 프로세스들의 논리적인 연결을 담당하는 계층이다.
  ㄴ 통신 중 연결이 끊어지지 않도록 유지시켜주는 역할 수행하기 위해 TCP/IP 세션 연결의 설정과 해제, 세션 메시지 전송 등의 기능을 수행한다.

437. 세션 계층 프로토콜
  ㄴ RPC(Remote Procedure Call): 원격 프로시저 호출이라고 불리며, 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있는 프로세스 간 통신에 사용되는 프로토콜
  ㄴ NetBIOS(Network Basic Input/Output System): 응용계층의 애플리케이션 프로그램에게 API를 제공하여 상호 통신할 수 있도록 해주는 프로토콜

438. 표현 계층 개념
  ㄴ 애플리케이션이 다루는 정보를 통신에 알맞은 형태로 만들거나, 하위 계층에서 온 데이터를 사용자가 이해할 수 있는 형태로 만드는 역할을 담당하는 계층
  ㄴ 수신자 장치에서 적합한 애플리케이션을 사용하여 응용계층 데이터의 부호화 및 변환 수행을 통해 송신 장치로부터 온 데이터를 해석한다.

439. 표현 계층 프로토콜: JM
  ㄴ JPEG: 이미지를 위해 만들어진 표준 규격
  ㄴ MPEG: 멀티미디어를 위해 만들어진 표준 규격

440. 응용 계층 개념
  ㄴ 응용 계층은 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행하는 역할을 담당하는 계층
  ㄴ 응용 프로세스가 개방된 형태로 다양한 범주의 정보처리기능을 수행할 수 있도록 여러 가지 프로토콜 개체에 대하여 사용자 인터페이스를 제공한다

441. 응용 계층의 프로토콜
  ㄴ HTTP(HyperText Transfer Protocol): 텍스트 기반의 통신 규약으로 인터넷에서 데이터를 주고받을 수 있는 프로토콜, 하이퍼텍스트를 빠르게 교환하기 위한 프로토콜 
  ㄴ FTP(File Transfer Protocol): TCP/IP 프로토콜을 가지고 서버와 클라이언트 사이의 파일을 전송하기 위한 프로토콜
  ㄴ SMTP(Simple Mail Transfer Protocol): 인터넷에서 TCP 포트 번호 25번을 사용하여 이메일을 보내기 위해 이용되는 프로토콜
  ㄴ POP3(Post Office Protocol version 3): 원격 서버로부터 TCP/IP 연결을 통해 이메일을 가져오는데 사용하는 프로토콜
  ㄴ IMAP(Internet Messaging Access Protocol): 원격 서버로부터 TCP/IP 연결을 통해 이메일을 가져오는데 사용하는 프로토콜
  ㄴ Telnet: 인터넷이나 로컬 영역에서 네트워크 연결에 사용되는 네트워크 프로토콜

442. 패킷 스위칭: 컴퓨터 네트워크와 통신 방식 중 하나로 작은 블록의 패킷으로 데이터를 전송하며 데이터를 전송하는 동안만 네트워크 자원을 사용하도록 하는 통신 방식
  ㄴ X.25: 통신을 원하는 두 단말장치가 패킷 교환망을 통해 패킷을 원활히 전달하기 위한 통신 프로토콜이다.
  ㄴ 프레임 릴레이: ISDN을 사용하기 위한 프로토콜로서 ITU-T에 의해 표준으로 작성됨
  ㄴ ATM: 비동기 전송모드라고 하는 광대역 전송에 쓰이는 스위칭 기법, 동기화를 맞추지 않아 보낼 데이터가 없는 사용자의 슬롯은 다른 사람이 사용할 수 있도록 하여 네트워크 상의 효율성을 높였다.

443. 서킷 스위칭: 네트워크 리소스를 특정 사용층이 독접하도록 하는 통신 방식

444. 제품 소프트웨어 패키징 개념
  ㄴ 개발이 완료된 제품 소프트웨어를 고객에게 전달하기 위한 형태로 포장하는 과정이다.
  ㄴ 모듈의 개념을 정확하게 파악한 후에 기능 단위로 패키징하는 것이 필요
  ㄴ 배포 전 시험 및 수정 등의 작업 진행에서도 모듈 단위로 분류하여 작업을 진행한다.

445. 소프트웨어 모듈화
  ㄴ 모듈을 이용하여 소프트웨어의 성능을 향상시키거나 시스템의 디버깅, 시험, 통합 및 수정을 용이하도록 하는 모듈 중심의 소프트웨어 설계 기법
  ㄴ 모듈 간 결합도를 최소화하고 응집도를 최대화 하는 것이 중요하다.
  ㄴ 모듈이란? 소프트웨어 설계에서 기능 단위로 분해하고 추상화되어 재사용 및 공유 가능한 수준으로 만들어진 단위이다.

446. 모듈화 장점: 개발편의성, 복잡성 감소

447. 사용자 중심의 패키징 고려사항: 소프트웨어 패키징은 사용자를 위해 진행되는 작업으로서, 고객 편의성 및 사용자 실행 환경을 우선 고려하여 진행한다.
  ㄴ 고려사항: 시스템 환경, 직관적 UI, 관리 서비스, 안정적 배포

448. 사용자 중심 모듈 패키징 프로세스
  ㄴ 기능 식별 -> 모듈화 -> 빌드 진행 -> 사용자 환경 분석 -> 패키징 적용 시험 -> 패키징 변경 개선

449. 릴리즈 노트의 개념: 최종 사용자인 고객에게 개발 과정에서 정리된 제품의 릴리즈 정보를 제공하는 문서, 릴리즈 정보는 상세 서비스 정보를 포함하여 제품의 수정, 변경, 개선하는 일련의 작업들에 대한 정보이며, 릴리즈 노트를 통해 제공된다.

450. 릴리즈 노트 중요성: 정보제공, 관리의 용이성

451. 릴리즈 노트 작성 시 고려사항: 현재 시제로 작성되어야 하며, 배포 시부터 신규 소스, 빌드 등 이력을 명확하고 정확하게 제공한다. 개발자와 테스터가 함께 협업해야하고 변경 개선 항목까지 연결되어 다음 항목에 대한 정보들이 릴리즈 노트를 통해 작성되어야한다.

452. 릴리즈 노트 작성 항목: 헤개목이 재수사소 노면연
  ㄴ 헤더
  ㄴ 개요
  ㄴ 목적
  ㄴ 이슈 요약
  ㄴ 재현 항목
  ㄴ 수정, 개선 내용
  ㄴ 사용자 영향도
  ㄴ 소프트웨어 지원 영향도
  ㄴ 노트
  ㄴ 면책 조항
  ㄴ 연락 정보

453. 디지털 저작권 관리(DRM; Digital Right Management) 기능 활용
  ㄴ 저작권 관리 구성요소: 제분패 보D클
      ㄴ 콘텐츠 제공자(Contents Provider): 콘텐츠를 제공하는 저작권자
      ㄴ 콘텐츠 분배자(Contents Distributor): 쇼핑몰 등으로써 암호화된 콘텐츠 제공
      ㄴ 패키저(Packager): 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 기능
      ㄴ 보안 컨테이너(Security Container): 원본을 안전하게 유통하기 위한 전자적 보안 장치
      ㄴ DRM 컨트롤러(DRM Controller): 배포된 콘텐츠의 이용 권한을 통제
      ㄴ 클리어링 하우스(Clearing House): 소비자와 유통업자 사이에 발생하는 거래에 대해 디지털 저작권 라이선싱을 중개하고 라이선스 발급을 수행하는 정산소, 모니터링 서비스를 지원하여 디지털 저작물의 이용 내역을 근거로 신뢰할 수 있는 저작권료의 정산 및 분배가 이루어짐

454. 암호화/ 보안 기능 중심의 패키징 도구 구성: 암키식저 파크정인
  ㄴ 암호화(Encryption): 일반 텍스트, 콘텐츠, 라이선스 등의 암ㄹ호화 및 전자서명에 사용하는 기술 ex) 공개 키 기반 구조, 대칭 및 비대칭 암호화, 전자서명
  ㄴ 키 관리(Key Management): 키에 대한 저장 및 배포 기술 
  ㄴ 식별 기술(Identification): 식별 체계 표현 기술 ex) DOI, URI
  ㄴ 저작권 표현(Right Expression): 라이선스의 내용 표현 기술 ex) XrML, MPEG-21
  ㄴ 암호화 파일 생성(Packager): 콘텐츠의 암호화를 통해 콘텐츠를 보호하는 기술 ex) Pre-packaging, On-the-fly Packaging
  ㄴ 크랙 방지(Tamper Resistance): 크랙에 의한 콘텐츠 사용 방지 기술 ex) 난독화, Secure DB
  ㄴ 정책 관리(Policy Management):라이선스 발급 및 사용에 대한 정책표현 및 관리기술: XML, 콘텐츠 관리 시스템(CMS)
  ㄴ 인증(Authentication): 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술 ex) 사용자/장비 인증, SSO

455. 애플리케이션 배포 도구를 활용한 배포 프로세스
  ㄴ 빌드 내용 식별 -> 패키징 도구 식별 -> DRM 흐름을 확인하여 패키징 수행 -> 패키징 도구 설치 -> 배포 작업 -> 정상 배포 확인

456. 제품 소프트웨어 매뉴얼 개념
  ㄴ 사용자 측면에서 패키징 이후 설치, 제품 소프트웨어를 사용하는 데 필요한 주요 내용 기록한 문서
  ㄴ 사용자 중심의 기능 및 방법을 나타낸 설명서와 안내서
  ㄴ 설치 매뉴얼과 사용자 매뉴얼이 있다.

457. 설치 매뉴얼 기본 작성 항목: 목이주구
  ㄴ 목차 및 개요
  ㄴ 문서 이력 정보
  ㄴ 설치 매뉴얼 주석
  ㄴ 설치 도구의 구성

458. 설치 매뉴얼 구성요소
  ㄴ 제품 소프트 웨어 개요
  ㄴ 설치 관련 파일
  ㄴ 설치 절차
  ㄴ 설치 아이콘
  ㄴ 삭제 방법
  ㄴ 설치 버전 및 작성자
  ㄴ 고객 지원 방법 및 FAQ
  ㄴ 준수 정보 & 제한 보증

459. 사용자 매뉴얼 작성 항목
  ㄴ 목차 및 개요
  ㄴ 문서 이력 정보
  ㄴ 사용자 매뉴얼 주석
  ㄴ 기록항목
  ㄴ 기본사항
  ㄴ 고객 지원 방법 및 FAQ
  ㄴ 준수 정보 & 제한 보증

460. 버전 관리 도구를 통한 관리
  ㄴ 버전 관리 백업 및 복구: 이전 버전으로의 복구 필요시, 이전 버전 기능 재활용 시
  ㄴ 동일 버전 공동 작업: 동일 버전의 소스코드를 두 명 이상의 개발자가 수정할 경우, 분산 환경에서 두 명 이상의 개발자가 동일한 버전의 소스를 수정할 경우
  ㄴ 여러 버전 솔루션 작업: 하나의 솔루션을 기반으로 여러 버전의 제품을 개발할 경우

461. 소스 및 자료 백업
  ㄴ 천재지변이나 해킹, 작게는 소프트웨어 버그 및 오동작 등으로 인한 재해에 대비에 시스템을 회복 가능한 상태로 만들기 위해 준비하는 것
  ㄴ 손실의 예방 및 최소화를 우선해야하고, 최단 기간에 정상 업무에 복구하도록 버전 관리 도구 적절히 사용해야함

462. 백업의 유형: 전차증
  ㄴ 전체 백업: 백업받고자 하는 데이터 전체에 대해 백업하는 방식
  ㄴ 차등 백업: 마지막 전체 백업 이후 변경된 모든 데이터를 백업하는 방식
  ㄴ 증분 백업: 정해진 시간을 기준으로 그 이후에 변경된 파일만을 백업하는 방식

---------------------------------------------------------------------------------------------------------------------

2회차

463. 소프트웨어 생명주기 모델(SDLC; Software Development Life Cycle)
   ㄴ 시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차. 

464. 폭포수 모델(Waterfall model)
  ㄴ 소프트웨어 개발 시 앞 단계를 마무리 지은 후 이후 단계를 진행하는 생명주기 모델, 가장 오래된 모델이며 고전적 생명주기 모형이라고도 함.
  ㄴ 타당성 검토 -> 계획 -> 요구분석 -> 설계 -> 구현 -> 테스트 -> 유지보수

465. 프로토 타이핑 모델
  ㄴ 개발자와 사용자 공통의 참조 모델을 제공, 고객의 피드백을 반영해서 프로토타입 제작하는 모델

466. 나선형 모델
  ㄴ 계획 및 정의 -> 위험 분석 -> 개발 -> 고객 피드백을 반복하여 점진적으로 완벽한 시스템으로 개발해나가는 모델

467. 반복적 모델
  ㄴ 구축 대상을 나누어 병렬적으로 개발해서 통합하는 모델

468. 소프트웨어 개발 방법론
  ㄴ 소프트웨어 개발 전 과정에서 지속적으로 적용할 수 있는 방법, 절차, 기법이다.

469. 구정객컴애제
  ㄴ 구조적 방법론
  ㄴ 정보공학 방법론
  ㄴ 객체지향 방법론
  ㄴ 컴포넌트 기반 방법론
  ㄴ 애자일 방법론
  ㄴ 제품 계열 방법론

470. 구조적 방법록
  ㄴ 전체 시스템을 기능에 따라 나누어 개발하고, 이를 통합하는 분할과 정복 방법론, 프로세스 중심 하향식 방법론 나씨-슈나이더만 차트, 논리의 기술에 중점을 둔 도형식 표현 방법

471. 정보공학 방법론
  ㄴ 정보시스템 개발에 필요한 관리 절차와 작업 방법을 체계화한 방법론

472. 객체지향 방법론
  ㄴ 복잡한 현실세계를 사람이 이해하는 방식으로 시스템에 적용하는 방법론, '객체'라는 기본단위로 시스템을 분석 및 설계

473. 컴포넌트 기반
  ㄴ 소프트웨어를 구성하는 컴포넌트를 조립하여 하나의 새로운 프로그램을 작성하는 방법론

474. 애자일 방법론
  ㄴ 절차보다는 사람이 중심이 되어 변화에 유연하고, 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 방법론

475. 제품 계열 방법론
  ㄴ 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론

476. 애자일 방법론 세부
  ㄴ 개발 기간이 짧고 신속하며, 폭포수 모형에 대비되는 방법론으로 개발과 함꼐 즉시 피드백을 받아 유동적으로 개발할 수 있ㅇ다.

477. 애자일 방법론의 유형
  ㄴ XP, 스크럼, 린

478. XP의 5가지 가치: 용단의 피존
  ㄴ 용기: 용기를 가지고 개발
  ㄴ 단순성: 필요한 것만 하기
  ㄴ 의사소통: 고객, 개발자, 관리자 간의 원활한 의사소통
  ㄴ 피드백: 의사소통에 대한 빠른 피드백
  ㄴ 존중: 팀원 간 상호 존중

479. XP의 12가지 기본원리: 짝공통계릴메디테리40고표
  ㄴ 짝 프로그래밍: 2명씩 짝 지어서 코딩
  ㄴ 공동 코드 소유: 시스템에 있는 코드는 누구든지 수정 가능
  ㄴ 지속적인 통합: 매일 여러번 씩 소프트웨어를 통합하고 빌드
  ㄴ 계획 세우기: 고객이 요구하는 비즈니스 가치를 정의하고, 개발자가 필요한 것은 무엇이며 어떤 부분에서 지연될 수 있는지를 알려주어야 한다는 원리
  ㄴ 작은 릴리즈 단위: 작은 시스템을 먼저 만들고, 짧은 단위로 업데이트 한다는 원리
  ㄴ 메타포어: 공통적인 이름체계와 시스템 서술서를 통해 고객과 개발자 간의 의사소통을 원활하게 한다는 원ㄹㅣ
  ㄴ 간단한 디자인: 요구사항에 적합한 가장 단순한 시스템을 설계한다는 원리
  ㄴ 테스트 기반 개발: 테스트를 먼저 수행하고, 이 테스트를 통과하 수 있도록 실제 프로그램의 코드를 작성한다는 원리
  ㄴ 리팩토링: 프로그램의 기능은 바꾸지 않으면서 중복제거, 단순화 등을 위해 시스템을 재구성
  ㄴ 40시간: 개발자가 피로감으로 인해 실수하지 않도록 주 40시간 이상 일을 하지 않도록 하는 원리
  ㄴ 고객 상주: 개발자들의 질문에 즉각 대답할 수 있도록 고객을 프로젝트에 풀타임 상주
  ㄴ 코드 표준: 효과적인 공동 작업을 위해서는 모든 코드에 대한 코딩 표준을 정의해야한다는 원리

480. 스크럼: 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론: 스크미마회번
  ㄴ 백로그: 제품과 프로젝트에 대한 요구사항
  ㄴ 스프린트: 2~4주의 짧은 개발 기간으로 반복적 수행으로 개발품질 향상
  ㄴ 스크럼 미팅: 매일 15분 정도 미팅으로 To-Do List 계획 수립, 데일리 미팅
  ㄴ 스크럼 마스터: 프로젝트 리더, 
  ㄴ 스크럼 회고: 스프린트 주기를 되돌아보며 정해놓은 규칙 준수 여부, 개선점 등을 확인 및 기록
  ㄴ 번다운 차트: 남아있는 백로그 대비 시간을 그래픽적으로 표현한 차트

481. 린: 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소 제거: 낭품지확인사전
  ㄴ 낭비제거
  ㄴ 품질내재화
  ㄴ 지식 창출
  ㄴ 늦은 확인
  ㄴ 빠른 인도
  ㄴ 사람 존중
  ㄴ 전체 최적화

482. 비용산정 모델
  ㄴ 하향식 방법론: 경험이 많은 전문가에게 비용산정 의뢰, 전문가 판단, 델파이
  ㄴ 상향식 방법론: 세부적인 요구사항과 기능에 따라 필요한 비용을 계산, LoC MM COCOMO Putnam FP

483. 델파이 기법: 전문가의 경험적 지식을 통한 문제 해결 및 미래예측을 위한 기법으로 전문가 합의법이라고도 한다.

484. Lines of Code
  ㄴ 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구하여 비용산정, 쉽고 이해하기 쉬워 널리 사용
  ㄴ 낙관치+4중간치+비관치/6
 
485. Man Month: LoC/프로그래머 월간 생산성, 기간=MM/인력

486. COCOMO: 보헴이 제안한 모형, 프로그램 규모에 따라 비용을 산정, 조직형, 반 분리형, 임베디드 형으로 나뉨
  ㄴ 조직형: 5만 라인 이하의 소프트웨어 개발, 중 소규모의 소프트웨어  
  ㄴ 반 분리형: 30만 라인 이하, 트랜잭션 처리 시스템이나, 데이터베이스 관리 시스템, 컴파일러 등과 같은 유틸 개발에 적용
  ㄴ 임베디드: 초대형 규모의 트랜잭션 처리, 운영체제, 실시간 처리 등 시스템 프로그램, 30만

487. 푸트남
  ㄴ 소프트웨어 개발주기의 단계별로 요구할 인력의 분포를 가정, Rayleigh-Norden 곡선의 노력 분포도 기초

488. 기능점수 모형
  ㄴ 요구 기능을 증가시키는 인자별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능의 점수 계산

489. CPM(Critical Path Method): 여러 작업의 수행 순서가 얽혀 있는 프로젝트의 일정 계산 방법, 프로젝트의 시작과 끝을 나타내는 노드와 노드간 연결을 통해 공정 계산

490. PERT(Program Evaluation and Review Technique): 일의 순서를 계획적으로 정리하기 위한 수렴 기법으로 비관치, 중간치, 낙관치 3점 추정방식 통해 일정 계산

491. 중요 연쇄 프로젝트 관리(CCPM): CPM에서 자원 제약사항을 고려해서 일정 작성

492. LoC가 30000라인이고, 개발자가 5명이고 월평균 300라인
  ㄴ 프로젝트 개발기간:
  ㄴ 계산식: 라인수/개발자 월 평균 생산량 = 100MM, 100MM / 5명 개발자 = 20개월

493. 현행 시스템 파악 절차
  ㄴ 1단계: 구성/기능/인터페이스 파악
  ㄴ 2단계: 아키텍처 및 소프트웨어 구성 파악
  ㄴ 3단계: 하드웨어 및 네트워크 구성 파악

494. 소프트웨어 아키텍처 4+1뷰
  ㄴ 고객 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어 적인 접근 방법
  ㄴ 4개의 분리된 구조로 구성되는 아키텍처 개념 제시 후, 체크 방법으로 유스케이스 사용
  ㄴ 유논프구배, 유스케이스뷰, 논리뷰, 프로세스뷰, 구현뷰, 배포뷰
  ㄴ 유스케이스: 시스템이 액터에게 제공해야하는 기능으로서 시스템 요구사항이자, 사용자 입장에서 바라본 시스템 기능

495. 유스케이스뷰: 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는데 사용되는 뷰
  ㄴ 논리뷰: 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
  ㄴ 프로세스뷰: 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰 
  ㄴ 구현뷰: 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
  ㄴ 배포뷰: 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가 매핑에서 보여주는 뷰

496. 소프트웨어 아키텍처 패턴: 소프트웨어를 설계할 떄 참조할 수 있는 전형적인 해결방식
  ㄴ 계층화패턴: 시스템을 계층으로 구분하여 구성하는 패턴
  ㄴ 클라이언트-서버: 하나의 서버와 다수의 클라이언트로 구성된 패턴
  ㄴ 파이프-필터: 서브 시스템이 입력 데이터를 받아 처리하고, 결과를 다음 서브 시스템으로 넘겨주는 과정 반복
  ㄴ 브로커: 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 이 컴포넌트들은 원격 서비스 실행ㅇ르 통해 상호작용이 가능, 브로커가 컴포넌트와 컴포넌트 간의 통신 조정
  ㄴ MVC: 모델-뷰-컨트롤러 3개의 서브시스템으로 구분하여 구조화, 모델: 핵심 기능과 데이터 보관, 뷰: 사용자에게 정보 표시, 컨트롤러: 사용자로부터 요청을 입력받아 처리, 각 부분이 컴ㅍ넌트로 분리되어 있어 서로 영향 받지 않고 개발 작업 수행 가능

497. 소프트웨어 아키텍처 비용평가 모델:SACAA
  ㄴ SAAM: 변경 용이성과 기능성에 집중, 평가가 용이하여 경험이 없는 조직에서도 활용 가능
  ㄴ ATAM: 아키텍처 품질 속성을 만족시키는지 판단 및 품질 속성들의 이해 상충관계까지 평가하는 모델
  ㄴ CBAM: ATAM 바탕의 시스템 아키텍처 분석 중심으로 경제적 의사결정에 대한 요구를 충족하는 비요ㅇ평가모델
  ㄴ ADR: 소프트웨어 아키텍처 구성요소 간 응집도 평가
  ㄴ ARID: 전체 아키텍처가 아닌 특정 부분에 대한 품질요소에 집중하는 비용평가 모델

498. 디자인 패턴: 소프트웨어 설계에서 공통으로 발생한느 문제에 대해 자주 쓰인느 설계방법을 정리

499. 디자인 패턴 구성요소: 패문솔사결샘
  ㄴ 패턴이름
  ㄴ 문제 및 배경
  ㄴ 솔루션
  ㄴ 사례
  ㄴ 결과
  ㄴ 샘플코드

500. 디자인 패턴 유형
 목적-생성, 구조, 행위
 범위-클래스, 객체
  ㄴ 생성: 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화
  ㄴ 구조: 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
  ㄴ 행위: 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴

501. 생빌 프로 팩앱싱(생성 - 빌더, 프로토타입, 팩토리 메서드, 앱스트랙 팩토리, 싱글톤)

502. Builder
  ㄴ 복잡한 인스턴스를 조립하여 만드는 구조로, 복합 객체를 생성할 때 객체를 생성하는 방법과 객체를 구현하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴, 생성과 표기를 분리해서 복잡한 객체를 생성

503. Prototype
  ㄴ 처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴으로, 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정하며 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용되는 디자인 패턴, 기존 객체를 복제함으로써 객체를 생성

504. Factory Method
  ㄴ 상위 킇ㄹ래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식으로, 상위 클래스에서는 인스턴스를 만드는 방법만 결정하고, 하위 클래스에서 그 데이터의 생성을 책임지고 조작하는 함수들을 오버로딩하여 인터페이스와 실제 객체를 생성하는 클래스를 분리할 수 있는 특성을 갖는 디자인 패턴

505. Abstract Factory 
  ㄴ 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴으로 이 패턴을 통해 생성된 클래스에서는 사용자에게 인터페이스를 제공하고, 구체적인 구현은 Concrete Product 클래스에서 이루어지는 특징을 갖는 디자인 패턴, 동일한 주제의 다른 팩토리를 묶음

506. Singleton
  ㄴ 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인 패턴, 한 클래스에 한 객체만 존재하도록 제한

507. 구 브데 퍼플 프록 컴 어(구조 - 브릿지, 데코레이터, 퍼사이드, 플라이웨이트, 프록시, 컴포지트, 어댑처)
 
508. Bridge
  ㄴ 기능의 클래스 계층과, 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴, 구현 뿐만 아니라 추상화된 부분까지 변경해야하는 경우 활용

509. Decorator
  ㄴ 기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 설계 패턴으로 기능 확장이 필요할 때 객체 간의 결함을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주어 상속의 대안으로 사용하는 디자인 패턴, 객체의 결합을 통해 기능을 동적으로 유연하게 확장

510. Facade
  ㄴ 복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 사용자와 시스템 간 또는 여타 시스템과의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴으로 오류에 대해서 단위별로 확인할 수 있게 하며, 사용자의 측면에서 단순한 인터페이스 제공을 통해 접근성을 높일 수 있는 디자인 패턴, 통합된 인터페이스 제공

511. Flyweight
  ㄴ 다수의 객체로 생설될 경우 모두가 갖는 본질적인 요소를 클래스화하여 공유함으로써 메모리를 절약하고, 클래스의 경량화를 목적으로 하는 디자인 패턴, 여러 개의 가상 인스턴스를 제공하여 메모리 절감

512. Proxy
  ㄴ 실체 객체에 대한 대리 객체로 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며, 이 점을 이요해서 미리 할당하지 않아도 상관 없는 것들을 실제 이용할 때 할당하게 하여 메모리 용량을 아낄 수 있으며, 실체 객체로 드러나지 않게 하여 정보은닉의 역할도 수행하는 디자인 패턴, 특정 객체로의 접근을 제어하기 위한 용도로 사용

513. Composite
  ㄴ 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 패턴, 복잡 객체와 단일 객체를 동일하게 취급

514. Adapter
  ㄴ 기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴으로, 상속을 이용하는 클래스 패턴과 위임을 이용하는 인스턴스 패턴의 두가지 형태로 사용되는 디자인 패턴, 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움

515. 행 미인이 템옵 스테 비커 스트 메체(행위 - 미디에이터, 인터프리터, 이터레이터, 템플릿 메서드, 옵저버, 스테이트, 비지터, 커맨드, 스트레티지, 메멘토, 체인 오브 리스폰서빌리티)

516, Mediator
  ㄴ 객체지향 설계에서 객체의 수가 너무 많아지면 서로 간 통신을 위해 복잡해져서 가장 중요한 느슨한 결합의 특성을 해칠 수 있기 때문에 이를 해결하는 방법으로 중간에 이를 통제하고 지시할 수 있는 역할을 하는 중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 객체지향의 목표를 달성하게 해주는 디자인 패턴, 상호작용의 유연한 변경을 지원

517. Interpreter
  ㄴ 언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 디자인 패턴, 문법 자체를 캡슐화하여 사용

518. Iterator
  ㄴ 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 방법을 제공하는 디자인 패턴, 내부 구조를 노출하지 않고 복잡 객체의 원소를 순차적으로 접근 가능하게 해주는 행위 패턴

519. Template Method
  ㄴ 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴으로 일반적으로 상위 클래스(추상 클래스)에는 추상 메서드를 통해 기능의 골격을 제공하고, 하위 클래스(구체 클래스)의 메서드에는 세부 처리를 구체화하는 방식으로 사용하여 코드의 양을 줄이고 유지보수를 용이하게 만드는 특징을 갖는 디자인 패턴, 상위 작업의 구조를 바꾸지않으면서 서브 클래스로 작업의 일부분을 수행

520. Observer
  ㄴ 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법으로 일대 다의 의존성을 가지며 상호작용하는 개체 사이에서는 가능하면 느슨하게 결합하는 디자인 패턴, 객체의 상태 변화에 따라 다른 객체의 상태도 연동, 일대 다 의존

521. State
  ㄴ 객체 상태를 캡슐화하여 클래스화함으로써 그것을 참조하게 하는 방식으로 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경하여, 변경 시 원시코드의 수정을 최소화할 수 있고, 유지보수의 편의성도 갖는 디자인 패턴, 객체의 상태에 따라 행위 내용을 변경

522. Visitor
  ㄴ 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴으로, 객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때 사용하는 디자인 패턴, 특정 구조를 이루는 복합 객체의 원소 특성에 따라 동작을 수행할 수 있도록 지원하는 행위

523. Command
  ㄴ 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴으로 하나의 추상 클래스에 메서드를 만들어 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 갖는 디자인 패턴, 요구사항을 객체로 캡슐화

524. Strategy
  ㄴ 알고리즘 군을 정의하고(추상 클래스) 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴으로, 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 디자인 패턴, 행위 객체를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변환

525. Memento
  ㄴ 클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 디자인 패턴으로 Undo 기능을 개발할 때 사용하는 디자인 패턴, 객체를 이전 상태로 복구시켜야 하는 경오 Undo 요청 가능

526. Chain of Responsibility
  ㄴ 정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어 있을 떄 기능 처리의 연결 변경이 불가능한데, 이를 동적으로 연결되어 있는 경우에 따라 다라게 처리될 수 있도록 연결한 디자인 패턴, 한 요청을 2개 이상의 객체에서 처리

527. 운영체제의 개념
  ㄴ 컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있도록 해주고, 사용자와 하드웨어 간에 인터페이스를 담당

528. 운영체제 현행 시스템 분석: 품신성 지기주구
  ㄴ 품질측면 - 신뢰도, 성능
  ㄴ 지원측면 - 기술지원, 주변기기, 구축비용

529. DBMS 현행 시스템 분석: 가성호기구
  ㄴ 성능측면 - 가용성, 성능, 상호 호환성
  ㄴ 지원측면 - 기술지원, 구축비용

530. 미들웨어 현행 시스템 분석: 가성기구
  ㄴ 성능측면 - 가용성, 성능
  ㄴ 지원측면 - 기술지원, 구축비용

531. 소프트웨어 아키텍처
  ㄴ 여러가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관게를 표현하는 시스템의 구조나 구조체이다.

532. UI 설계원칙: 직유학유
  ㄴ 직관성(Intutiveness): 누구나 쉽게 이해하고, 쉽게 사용할 수 있어야 함
  ㄴ 유효성(Efficiency): 정확하고 완벽하게 사용자의 목표가 달성될 수 있도록 제작
  ㄴ 학습성(Learnability): 초보와 숙련자 모두가 쉽게 배우고 사용할 수 있게 제작
  ㄴ 유연성(Flexibility): 사용자의 인터랙션을 최대한 포용하고, 실수를 방지할 수 있도록 제작

533. UML 개념
  ㄴ 객체지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화 할 떄 사용되는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어

534. UML 특징: 가구명문
  ㄴ 가시화 언어: 개념 모델 작성 시 오류가 적고 의사소통이 용이
  ㄴ 구축 언어: 다양한 프로그래밍 언어로 실행 시스템의 예측 가능
  ㄴ 명세화 언어: 정확한 모델 제시, 완전한 모델 작성 가능
  ㄴ 문서화 언어: 시스템에 대한 평가 및 의사소통의 문서

535. UML 구성요소: 사관다
  ㄴ 사물: 추상적인 개념으로 주제를 나타내는 요소
  ㄴ 관계: 사물의 의미를 확장하고 명확히 하는 요소, 사물과 사물을 연결하여 관계 표현
  ㄴ 다이어그램: 사물과 관계를 모아 그림으로 표현한 형태

536. 구조적/정적 다이어그램: 클객컴배복패
  ㄴ 클래스: 객체지향 모델링 시 클래스의 속성 및 연산과 클래스 간 정적인 관계를 표현한 다이어그램
  ㄴ 객체: 클래스에 속한 사물들, 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현한 다이어그램
  ㄴ 컴포넌트: 시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존 관계를 나타내는 다이어그램
  ㄴ 배치: 컴포넌트 사이의 종속성을 표현하고, 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현하는 다이어그램
  ㄴ 복합체구조: 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현하는 다이어그램
  ㄴ 패키지: 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현한 다이어그램

537. 행위적/동적 다이어그램: 유시커 상활타
  ㄴ 유스케이스: 시스템이 제공하고 있는 기능 및 그와 관련된 외부 요소를 사용자의 관점에서 표현하는 다이어그램
  ㄴ 시퀀스: 객체 간 동적 상호작용을 시간적 개념을 중심으로 메시지 흐름으로 표현한 다이어그램
  ㄴ 커뮤니케이션: 동작에 참여하는 객체들이 주고 받는 메시지를 표현하고, 메시지 뿐만 아니라 객체 간의 연관 까지 표현하는 다이어그램
  ㄴ 상태: 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호작용에 따라 상태가 어떻게 변화하는지 표현하는 다이어그램
  ㄴ 활동: 시스템의 어떤 기능을 수행하는지를 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서대로 표현하는 다이어그램
  ㄴ 타이밍: 객체 상태 변화와 시간 제약을 명시적으로 표현하는 다이어그램

538. UML 확장 모델의 스테레오 타입
  ㄴ UML의 스테레오 타입은 UML의 기본적 요소 이외의 새로운 요소를 만들어내기 위한 확장 메커니즘, <<>> 길러멧; Guillemet 기호를 사용하여 표현한다.

539. 클래스 다이어그램
  ㄴ 객체지향 모델링 시 클래스의 속성 및 연산과 클래스 간 정적인 관계를 표현한 다이어그램

540. 클래스 다이어그램 구성요소: 클속연접
  ㄴ 클래스: 공통의 속성, 연산, 관계, 의미를 공유하는 객체들의 집합
  ㄴ 속성: 클래스의 구조적 특성에 이름을 붙인 것으로 특성에 해당하는 인스턴스가 보유할 수 있는 값의 범위를 기술
  ㄴ 연산, 메서드: 이름, 타입, 매개변수들과 연관된 행위를 호출하는데 요구되는 제약사항들을 명시하는 클래스의 행위적 특징
  ㄴ 접근 제어자(접근 제한자): - 클래스 내부 접근만 허용, + 클래스 외부 접근 허용, # 동일 패키지/파생 클래스에서 접근 가능, ~ 동일 패키지 클래스에서 접근 가능

541. 클래스 간의 관계: 연집복 일의실
  ㄴ 연관 관계: 연관 관계는 클래스가 서로 개념적으로 연결된 선, 2개 이상의 사물이 서로 관련되어 있는 상태를 표현, 실선으로 연결
  ㄴ 집합 관계: 하나의 객체에 여러 개의 독립적인 객체들이 구성되는 관계, 하나의 사물이 다른 사물에 포함되어 있는 관계, Part에서 Whole으로 속이 빈 마름모 연결
  ㄴ 복합 관계: 영구적이고, 집합관계보다 더 강한 관계로 구성, Part에서 Whole으로 속이 찬 마름모, 집합 관계의 특수한 형태로, 포함관계라고도 함
  ㄴ 일반화 관계: 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지 표현, 일반적인 개념을 부모라고 하고, 구체적인 개념을 자식이라 함, 속이 빈 화살표를 연결, 상속관계라고도 함
  ㄴ 의존 관계: 하나의 클래스가 또 다른 클래스를 사용하는 관계, 다른 클래스의 멤버 함수 사용, 사물 사이에서 서로 연관은 있으나 필요에 따라 서ㅗ에게 영향을 주는 짧은 시간만 연관을 유지하는 관계를 표현, 점선 화살표 연결
  ㄴ 실체화 관계: 추상 클래스나 인터페이스를 상속 받아 자식 클래스가 추상 메서드를 구현할 떄 사용, 사물이 할 수 있거나, 해야하는 기능으로 서로를 그룹화 할 수 있는 관계를 표현

542. 유스케이스 다이어그램
  ㄴ 시스템이 제공하고 있는 기능 및 그와 관련된 외부 요소를 사용자의 관점에서 표현하는 다이어그램

543. 구성요소: 유액시시이
  ㄴ 유스케이스: 시스템이 제공해야하는 서비스, 기능, 액터가 시스템을 통해 수행하는 일련의 행위
  ㄴ 액터: 시스템과 상호작용하는 사람 또는 사물
  ㄴ 시스템: 전체 시스템의 영역을 표현
  ㄴ 시나리오: 발생되는 이벤트의 흐름
  ㄴ 이벤트의 흐름: 사람, 시스템, 하드웨어, 시간의 흐름에 의해 시작

544. 유스케이스 다이어그램 관계: 포확일
  ㄴ 포함: 유스케이스를 수행할 때 다른 유스케이스가 반드시 수행되는 관계, <<include>>로 표현,
  ㄴ 확장: 특정 조건에서 한 유스케이스로만 확장 되는 과계, <<extend>>로 표현
  ㄴ 일반화: 추상적인 액터와 좀 더 구체적인 액터 사이에 맺어주는 관계, 속이 빈 삼각형 화살표를 연결

545. 시퀀스 다이어그램
  ㄴ 객체 간 상호작용을 메시지 흐름으로 표현한 다이어그램
  ㄴ 객체 간 동적 상호작용을 시간적 개념을 중심으로 모델링하는 과정

546. 시퀀스 다이어그램 구성요소: 객생실메
  ㄴ 객체: 객체는 위쪽에 표시되며 아래로 생명선을 가짐
  ㄴ 생명선: 객체로부터 뻗어 나가는 점선, 실제 시간이 흐름에 따라 객체의 생명주기 동안 발생하는 이벤트 명시
  ㄴ 실행: 직사각형은 오퍼레이션이 실행되는 시간을 의미
  ㄴ 메시지: 객체 간 상호작용은 메시지 교환으로 이루어짐

547. 패키지 다이어그램 개념
  ㄴ 시스템의 서로 다른 패키지들 사이 의존 관계를 표현하기 위한 다이어그램

548. 패키지 다이어그램 구성요소: 패의
  ㄴ 패키지: 요소들을 그룹으로 조직하기 위한 요소
  ㄴ 의존관계: 하나의 패키지가 다른 패키지를 사용하는 관계

549. 활동 다이어그램
  ㄴ 시스템이 어떤 기능을 수행하는지를 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서대로 표현하는 다이어그램
  ㄴ 오퍼레이션이나 처리과정이 수행되는 동안 일어나는 일들을 단계적으로 표현한다.

550. 활동 다이어그램 구성요소
  ㄴ 시작점
  ㄴ 전이
  ㄴ 액션/액티비티
  ㄴ 종료점
  ㄴ 조건노드
  ㄴ 병합노드
  ㄴ 포크노드
  ㄴ 조인노드
  ㄴ 구획면

551. 상태 다이어그램
  ㄴ 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호작용에 따라 상태가 어떻게 변화하는지 표현하는 다이어그램
  ㄴ 어떤 이벤트에 의해 객체 자신이 속한 클래스의 상태 변화나 객체 간 상호작용하는 과정에서의 상태 변화를 표현한다.

552. 상태 다이어그램 구성요소
  ㄴ 상태
  ㄴ 시작 상태
  ㄴ 종료 상태
  ㄴ 전이
  ㄴ 이벤트
  ㄴ 전이 조건

553. 커뮤니케이션 다이어그램
  ㄴ 시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하고, 메시지 뿐만 아니라 객체 간의 연관까지 표현하는 다이어그램

554. 커뮤니케이션 다이어그램 구성요소: 액객링메
  ㄴ 액터: 시스템으로부터 서비스를 요청하는 외부 요소
  ㄴ 객체: 메시지를 주고 받은 주체
  ㄴ 링크: 객체들 간의 관계를 표현
  ㄴ 메시지: 객체가 상호작용을 위해 주고받는 메시지

555. 컴포넌트 다이어그램
  ㄴ 시스템을 구성하는 물리적인 컴로넌트와 그들 사이의 의존 관계를 나타내는 다이어그램
  ㄴ 컴포넌트 기반의 물리적 구조로 표현

556. 컴포넌트 다이어그램 구성요소
  ㄴ 컴포넌트
  ㄴ 인터페이스
  ㄴ 의존 관계

557. 데이터 모델 절차: 개논물
  ㄴ 개념적 데이터 모델: 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 데이터모델, 주요 산출물로는 개체관계 다이어그램
  ㄴ 논리적 데이터 모델: 업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현한 데이터 모델, 목표 DBMS에 맞는 스키마 선례, 트랜잭션 인터페이스를 설계, 논리적 데이터 모델링에서 정규화를 수행, 스키마의 평가 및 정제
  ㄴ 물리적 데이터 모델: 논리 데이터 모델을 특정 DBMS의 특성 및 성능을 고려하여 물리적인 스키마를 만드는 일련의 데이터 모델, 테이블, 인덱스, 뷰, 파티션 등 객체를 생성, 응답시간, 저장 공간의 효율화, 트랜잭션 처리를 고려하여 설계, 성능 측면에서 반 정규화를 수행, 레코드 집중의 분석 및 설계, 저장 레코드 양식 설계, 접근 경로 설계

558. 정규화 단계: 원부이 결다조
  ㄴ 1NF: 원자값으로 구성
  ㄴ 2NF: 부분 함수 종속 제거
  ㄴ 3NF: 이행 함수 종속 제거
  ㄴ BCNF: 결정자 후보 키가 아닌 함수 종속 제거
  ㄴ 4NF: 다치 종속 제거
  ㄴ 5NF: 조인 종속 제거

559. 데이터 마이닝 개념
  ㄴ 대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 기술
  ㄴ 의미있는 패턴을 파악하거나 예측

560. EAI 개념(Enterprise Application Integration)
  ㄴ 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 간의 정보를 전달, 연계, 통합이 가능하도록 해주는 솔루션
  ㄴ 각 비즈니스 간 통합 및 연계성을 증대시켜 효율성을 높여 줄 수 있으며 각 시스템 간의 확장성을 높여 줄 수 있다.

561. EAI 구축 유형: 포허메하
  ㄴ 포인트 투 포인트: 가장 기초적인 애플리케이션 통합 방법으로 1:1 단순 통합
  ㄴ 허브 앤 스포크: 단일한 접점의 허브 시스템을 통하여 데이터를 전송하는 중앙 집중식 방식
  ㄴ 메시지 버스: 애플리케이션 사이 미들웨어를 두어 연계하는 미들웨어 통합 방식
  ㄴ 하이브리드: 그룹 내는 허브 앤 스포크, 그룹 간에는 메시지 버스

562. ESB(Enterprise Service Bus)
  ㄴ 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간을 하나의 시스템으로 관리 운영할 수 있도록 서비스 중심으로 통합을 지향하는 아키텍처
  ㄴ 느슨한 결합: 서비스를 변경하더라도 연결된 다른 서비스에는 영향을 주지 않는 유연한 구조

563. 웹 서비스 개념
  ㄴ 네트워크에 분산된 정보를 서비스 형태로 개방하여 표준화된 방식으로 공유하는 기술로써 서비스 지향 아키텍처 개념을 실현하는 대표적인 기술 

564. 웹 서비스 유형: SUW
  ㄴ SOAP(Simple Object Access Protocol): HTTP, HTTPS, SMTP 등을 사용하여 XML 기반의 메시지를 네트워크 상태에서 교환하는 프로토콜, 기본적인 송수신은 HTTP로 한다. 보통의 경우 원격 프로시저 호출을 하는 메시지 패턴을 사용한다. 
  ㄴ WSDL(Web Service Description Language): 웹 서비스 명, 제공 위치, 메시지 포맷, 프로토콜 정보 등 웹 서비스에 대한 상세 정보가 기술된 XML 형식으로 구현되어 있는 언어이다.
  ㄴ UDDI(Universal Description, Discovery and Integration): UDDI는 웹 서비스에 대한 정보인 WSDL을 등록하고 검색하기 위한 저장소로 공개적으로 접근, 검색이 가능한 레지스트리이자 표준이다.

565. XML(eXtensible Markup Language): W3C에서 개발되었고, 웹 브라우저 간 호환이 되지 않는 문제와 SGML의 복잡함을 해결하기 위해 개발된 다목적 마크업 언어

566. JSON(Javascript Object Notation): 속성-값(Attribute-Value Pair)으로 이루어진 데이터 오브젝트를 전달하기 위해 사용하는 개방형 표준 포맷, AJAX에서 많이 사용 되고 XML을 대체하는 주요 데이터 포맷이다. 언어 독립형 데이터 포맷으로 다양한 데이터 프로그래밍 언어에서 사용하고 있는 기술

567. AJAX(Asynchronous JavaScript and XML): 브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 고치지 않고도 페이지의 일부분만을 위한 데이터를 로드하는 기법이며, 하이퍼 텍스트 표기 언어 만으로 어려운 작업을 웹 페이지에서 구현해 이용자가 웹 페이지와 자유롭게 상호 작용 할 수 있도록 하는 기술

568. 인터페이스 구현 검증 도구 종류: 엑스피 엔셀웨
  ㄴ xUnit: 자바, C++, .Net 등 다양한 언어를 지원하는 단위테스트 프레임워크, 소프트웨어의 함수나 클래스 같은 서로 다른 구성 원소를 테스트할 수 있게 해주는 도구
  ㄴ STAF: 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크, 각 테스트 대상 분산 환경에 데몬을 사용하여 테스트 대상 프로그램을 통해 테스트를 수행하고, 통합하며 자동화하는 검증 도구
  ㄴ FitNesse: 웹 기반 테스트 케이스 설계/실행/결과 확인 등을 지원하는 테스트 프레임워크, 사용자가 테스트 케이스 테이블을 작성하면 빠르고 편하게 자동으로 원하는 값에 대해 테스트할 수 있는 장점이 있음
  ㄴ NTAF: FitNesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN의 테스트 자동화 프레임워크
  ㄴ Selenium: 다양한 브라우저 지원 및 개발언어를 지원하는 웹 애플리케이션 테스트 프레임워크, 테스트 스크립트 언어를 학습할 필요 없이 기능 테스트를 만들기 위한 도구를 제공
  ㄴ water: 루비 기반 웹 애플리케이션 테스트 프레임워크, 모든 언어 기반의 웹 애플리케이션 테스트와 브라우저 호환성 테스팅 가능

569. 식별자 표기법: input function을 각 표기법에 맞게 변수이름으로 지정했을 때
  ㄴ 카멜 표기법: inputFunction 첫단어만 소문자, 다른 단어의 첫 글자는 대문자
  ㄴ 파스칼 표기법: InputFunction 각 단어의 첫 글자는 대문자
  ㄴ 스네이크 표기법: input_function 각 단어 사이에 언더바
  ㄴ 헝가리안 표기법: nInputFunction 표기 시 자료형을 두어에 붙임, int는 n, char은 c, 문자열은 sz

570. 트랜잭션의 특성: ACID(원일격지)
  ㄴ Atomicity(원자성): 분해가 불가능한 작업의 최소 단위, 연산 전체가 성공 또는 실패. 하나라도 실패할 경우 전체가 취소되어야 하는 특성
  ㄴ Consistency(일관성): 트랜잭션이 실행 성공 후 항상 일관된 데이터베이스 상태를 보존해야하는 특성
  ㄴ Isolation(격리성): 트랜잭션 실행 중 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근 불가한 특성
  ㄴ Durability(지속성): 성공이 완료된 트랜잭션의 결과는 영속적으로 데이터베이스에 저장하는 특성

571. 트랜잭션의 롤백
  ㄴ 오류가 발생했을 때, 오류 발생 이전의 특정 시점(Save Point, Check Point)으로 되돌아가는 제어어

572. 병행 제어 기법의 종류: 로 낙타다
  ㄴ 로킹: 같은 자원을 액세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보장하는 직렬화 기법, 데이터 베이스, 파일, 레코드 등은 로킹 단위가 될 수 있음. 로킹 단위가 작어지면 데이터베이스 공유도가 증가, 로킹 오버헤드 증가, 한꺼번에 로킹할 수 있는 객체의 크기를 로킹 단위라고 함
  ㄴ 낙관적 검증: 트랜잭션이 어떠한 검증도 수행하지 않고 일단 트랜잭션을 수행하고, 트랜잭션 종료 시 검증을 수행하여 데이터베이스에 반영하는 기법
  ㄴ 타임 스탬프 순서: 트랜잭션과 트랜잭션이 읽거나 갱신한 뎅터에 대해 트랜잭션이 실행을 시작하기 전에 타임 스탬프를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법
  ㄴ 다중버전 동시성 제어: 트랜잭션의 타임스탬프와 접근하려는 데이터의 타임스탬프를 비교하여 직렬 가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법

573. 회복기법 종류: 회로체크
  ㄴ 로그 기반 회복 기법(지연 갱신 회복 기법): 트랜잭션이 완료되기 전까지 데이터베이스에 기록하지 않는 기법
  ㄴ 로그 기반 회복 기법(즉각 갱신 회복 기법): 트랜잭션 수행 중 갱신 결과를 바로 DB에 반영하는 기법
  ㄴ 체크포인트 회복 기법: 장애 발생 시 검사점 이후에 처리된 트랜잭션에 대해서만 장애 발생 이전의 상태로 복원시키는 회복 기법
  ㄴ 그림자 페이징 회복 기법: 데이터베이스 트랜잭션 수행 시 복제본을 생성하여 데이터베이스 장애 시 이를 이용해 복구하는 방법

574. DDL 대상: 도스뷰테인
  ㄴ 도메인: 하나의 속성이 가질 수 있는 원자값들의 집합, 속성의 데이터 타입과 크기, 제약조건 등의 정보
  ㄴ 스키마: 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조, 외부/개념/내부 3계층 외논뷰개논전내물
    ㄴ 외부: 사용자나 개발자의 관점에서 필요로 하는 데이터베이스의 논리적 구조, 사용자 뷰를 나타냄, 서브 스키마라고도 함
    ㄴ 개념: 데이터베이스의 전체적인 논리 구조, 전체적인 뷰를 나타냄, 개체 간의 관계, 제약조건, 접근 권한, 무결성, 보안에 대해 정의
    ㄴ 내부: 물리적 저장장치의 관점에서 보는 데이터베이스 구조, 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 표현
  ㄴ 뷰: 하나 이상의 물리 테이블에서 유도되는 가상의 테이블
  ㄴ 테이블: 데이터 저장 공간
  ㄴ 인덱스: 검색을 빠르게 하기 위한 데이터 구조

575. 카튜애차
  ㄴ 카디널리티 = 튜플의 수, 차수 = 애트리뷰트의 수

576. 형상관리(Configuration Management) 개념
  ㄴ 소프트웨어 개발을 위한 전체 과정에서 발생하는 모든 항목의 변경 사항을 관리하기 위한 활동, SW 생명 주기 동안 형상 관리를 통해 산출물을 체계적으로 관리하여 SW의 가시성, 추적성, 무결성 등의 품질 보증을 보장할 수 있다.

577. 형상 관리 목적
  ㄴ 프로젝트 생명주기 동안 제품의 무결성과 변경에 대한 추적성을 확보할 수 있다.
  ㄴ 프로젝트 변경이 발생되었을 때 처리하는 메커니즘을 제공한다.
  ㄴ 형상 관리대상 파악, 베이스라인 지정, 형상 관리, 접근 제어 등이 있다.

578. 형상 관리 절차: 식통감기
  ㄴ 형상 식별: 형상 관리 대상을 정의 및 식별하는 활동, 추적성 부여를 위해 ID와 관리번호 부여
  ㄴ 형상 통제: 형상 항목의 버전 관리를 위한 형상통제위원회 운영, 변경요구 관리, 변경제어, 형상 관리 등 통제 지원, 베이스라인에 대한 관리 및 형상 통제 수행 기능
    ㄴ 형상통제위원회: 형상 관리에 대한 주요 방침을 정하고 산출물을 검토하며, 단계별 의사결정을 수행하는 조직이다.
  ㄴ 형상 감사: 소프트웨어 베이스라인의 무결성 평가, 베이스라인 변경 시 요구사항과 일치 여부 검토
  ㄴ 형상 기록: 소프트웨어 형상 및 변경관리에 대한 각종 수행결과를 기록, 형상결과 보고서 작성

579. 모듈 개념
  ㄴ 모듈은 그 자체로 하나의 완전한 기능을 수행할 수 있는 독립된 실체이다.
  ㄴ 모듈화를 통해 분리된 시스템의 각 기능들로 서브프로그램, 서브 루틴, 소프트웨어 내의 단위 프로그램, 작업 단위 등과 같은 의미로 사용된다.

580. 모듈의 특징
  ㄴ 각각의 모듈은 상대적으로 독립성을 가지고 있다.
  ㄴ 모듈 내부에는 그 모듈을 하나로 통합하는 수 많은 조합이 존재할 수 있다.
  ㄴ 모듈은 단독으로 컴파일할 수 있으며, 재사용 할 수 있다. 
  ㄴ 독립성이 높은 모듈일 수록 수정 시에도 다른 모듈에 영향을 거의 미치지 않고, 오류도 쉽게 해결할 수 있다.
  ㄴ 모듈의 독립성은 결합도와 응집도에 의해 측정, 결합도는 낮게, 응집도는 높게

581. 모듈화 개념
  ㄴ 모듈화는 소프트웨어의 성능을 향상시키거나 복잡한 시스템의 수정, 재사용, 유지 관리  등이 용이하도록 기능 단위의 모듈로 분해하는 설계 및 구현 기법이다.
 
582. 모듈화 기법
  ㄴ 루틴: 소프트웨어에서 특정 동작을 수행하는 일련의 코드로 기능을 가진 명령들의 모임
  ㄴ 메인 루틴: 프로그램의 주요한 부분이며, 전체의 개략적인 동작 절차를 표시하도록 만들어진 루틴
  ㄴ 서브 루틴: 메인 루틴에 의해 필요할 때마다 호출되는 루틴

583. 응집도(Cohesion) 개념
  ㄴ 모듈의 독립성을 나타내는 정도로, 모듈 내부 구성요소 간 연관 정도
  ㄴ 하나의 모듈이 하나의 기능을 수행할 수록 응집도가 높다.

584. 우논시절 통 순기
  ㄴ 우연적(Coincidention): 모듈 내부의 각 구성요소가 연관이 없을 경우의 응집도
  ㄴ 논리적(Logical): 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우의 응집도
  ㄴ 시간적(Temporal): 연관된 기능이라기보다는 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우의 응집도
  ㄴ 절차적(Procedural): 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우의 응집도
  ㄴ 통신적(Communication): 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우의 응집도
  ㄴ 순차적(Sequential): 모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용될 경우의 응집도
  ㄴ 기능적(Functional): 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우의 응집도

585. 결합도 개념
  ㄴ 모듈 내부가 아닌 외부의 모듈과의 연관도 또는 모듈 간의 상호의존성이다.
  ㄴ 소프트웨어 구조에서 모듈 간의 관련성을 측정하는 척도

586. 내공외제스자
  ㄴ 내용(Content): 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도
  ㄴ 공통(Common): 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고, 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도
  ㄴ 외부(External): 두 개의 모듈이 외부에서 도입된 데이터 포맷, 통신 프로토콜, 또는 디바이스 인터페이스를 공유할 경우의 결합도
  ㄴ 제어(Control): 단순 처리할 대상인 값만 전달하는게 아니라 어떻게 처리를 해야 한다는 제어요소가 전달 될 경우의 결합도
  ㄴ 스탬프(Stamp): 모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우의 결합도
  ㄴ 자료(Data): 모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 모듈 간의 상호 작용이 일어나는 경우의 결합도


587. MVC 패턴
  ㄴ 모듈: 애플리케이션이 무엇을 할 것인지 정의, 내부 비즈니스 로직을 처리하기 위한 역할
  ㄴ 뷰: 화면에 무엇인가를 보여주기 위한 역할
  ㄴ 컨트롤러: 모델이 어떻게 처리할 지를 알려주는 역할, 부에 명령을 보내어 화면 요청 결과를 전달

588. Land Attack
  ㄴ 공격자가 패킷의 출발지 주소나 포트를 임의로 변경해서 출발지와 목적지 주소를 동일하게 함으로써 공격 대상 컴퓨터의 실행 속도를 느리게 하거나 동작을 마비시켜 서비스 거부 상태에 빠지도록 하는 공격 방법

589. MD5
  ㄴ RFC 1321로 지정되어 있으며, 주로 프로그램이나 파일이 원본 그대로인지를 확인하는 무결성 검사 등에 사용된다. 1991년 로널드 라이베스트가 예전에 쓰이던 MD4를 대체하기 위해 고안된 128비트 암호화 해시 함수

590. 스니핑
  ㄴ 공격대상에게 직접 공격하지 않고 데이터만 몰래 들여다보는 수동적 공격 기법

591. IPSec
  ㄴ 무결성과 인증을 보장하는 인증헤더와 기밀성을 보장하는 암호화를 이용한 프로토콜로 네트워크계층인 인터넷 프로토콜에서 보안성을 제공해주는 표준화된 기술

592. SQL Injection 
  ㄴ 데이터베이스에 접근하는 특정 개체의 보안 취약점을 이용해서 공격자가 임의로 SQL 구문을 삽입, 실행시켜서 데이터베이스 내 데이터를 탈취하는거나 조작하는 방법

593. 정보보안의 기무가
  ㄴ 기밀성: 인가되지 않은 개인 혹은 시스템 접근에 따른 정보 공개 및 노출을 차단하는 특성
  ㄴ 무결성: 정당한 방법을 따르지 않고선 데이터가 변경 될 수 없으며, 데이터의 정확성 및 완전성과 고의, 악의로 변경되거나 훼손 또는 파괴되지 않음을 보장하는 특성
  ㄴ 가용성: 권한을 가진 사용자나 애플리케이션이 원하는 서비스를 지속 사용할 수 있도록 보장하는 특성

594. SW 개발 보안 용어
  ㄴ 자산: 조직의 데이터 또는 조직의 소유자가 가치를 부여한 대상
  ㄴ 위협:조직이나 기업의 자산에 악영향을 끼칠 수 있는 사건이나 행위
  ㄴ 취약점: 위협이 발생하기 전 사전 조건으로 시스템의 정보 보증을 낮추는 데 사용되는 약점
  ㄴ 위험: 위협이 취약점을 이용하여 조직의 자산 손실 피해를 가져올 가능성

595. DoS(Denial ofr Service) 공격
  ㄴ 시스템을 악의적으로 공격해서 해상 시스템의 자원을 부족하게 하여 원래 의도된 용도로 사용되지 못하게 하는 공격
  ㄴ 특정 서버에 수많은 접속 시도를 만들어 다른 이용자가 정상적으로 서비스를 이용하지 못하게 하거나, 서버의 TCP 연결을 소진시키는 등의 공격이다.

596. SYN 플러딩
  ㄴ TCP 프로토콜의 구조적인 문제를 이용한 공격
  ㄴ 서버의 동시 가용 사용자 수를 SYN 패킷만 보내 점유하여 다른 사용자가 서버를 사용 불가능하게 하는 공격
  ㄴ 공격자는 ACK를 발송하지 않고 계속 새로운 연결 요청을 하게 되어 서버는 자원할당을 해지하지 않고 자원만 소비하여 고갈됨

597. UDP 플러딩
  ㄴ 대량의 UDP 패킷을 만들어 임의의 포트 번호로 전송하여 응답 메시지(ICMP)를 생성하게 하여 지속해서 자원을 고갈시키는 공격
  ㄴ ICMP 패킷은 변조되어 공격자에게 전달되지 않아 대기함

598. 스머프, 스머핑
  ㄴ 출발지 주소를 공격 대상의 IP로 설정하여 네트워크 전체에게 ICMP Echo 패킷을 직접 브로드캐스팅하여 마비시키는 공격, 
  ㄴ 바운스 사이트라고 불리는 제 3의 사이트를 이용해 공격

599. 죽음의 핑(PoD)
  ㄴ ICMP 패킷(Ping)을 정상적인 크기보다 아주 크게 만들어 전송하면 다수의 IP 파편화가 발생하고, 수신 측에서는 단편화된 패킷을 처리하는 과정에서 많은 부하가 발생하거나, 재조합 버퍼의 오버플로우가 발생하여 정상적인 서비스를 하지 못하도록 하는 공격기법

600. 랜드 어택(Land Attack)
  ㄴ 출발지 IP와 목적지 IP를 같은 패킷 주소로 만들어 보냄으로써 수신자가 자기 자신에게 응답을 보내게 하여 시스템의 가용성을 침해하는 공격기법

601. 티어 드롭
  ㄴ IP 패킷의 재조합 과정에서 잘못된 Fragment Offset 정보로 인해 수신시스템이 문제를 발생하도록 만드는 DoS공격
  ㄴ IP 헤더가 조작된 일련의 IP 패킷 조각들을 전송, 이를 수신한 시스템이 재조합하는 과정에서 오류가 발생, 시스템의 기능을 마비시키는 공격방식

602. 봉크, 보잉크
  ㄴ 프로토콜의 오류 제어를 이용한 공격기법으로서 시스템의 패킷 재전송과 재조립이 과부하를 유발

603. DDOS(Distributed DoS) 개념 
  ㄴ DoS의 또 다른 형태로 여러대의 공격자를 분산 배치하여 동시에 동작하게 함으로써 특정 사이트를 공격하는 기법
  ㄴ 해커들이 취약한 인터넷 시트메에 대한 액세스가 이뤄지면, 침입한 시스템에 소프트웨어를 설치하고 이를 실행시켜 원격에서 공격을 개시한다.

604. DDoS 공격 구성요소: HAMAD
  ㄴ Handler: 마스터 시스템의 역할을 수행하는 프로그램
  ㄴ Agent: 공격 대상에 직접 공격을 가하는 시스템
  ㄴ Master: 공격자에게서 직접 명령을 받는 시스템, 여러 대의 에이전트를 관리
  ㄴ Attacker: 공격을 주도하는 해커의 컴퓨터
  ㄴ Daemon: 에이전트 시스템의 역할을 수행하는 프로그램

605. DRDoS(Distributed Reflection DoS) 개념
  ㄴ 공격자는 출발지 IP를 공격 대상 IP로 위조하여 다수의 반사 서버로 요청 정보를 전송, 공격 대상자는 반사 서버로부터 다량의 응답을 받아서 서비스 거부가 되는 공격

606. 애플리케이션 공격
  ㄴ HTTP Get Flooding: Cache Control Attack 공격, 과도한 get 메시지 이용하여 웹 서버의 과부하를 유발시키는 공격, HTTP 캐시 옵션을 조작하여 캐싱 서버가 아닌 웹 서버가 직접 처리하도록 유도, 웹 서버 자원을 소진시키는 서비스 거부 공격
  ㄴ Slowloris: HTTP GET 메서드를 사용하여 헤더의 최종 끝을 알리는 개행 문자열을 전송하지 않고, 일부만 전송하여 대상 웹서버와 연결상태를 장시간 지속시키고 연결 자원을 모두 소진시키는 서비스 거부 공격
  ㄴ RUDY: 요청 헤더의 Content-Lenth를 비 정상적으로 크게 설정하여 메시지 바디 부분을 매우 소량으로 보내 계속 연결상태를 유지시키는 공격
  ㄴ Slow HTTP Read DoS: TCP 윈도 크기와 데이터 처리율을 감소시킨 상태에서 다수 HTTP 패킷을 지속적으로 전송하여 대상 웹 서버의 연결상태가 장시간 지속, 연결 자원을 소진시키는 서비스 거부 공격
  ㄴ Hulk DoS: 공격자가 공격대상 웹 사이트 웹 페이지 주소를 지속적으로 변경하면서 다량으로 GET 요청을 발생시키는 서비스 거부 공격, 주소를 지속적으로 변경시키는 이유는 임계치 기반의 디도스 대응 장비를 우회하기 위한 방법
  ㄴ Hash DoS: 웹 서버는 클라이언트 HTTP 요청을 통해 전달되는 파라미터를 효율적으로 저장하고 검색하기 위한 자료구조로 해시테이블을 주로 사용, 공격자는 이러한 특성을 악용하여 조작된 수 많은 파라미터를 POST 방식으로 웹 서버로 전달하여 다수의 해시 충돌을 발생시켜 자원을 소모시키는 서비스 거부 공격

607.  네트워크 공격
  ㄴ 스니핑: 공격대상에게 직접 공격을 가하지 않고 데이터만 몰래 들여다보는 수동적 공격
  ㄴ 네트워크 스캐너, 스니퍼: 네트워크 하드웨어 및 소프트웨어 구성의 취약점 파악을 위해 공격자가 취약 점을 탐색하는 공격 도구
  ㄴ 패스워드 크래킹
  ㄴ IP 스푸핑: 침입자가 인증된 컴퓨터 시스템인 것처럼 속여서 타깃 시스템의 정보를 빼내기 위해서 본인의 패킷 헤더를 인증된 호스트의 IP 어드레스로 위조하여 타깃에 전송하는 공격기법
  ㄴ ARP 스푸핑: ARP 스푸핑은 공격자가 특정 호스트의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Reply를 만들어 희생자에게 지속적으로 전송하여 희생자의 ARP Cache Table에 특정 호스트의 MAC 정보를 공격자의 MAC 정보로 변경, 희생자로부터 특정 호스트로 나가는 패킷을 공격자가 스니핑하는 공격기법
  ㄴ ICMP Redirect 공격: 3계층에서 스니핑 시스템을 네트워크에 존재하는 또 다른 라우터라고 알림으로써 패킷의 흐름을 바꾸는 공격기법
  ㄴ 트로이목마: 악성 루틴이 숨어 있는 프로그램으로 겉보기에는 정상적인 프로그램으로 보이지만 실행하면 악성 코드를 실행하는 프로그램

608. 버퍼 오버플로우 공격
  ㄴ 메모리에 할당된 버퍼 크기를 초과하는 양의 데이터를 입력하여 이로 인해 프로세스 흐름을 변경시켜서 악성 코드를 실행시키는 공격기법

609. 버퍼 오버플로우 공격 유형
  ㄴ 스택 버퍼 오버플로우: 메모리 영역 중 Local Value나 함수의 Return Address가 저장되는 스택영역에서 발생하는 오버플로우 공격, 스택 영역에 할당된 버퍼 크기를 초과하는 양의 데이터를 입력하여 복귀 주소를 변경하고 공격자가 원하는 임의의 코드를 실행하는 공격 기법
  ㄴ 힙 버퍼 오버플로우: 동적으로 할당하는 힙 영역에 할당된 버퍼 크기를 초과하는 데이터를 입력하여 메모리의 데이터와 함수 주소 등을 변경, 공격자가 원하는 임의의 코드를 실행하는 공격기법

610. 버퍼 오버플로우 공격 대응 방안
  ㄴ 스택가드: 카나리라고 불리는 무결성 체크용 값을 복귀 주소와 변수 사이에 삽입해두고, 버퍼 오버플로우 발생 시 카나리 값을 체크, 변할 경우 복귀 주소를 호출하지 않는 방식으로 대응
  ㄴ 스택쉴드: 함수 시작시 복귀 주소를 Global RET라는 특수 스택에 저장해 두고, 함수 종료 시 저장된 값과 스택의 RET값을 비교해서 다를 경우 오버플로우로 간주하고 프로그램 실행을 중단
  ㄴ ASLR(Address Space Layout Randomiztion): 메모리 공격을 방어하기 위해 주소 공간 배치를 난수화하고, 실행 시 마다 메모리 주소를 변경시켜 버퍼 오버플로우를 통한 특정 주소 호출을 차단, 리눅스에서 설정 가능
  ㄴ 안전한 함수 활용
  ㄴ 실행 제한: 스택에서의 쓰기 권한 제한

611. 백도어
  ㄴ 어떤 제품이나 컴퓨터 시스템, 암호 시스템 혹은 알고리즘에서 정상적인 인증 절차를 우회하는 기법
  ㄴ 허가받지 않고 시스템에 접속하는 권리를 얻기 때문에 은밀하게 작동

612. 시스템 보안 공격
  ㄴ 포맷 스트링 공격: 포맷 스트링을 인자로하는 함수의 취약점을 이용한 공격으로 외부로부터 입력된 값을 검증하지 않고 입출력 함수위 포맷 스트링을 그대로 사용하는 경우 발생 하는 취약점 공격 기법
  ㄴ 레이스 컨디션 공격: 둘 이상의 프로세스나 스레드가 공유자원을 동시에 접근할 때 접근 순서에 따라 비정상적인 결과가 발생하는 조건/상황, 실행되는 프로세스가 임시파일을 만드는 경우 악의 적인 프로그램을 통해 그 프로세스의 실행 중에 끼어들어 임시 파일을 심볼릭 링크하여 악의적인 행위를 수행하게 하는 공격기법
  ㄴ 키로거 공격: 컴퓨터 사용자의 키보드 움직임을 탐지해서 저장하고, ID나 패스워드, 계좌 번호, 카드 번호 등과 같은 개인의 중요한 정보를 몰래 빼가는 공격
  ㄴ 루트킷: 시스템 침입 후 침입 사실을 숨긴 채 차후의 침입을 위한 백도어, 트로이 목마 설치, 원격 접근, 내부 사용 흔적 삭제, 관리자 권한 획득 등 주로 불법적인 해킹에 사용되는 기능을 제공하는 프로그램의 모음
 
613. 보안 관련 용어
  ㄴ 스피어 피싱: 특정 대상 선정 후 그 대상에게 일반 이메일로 위장한 메일을 발송하여 링크나 첨부파일 클릭 유도, 개인정보 탈취
  ㄴ 스미싱: SMS와 피싱의 합성어, 신뢰할 수 있는 사람이나 기업으로 위장하여 개인 비밀정보를 요구하거나 소액 결제를 유도하는 공격
  ㄴ 큐싱: QR코드와 피싱의 합성어, 스마트폰을 이용하여 위장한 QR코드를 통해 악성 앱을 내려 받도록 유도, 금융 정보 등을 빼내는 사기
  ㄴ 봇넷: 악성 프로그램에 감염된 다수의 컴퓨터들이 네트워크로 연결된 형태
  ㄴ APT 공격: 특정 타깃을 목표로하여 다양한 수단을 통한 지속적이고 지능적인 맞춤형 공격기법, 특수 목적의 조직이 하나의 표적에 대해 다양한 IT 기술을 이용하여 지속적으로 정보 수집, 취약점 분석하여 피해를 주느 ㄴ기법
  ㄴ 공급망 공격: SW 개발사 네트워크 침투하여 소스 코드 수정 등을 통해 악의적인 코드 삽입하거나 파일 변경하여 사용자 PC에 SW설치 또는 업데이트 시에 자동적으로 감염되도록 하는 공격 기법
  ㄴ 제로데이 공격: 보안 취약점이 발견되어 널리 공표되기 전에 해당 취약점을 악용하여 이루어지는 보안 공격 기법, 
  ㄴ 웜: 스스로를 복제하여 네트워크 등의 연결을 통하여 전파하는 악성 소프트웨어 컴퓨터 프로그램, 웜은 독자적으로 실행되며 다른 실행프로그램이 필요하지 않음
  ㄴ 악성 봇: 스스로 실행되지 못하고, 해커의 명령에 이해 원격에서 제어 또는 실행이 가능한 프로그램 혹은 코드
  ㄴ 사이버 킬체인: 공격형 방위 시스템으로 사이버공격에 대해 7단계 프로세스별 공격분석 및 대응을 체계화한 APT 공격 방어 분석 모델
  ㄴ 랜섬웨어: 감염된 시스템 파일들을 암호화하여 인질로 잡고 몸값을 요구하는 악성 소프트웨어
  ㄴ 이블 트윈: 무선 Wifi 피싱 공격으로 합법적인 와이파이 제공자처럼 행세하며 노트북이나 휴대전화로 핫스팟에 연결한 사용자들의 정보를 탈취
  ㄴ 난독화: 코드의 가독성을 낮춰 역공학에 대한 대비를 하기 위해 프로그램 코드의 일부 또는 전체를 변경하는 기법
  ㄴ Tripwire: 크래커가 침입하여 시스템에 백도어를 만들어 놓거나 설정 파일을 변경 했을 때 이런 사실을 알 수 있게 분석하는 도구
  ㄴ Ping: 인터넷으로 접속하려는 원격 호스트가 정상적으로 운영되고 있는지를 확인하는 진단 목적으로 사용하는 명려엉
  ㄴ Tcpdump: 네트워크 인터페이스를 거치는 패킷의 내용을 출력해주는 프로그램, 스니핑 도구의 일종으로 자신의 컴퓨터로 들어오는 모든 패킷의 내용을 도청, 공격자에 대한 추적 시 활용

614. 서버 접근 통제 개념
  ㄴ 사람 또는 프로세스가 서버 내 파일에 읽기, 쓰기, 실행 등의 접근 여부를 허가하거나 거부하는 기능

615. 서버 접근 통제 목적
  ㄴ 비인가자로부터 객체의 기밀성, 무결성, 가용성을 보장한다.

616. 서버 접근 통제 유형
  ㄴ 임의적 접근 통제(DAC): 시스템에 대한 접근을 사용자/그룹의 신분 기반으로 제한하는 방법, DAC에서 사용자는 자원과 관련된 ACL이 수정됨으로써 자원에 대한 권한을 부여
  ㄴ 강제적 접근 통제(MAC): 시스템 저옵의 허용등급을 기준으로 사용자가 갖는 접근 허가 권한에 근거하여 시스템에 대한 접근을 제한하는 방법
  ㄴ 역할기반 접근 통제(RBAC): 중앙 관리자가 사용자와 시스템의 상호관계를 통제하여 조직 내 맡은 역할에 기초하여 자원에 대한 접근을 제한하는 방법

617. 벨-라파듈라
  ㄴ 기밀성 강조하여 강제적 정책에 의해 접근 통제
  ㄴ No Read Up, No Write Down

618. 비바 모델
  ㄴ 벨-라파둘라 모델의 단점을 보완한 무결성 보장하는 모델
  ㄴ No Read Down, No Write Up

619. 대칭 키 암호 방식
  ㄴ 암호화 알고리즘의 한 종류로, 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘, 블록 암호화와 스트림 암호화 알고리즘으로 나뉨

620. 비대칭 키 암호 방식
  ㄴ 사전에 개인 키를 나눠 가지지 않은 사용자들이 안전하게 통신하는 방식, 공개키로 암호화된 메시지는 반드시 비밀키로 복호화 해야한다.

621. 일방향 암호(해시) 방식
  ㄴ 임의 길이의 정보를 입력받아, 고정된 길이의 암호문(해시값)을 출력하는 암호 방식, 복호화가 불가능

622. 대칭 키 암호화 알고리즘 유형
  ㄴ DES(Data Encryption Standard): 1975년 미국 연방 표준국에서 발표한 대칭 키 기반의 블록 암호화 알고리즘, 블록 크기는 64bit, 키 길이는 56bit인 페이스텔 구조
  ㄴ SEED: 국내 한국인터넷 진흥원이 개발한 블록 암호화 알고리즘, 128비트 비밀키로부터 생성된 16개의 64비트 라운드키를 사용하여 16회의 라운드를 거쳐 128비트 평문을 128비트 암호문으로 암호화
  ㄴ AES(Advanced Encryption Standard): 2001년 미국 표준 기술 연구소에서 발표한 블록 암호화 알고리즘, 3DES의 성능문제 극복위해 개발, 블록 크기는 128비트이며, 키 길이에 따라 128, 192, 256 비트로 분류,
  ㄴ ARIA(Academy, Research Institute, Agency): 2004년 국가 정보원과 산학연구협회가 개발한 블록 암호화 알고리즘, 블록 크기는 128비트이며, 키 길이에 따라 128, 192, 256비트로 분류, 경량 환경 및 하드웨어에서의 효율성 향상을 위해 개발되었으며, 대부분의 연산은 XOR과 같은 단순한 바이트 단위연산
  ㄴ IDEA(International Data Encryption Algorithm): DES를 대체하기 위해 스위스 연방 기술 기관에서 개발, 128비트의 키를 사용하여 64비트 평문을 8라운드에 거쳐 64비트 암호문 만듦
  ㄴ LFSR(Linear Feedback Shift Resister): 선혁 되먹임 시프트 레지스터는 레지스터에 입력되는 값이 이전 상태들 값의 선형 함수로 계산되는 구조로 되어있는 스트림 암호화 알고리즘, 주로 XOR사용

623. 비대칭키 암호화 알고리즘
  ㄴ 디피-헬만: 최초의 공개키 알고리즘, 이산대수의 계산이 어려운 문제를 기본 원리로 함, 두 사용자 간에 공통의 암호화 키를 안전하게 공유할 방법을 제시하였으며, 많은 키분배 방식에 관한 연구의 기본이 됨
  ㄴ RSA: 3명의 MIT 수학교수가 고안한 인수의 곱을 소인수 분해하는 수학적 알고리즘 이용하는 공개키 암호화 알고리즘, 소인수 분해 문제의 어려움에 근거
  ㄴ ECC: RSA의 대안으로 처음 제안, 유한체 위에서 정의된 타원곡선 군에서의 이산대수 문제에 기초한 공개키 암호화 알고리즘, RSA의 문제점인 속도와 안전성 해결하기 위해 타원 기반 구조체의 안전성과 효율성을 기반으로 생성
  ㄴ ElGamal: 이산대수 계산이 어려운 문제를 기본 원리로 하고 있으며, RSA와 유사하게 전자서면과 데이터 암복호화에 함께 사용 가능

624. 해시 암호화 알고리즘
  ㄴ MD5(Message-Digest Algorithm 5): MD4를 개선한 암호화 알고리즘으로 프로그램이나 파일의 무결성 검사에 사용, 512비트짜리 입력 메시지 블록에 대해 차례로 동작하여 128비트의 해시값을 생성하는 해시 알고리즘
  ㄴ SHA-1(Secure Hash Algorithm): NSA에서 미 정부 표준으로 지정, DSA에서 사용, 160비트의 해시값을 생성하는 해시 알고리즘
  ㄴ SHA-256/384/512: SHA 알고리즘의 한 종류로서 256비트 해시값을 생성하는 해시 함수, AES의 키 길이인 128, 192, 256비트에 대응하도록 출력 길이를 늘인 해시 알고리즘
  ㄴ HAS-160: 국내 표준 서명 알고리즘을 위해 개발된 해시함수, MD5와 SHA1의 장점을 취하여 개발된 알고리즘

625. IPSec(Internet Protocol Security) 개념
  ㄴ IP계층에서 무결성과 인증을 보장하는 인증 헤더와 기밀성을 보장하는 암호화를 이용한 IP 보안 프로토콜
  ㄴ IPSec의 기능: 기무인재접
  ㄴ IPSec 동작모드: 전송모드, 터널모드
  ㄴ IPSec 프로토콜: 인증(AH) 프로토콜, 암호화(ESP) 프로토콜, 키 관리(IKE) 프로토콜

626. SSL/TLS(Secure Socket Layer/Transport Layer Security)
  ㄴ 전송계층과 응용계층 사이에서 클라이언트와 서버 간의 웹 데이터 암호화, 상호 인증 및 전송 시 데이터 무결성을 보장하는 보안 프로토콜
  ㄴ SSL/TLS보안기능: 기밀성, 상호인증, 메시지 무결성

627. S-HTTP(Secure Hypertext Transfer Protocol)
  ㄴ 웹상에서 네트워크 트래픽을 암호화하는 주요 방법 중 하나로 클라이언트와 서버 간에 전송되는 모든 메시지를 각각 암호화하여 전송하는 기술

628. 시큐어 코딩 가이드: 입보시 에코캡아
  ㄴ 입력 데이터 검증 및 표현
  ㄴ 보안 기능
  ㄴ 시간 및 상태
  ㄴ 에러 처리
  ㄴ 코드 오류
  ㄴ 캡슐화
  ㄴ API 오용

629. 입력 데이터 검증 및 표현 취약점
  ㄴ XSS(Cross Site Script): 검증되지 않은 외부 입력 데이터가 포함 된 웹페이지가 전송되는 경우, 사용자가 해당 웹페이지를 열람함으로써 웹페이지에 포함된 부적절한 스크립트가 실행되는 공격
  ㄴ 사이트 간 요청 위조(CSRF;Cross Site Request Forgery): 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 하는 공격
  ㄴ SQL Injection: 응용 프로그램의 보안 취약점을 이용해서 악의적인 SQL 구문을 삽입, 실행시켜서 데이터베이스의 접근을 통해 정보를 탈취하거나 조작 등의 행위를 하는 공격기법

630. 보안 기능 취약점
  ㄴ 적절한 인증 없이 중요기능 허용
  ㄴ 부적절한 인가
  ㄴ 취약한 암호화 알고리즘 사용
  ㄴ 중요 정보 평문 저장 및 전송
  ㄴ 하드 코드 된 비밀번호

631. 에러처리 취약점
  ㄴ 취약한 패스워드 요구 조건
  ㄴ 오류 메시지 통한 정보 노출
  ㄴ 오류 상황 대응 부재
  ㄴ 적절하지 않은 예외처리

632. 세션 통제 취약점
  ㄴ 불충분한 세션 관리

633. 코드오류 취약점
  ㄴ 널 포인터 참조
  ㄴ 정수를 문자로 변환
  ㄴ 부적절한 자원 해제
  ㄴ 초기화되지 않은 변수 사용

634. 소프트웨어 테스트 개념
  ㄴ 개발된 응용 애플리케이션이나 시스템이 사용자가 요구하는 기능과 성능, 사용성, 안정성 등을 만족하는지 확인하고, 노출되지 않은 숨어있는 결함을 찾는 활동

635. 소프트웨어 테스트 필요성: 발예향
  ㄴ 오류 발견 관점
  ㄴ 오류 예방 관점
  ㄴ 품질 향상 관점

636. 소프트웨어 테스트의 기본 원칙: 결완초집 살정오
  ㄴ 테스팅은 결함이 존재함을 밝히는 것: 결함이 없다는 것을 증명할 수는 없음, 결함이 존재함을 밝히는 활동
  ㄴ 완벽한 테스팅은 불가능: 완벽한 테스팅하려는 시도는 불필요한 시간과 자원 낭비, 무한경로, 무한입력값으로 인한 테스트 어려움
  ㄴ 개발 초기에 테스팅 시작: 조기 테스트 설계시 결과를 단시간에 알 수 있고, 테스팅 기간 단축, 재작업을 줄여 개발기간 단축 및 결함 예방 개발 초기에 체계적인 분석 및 설계가 수행되지 못하면 프로젝트 후반에 영향을 미치게 되어 비용이 커진다는 요르돈 법칙 적용
  ㄴ 결함 집중: 적은 수의 모듈에서 대다수의 결함이 발견됨, 파레토 법칙 내용 적용 소프트웨어 테스트 오류의 80%는 전체 모듈 20% 내에서 발견
  ㄴ 살충제 패러독스: 동일한 테스트 케이스에 의한 반복 테스트는 새로운 버그를 찾지 못함, 정기적 리뷰와 개선 및 다른 시각 접근 필요
  ㄴ 테스팅은 정황에 의존적: 소프트웨어 성격에 맞게 테스팅 실시, 정황과 비즈니스 도메인에 따라 테스트를 다르게 수행
  ㄴ 오류-부재의 궤변: 요구사항을 충족시키지 못한다면, 결함이 없다해도 품질이 높다고 볼 수 없음.

637. 프로그램 실행 여부에 따른 테스트 분류
  ㄴ 정적 테스트: 테스트 대상을 실행하지 않고 구조를 분석하여 논리성 검증
  ㄴ 동적 테스트: 소프트웨어를 실행하는 방식으로 테스트를 수행하여 결함 검출

638. 화이트 박스 테스트: 각 응용 프로그램의 내부 구조와 동작을 검사하는 소프트웨어 테스트
  ㄴ 코드 분석과 프로그램 구조에 대한 지식을 바탕으로 문제 발생 가능성 있는 모듈 내부 테스트, 모든 문장을 한 번 이상 수행함으로써 진행되고, 산출물의 기능 별로 적절한 프로그램의 제어 구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로 점검

639. 화박테스트 유형: 구결조 조변다 기제데
  ㄴ 구문 커버리지: 프로그램 내의 모든 명령문을 적어도 한 번 이상 수행하는 커버리지
  ㄴ 결정 커버리지: 결정 포인트 내의 전체 조건식이 적어도 한번은 참과 거짓의 결과를 수행하는 테스트 커버리지
  ㄴ 조건 커버리지: 결정 포인트 내 각 개별 조건식이 적어도 한번은 참과 거짓의 결과를 수행하는 테스트 커버리지
  ㄴ 조건/결정 커버리지: 전체 조건식 뿐만 아니라 개별 조건식도 참 한번, 거짓 한번의 결과가 되도록 수행하는 테스트 커버리지
  ㄴ 변경 조건/결정 커버리지: 개별 조건식이 다른 개별 조건식에 여향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 함으로써 조건/결정 커버리지를 향상시킨 커버리지
  ㄴ 다중 조건 커버리지: 다중 조건 커버리지는 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 커버리지
  ㄴ 기본 경로 커버리지: 기본 경로 커버리지는 수행 가능한 모든 경로를 테스트 하는 기법
  ㄴ 제어 흐름 테스트: 프로그램 제어 구조를 그래프 형태로 나타내어 내부 로직을 테스트 하는 기법
  ㄴ 데이터 흐름 테스트: 제어 흐름 그래프에 데이터 사용현황을 추가한 그래프를 통해 테스트하는 기법

640. 블랙박스 테스트: 동경결상 유분페원비
  ㄴ 외부 사용자의 요구사항 명세를 보면서 수행하는 테스트

641.  블랙박스 테스트 유형
  ㄴ 동등분할 테스트: 입력 데이터의 영역을 유사한 도메인별로 유횻값/무횻값을 그룹핑하여 대표값 테스트 케이스를 도출하여 테스트 하는 기법
  ㄴ 경곗값 분석 테스트: 등가 분할 후 경곗값 부분에서 오류 발생 확률이 높기 때문에 경곗값을 포함하여 테스트 케이스를 설계하여 테스트 하는 기법
  ㄴ 결정 테이블 테스트: 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합하여 테스트 하는 기법
  ㄴ 상태 전이 테스트: 테스트 대상 시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트 기법
  ㄴ 유스케이스 테스트: 시스템이 실제 사용되는 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트케이스를 명세화하여 수행하는 테스트 기법
  ㄴ 분류 트리 테스트: SW의 일부 또는 전체를 트리구조로 분석 및 표현하여 테스트 케이스를 설계하여 테스트하는 기법
  ㄴ 페어와이즈 테스트: 테스트 데이터값들 간에 최소한 한 번씩을 조합하는 방식이며, 이는 커버해야할 기능적 범위를 모든 조합에 비해 상대적으로 적응 양의 테스트세트를 구성하기 위한 테스트 기법
  ㄴ 원인-결과 그래프 테스트: 그래프를 활용하여 입력 데이터 간에 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정하여 테스트하는 기법
  ㄴ 비교 테스트: 여러 버전의 프로그램에 같은 입력값을 넣어서 동일한 결과 데이터가 나오는지 비교해보는 테스트 기법

642. 테스트 오라클 개념
  ㄴ 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참 값을 입력하여 비교하는 기법

643. 테스트 오라클 종류: 참샘휴일
  ㄴ 참 오라클: 모든 입력값에 대하여 기대하는 결과를 생성함으로써 발생된 오류를 모두 검출할 수 있는 오라클
  ㄴ 샘플링 오라클: 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해 주는 오라클
  ㄴ 휴리스틱 오라클: 샘플링 오라클을 개선한 오라클로, 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱으로 처리하는 오라클
  ㄴ 일관성 검사 오라클: 애플리케이션 변경이 있을 때, 수행 전과 후의 결괏값이 동일한지 확인하는 오라클

644. 테스트 레벨 종류: 단통시인
  ㄴ 단위 테스트: 사용자 요구사항에 대한 단위 모듈, 서브 루틴 등을 테스트 하는 단계
  ㄴ 통합 테스트: 단위 테스트를 통과한 모듈 사이 인터페이스, 통합된 컴포넌트 간의 상호작용을 검증하는 테스트 단계
  ㄴ 시스템 테스트: 통합된 단위 시스템의 기능이 시스템에서 정상적으로 수행되는 지를 검증하는 단계
  ㄴ 인수 테스트: 계약상의 요구사항이 만족되었는지 확인하기 위한 테스트 단계

645. V모델
  ㄴ SW 생명주기 각 단계별로 개발자 관점에서의 공정 과정상 검증과 사용자 관점에서의 최종 산출물에 대한 확인을 지원하기 위한 테스트 모델

646. 인수 테스트 종류
  ㄴ 사용자 인수 테스트: 사용자가 시스템 사용의 적절성 여부 확인
  ㄴ 운영상의 인수 테스: 시스템 관리자가 시스템 인수 시 수행하는 테스트, 백업/복원, 재해 복구, 사용자 관리 등을 확인
  ㄴ 계약 인수 테스트: 계약 상의 인수/검수 조건을 준수하는지 여부 등을 확인
  ㄴ 규정 인수 테스트: 정부 지침, 법규, 규정 등에 맞게 개발되었는지 확인
  ㄴ 알파 테스트: 선택된 사용자가 개발자 환경에서 통제된 상태로 개발자와 함께 수행하는 인수 테스트
  ㄴ 베타 테스트: 실제 환경에서 일정 수의 사용자에게 대상 소프트웨어를 사용하게 하고 피드백을 받는 인수테스트

647. 테스트 시나리오 개념
  ㄴ 테스트 수행을 위한 여러 테스트 케이스의 집합으로서, 케이스의 동작 순서를 기술한 문서이며 테스트를 위한 절차를 명세한 문서이다.

648. 목 객체 유형
  ㄴ 더미 객체: 테스트할 때 객체만 필요하고, 해당 객체의 기능까지는 필요하지 않은 겨웅에 사용, 더미 객체의 메서드가 호출되면 예외 수행
  ㄴ 테스트 스텁: 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구
  ㄴ 테스트 드라이버: 테스트 대상 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 수행 후의 결과를 도출
  ㄴ 테스트 스파이: 주로 테스트 대상 클래스와 협력하는 클래스로 가는 출력을 검증하는 데 사용
  ㄴ 가짜 객체: 실제 협력 클래스의 기능을 대체해야 할 경우에 사용

649. 하향식 통합: ㄱ메인 제어 모듈로부터 아래 방향으로 제어의 경로를 따라 이동하면서 하향식으로 통합하면서 테스트를 진행하며,메인 제어 모듈에 통합되는 하위 모듈과 최 하위 모듈은 '깊이-우선' 또는 '너비-우선' 방식으로 통합된다.
 
650. 상향식 통합: 애플리케이션 구조에서 최하위 레벨의 모듈 또는 컴포넌트로부터 위쪽 방향으로 제어의 경로를 따라 이동하면서 구축과 테스트 수행

651. 하스 상드: 하향식-스텁, 상향식-드라이버
  ㄴ 스텁: 모듈 및 모든 하위 컴포넌트를 대신하는 더미 모듈, 스텁은 하위 모듈의 반환 값만 전달하면 됨
  ㄴ 드라이버: 상위의 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈

652. 테스트 자동화 도구 유형: 정실성통
  ㄴ 정적 분석 도구: 만들어진 애플리케이션을 실행하지 않고 분석하는 도구, 작성된 소스 코드에 대한 이해를 바탕으로 도구를 이용해 분석
  ㄴ 테스트 실행 도구: 스크립트를 실행하고, 작성된 스크립트는 각 스크립트마다 특정 데이터와 테스트 수행 방법을 포함하고 있다. 
  ㄴ 성능 테스트 도구: 애플리 케이션의 처리량, 응답 시간, 경과 시간, 자원 사용률에 대해 가상의 사용자를 생성하고 테스트 수행
  ㄴ 테스트 통제 도구: 테스트 계획 및 관리를 위한 테스트 관리 도구, 테스트 수행에 필요한 데이터와 도구를 관리하는 형상 관리도구, 결함/추적 관리 도구 등이 있다.

653. 테스트 하네스
  ㄴ 애플리케이션 컴포넌트 및 모듈을 테스트 하는 환경의 일부분으로, 테스트를 지원하기 위한 코드와 데이터를 말함

654. 테스트 하네스 구성요소
  ㄴ 테스트 드라이버: 테스트 대상 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 수행 후의 결과를 도출하는 등 상향식 테스트에 필요
  ㄴ 테스트 스텁: 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로 하향식 테스트에 필요
  ㄴ 테스트 슈트: 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합
  ㄴ 테스트 케이스: 입력값, 실행 조건, 기대 결과 등의 집합
  ㄴ 테스트 스크립트
  ㄴ 목 오브젝트

655. 애플리케이션 성능 측정 지표
  ㄴ 처리량(Throughput): 애플리케이션이 주어진 시간에 처리할 수 있는 트랜잭션의 수
  ㄴ 응답시간(Response Time): 사용자 입력이 끝난 후, 애플리케이션의 응답 출력이 개시될 때 까지의 시간
  ㄴ 경과시간(Turnaround Time): 애플리케이션에 사용자가 요구를 입력한 시점부터 트랜잭션을 처리 후 그 결과의 출력이 완료할 때까지 걸리는 시간
  ㄴ 자원 사용률(Resource Usage): 애플리케이션이 트랜잭션을 처리하는 동안 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량

656. 외계인 코드: 아주 오래되거나 참고 문서 또는 개발자가 없어 유지보수 작업이 아주 어려운 코드

657. 스파게티 코드: 컴퓨터 프로그램의 소스 코드가 복잡하게 얽힌 모습을 스파게티의 면발에 비유한 표현, 작동은 정상적으로 하지만, 코드를 읽으면서 그 코드의 작동을 파악하기는 어려운 코드

658. 클린 코드 작성 원칙 : 가단의중추
  ㄴ 가독성
  ㄴ 단순성
  ㄴ 의존성 최소
  ㄴ 중복성 제거
  ㄴ 추상화

659. 리팩토링 개념
  ㄴ 유지보수 생산성 향상을 목적으로 기능을 변경하지 않고, 복잡한 소스 코드를 수정, 보완하여 가용성 및 가독성을 높이는 기법
  ㄴ 소프트웨어 모듈의 외부적 기능은 수정하지 않고 내부적으로 구조, 관계 등을 단순화하여 소프트웨어의 유지보수성을 향상시키는 기법

660. 리팩토링의 목적: 유유생품
  ㄴ 유지보수성 향상, 유연한 시스템, 생산성 향상, 품질 향상

661. 운영체제 개념
  ㄴ 사용자가 컴퓨터의 하드웨어를 쉽게 사용할 수 있도록 인터페이스를 제공해주는 소프트웨어
  ㄴ 한정된 시스템 자원을 효과적으로 사용할 수 있도록 관리 및 운영함으로써 사용자에게 편리성을 제공한다.

662. 운영체제 특징
  ㄴ 사용자 편리성 제공, 인터페이스 기능 담당, 스케줄링 담당, 자원관리, 제어 기능

663. 운영체제에서 커널의 기능
  ㄴ 운영체제는 크게 인터페이스 + 커널의 구조이다.
  ㄴ 커널: 운영체제 핵심이 되는 기능들이 모여 있는 프로그램
  ㄴ 프로세스 관리, 기억장치 관리, 주변장치 관리, 파일 관리

664. 접근 명령어 chmod
Rwx - 421, Read, Write, excute 









